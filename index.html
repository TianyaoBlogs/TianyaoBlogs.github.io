<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tianyaoblogs.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="TianyaoBlogs">
<meta property="og:url" content="https://tianyaoblogs.github.io/index.html">
<meta property="og:site_name" content="TianyaoBlogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tianyaoblogs.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TianyaoBlogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TianyaoBlogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/10/13/5054C6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/13/5054C6/" class="post-title-link" itemprop="url">MSDM 5054 - Statistical Machine Learning-L6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-13 21:00:00" itemprop="dateCreated datePublished" datetime="2025-10-13T21:00:00+08:00">2025-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-20 03:45:06" itemprop="dateModified" datetime="2025-10-20T03:45:06+08:00">2025-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计机器学习Lecture-6</p>
<p><a target="_blank" rel="noopener" href="https://www.math.hkust.edu.hk/~madxia/">Lecturer: Prof.XIA
DONG</a></p>
<h1
id="linear-model-selection-and-regularization-线性模型选择与正则化">1.
Linear Model Selection and Regularization 线性模型选择与正则化</h1>
<h2 id="summary-of-core-concepts">Summary of Core Concepts</h2>
<p><strong>Chapter 6: Linear Model Selection and
Regularization</strong>, focusing specifically on <strong>Section 6.1:
Subset Selection</strong>.
<strong>第六章：线性模型选择与正则化</strong>，<strong>6.1节：子集选择</strong></p>
<ul>
<li><p><strong>The Problem:</strong> You have a dataset with many
potential predictor variables (features). If you include all of them
(like <strong>Model 1</strong> with <span
class="math inline">\(p\)</span> predictors in slide
<code>...221320.png</code>), you risk including “noise” variables. These
irrelevant features can decrease model accuracy (overfitting) and make
the model difficult to interpret.
数据集包含许多潜在的预测变量（特征）。如果包含所有这些变量（例如幻灯片“…221320.png”中带有<span
class="math inline">\(p\)</span>个预测变量的<strong>模型1</strong>），则可能会包含“噪声”变量。这些不相关的特征会降低模型的准确率（过拟合），并使模型难以解释。</p></li>
<li><p><strong>The Goal:</strong> Identify a smaller subset of variables
that are truly related to the response. This creates a simpler, more
interpretable, and often more accurate model (like <strong>Model
2</strong> with <span class="math inline">\(q\)</span> predictors).
找出一个与响应真正相关的较小变量子集。这将创建一个更简单、更易于解释且通常更准确的模型（例如带有<span
class="math inline">\(q\)</span>个预测变量的<strong>模型2</strong>）。</p></li>
<li><p><strong>The Main Method Discussed: Best Subset
Selection</strong></p></li>
<li><p><strong>主要讨论的方法：最佳子集选择</strong> This is an
<em>exhaustive search</em> algorithm. It checks <em>every possible
combination</em> of predictors to find the “best” model. With <span
class="math inline">\(p\)</span> variables, this means checking <span
class="math inline">\(2^p\)</span> total models.
这是一种<em>穷举搜索</em>算法。它检查<em>所有可能的预测变量组合</em>，以找到“最佳”模型。对于
<span class="math inline">\(p\)</span> 个变量，这意味着需要检查总共
<span class="math inline">\(2^p\)</span> 个模型。</p>
<p>The algorithm (from slide <code>...221333.png</code>) works in three
steps:</p>
<ol type="1">
<li><p><strong>Step 1:</strong> Fit the “null model” <span
class="math inline">\(M_0\)</span>, which has no predictors (it just
predicts the average of the response). 拟合“空模型”<span
class="math inline">\(M_0\)</span>，它没有预测变量（它只预测响应的平均值）。</p></li>
<li><p><strong>Step 2:</strong> For each <span
class="math inline">\(k\)</span> (from 1 to <span
class="math inline">\(p\)</span>):</p>
<ul>
<li><p>Fit all <span class="math inline">\(\binom{p}{k}\)</span> models
that contain exactly <span class="math inline">\(k\)</span> predictors.
(e.g., fit all models with 1 predictor, then all models with 2
predictors, etc.).</p></li>
<li><p>拟合所有包含 <span class="math inline">\(k\)</span> 个预测变量的
<span class="math inline">\(\binom{p}{k}\)</span>
个模型。（例如，先拟合所有包含 1 个预测变量的模型，然后拟合所有包含 2
个预测变量的模型，等等）。</p></li>
<li><p>From this group, select the single best model <em>for that size
<span class="math inline">\(k\)</span></em>. This “best” model is the
one with the highest <strong><span
class="math inline">\(R^2\)</span></strong> (or lowest
<strong>RSS</strong> - Residual Sum of Squares) on the <em>training
data</em>. Call this model <span
class="math inline">\(M_k\)</span>.</p></li>
<li><p>从这组中，选择 <em>对于该规模 <span
class="math inline">\(k\)</span></em> 的最佳模型。这个“最佳”模型是在
<em>训练数据</em> 上具有最高 <strong><span
class="math inline">\(R^2\)</span></strong>（或最低 <strong>RSS</strong>
- 残差平方和）的模型。将此模型称为 <span
class="math inline">\(M_k\)</span>。</p></li>
</ul></li>
<li><p><strong>Step 3:</strong> You now have <span
class="math inline">\(p+1\)</span> models: <span
class="math inline">\(M_0, M_1, \dots, M_p\)</span>. You must select the
single best one from this list. To do this, you <strong>cannot</strong>
use training <span class="math inline">\(R^2\)</span> (as it will always
pick the biggest model <span class="math inline">\(M_p\)</span>).
Instead, you must use a metric that estimates <em>test error</em>, such
as: <strong>现在你有 <span class="math inline">\(p+1\)</span>
个模型：<span class="math inline">\(M_0, M_1, \dots,
M_p\)</span>。你必须从列表中选择一个最佳模型。为此，你</strong>不能**使用训练
<span class="math inline">\(R^2\)</span>（因为它总是会选择最大的模型
<span
class="math inline">\(M_p\)</span>）。相反，你必须使用一个能够估计<em>测试误差</em>的指标，例如：</p>
<ul>
<li><strong>Cross-Validation (CV) 交叉验证 (CV)</strong> (This is what
the Python code uses)</li>
<li><strong>AIC</strong> (Akaike Information Criterion
赤池信息准则)</li>
<li><strong>BIC</strong> (Bayesian Information Criterion
贝叶斯信息准则)</li>
<li><strong>Adjusted <span class="math inline">\(R^2\)</span> 调整后的
<span class="math inline">\(R^2\)</span></strong></li>
</ul></li>
</ol></li>
<li><p><strong>Key Takeaway:</strong> The slides show this “subset
selection” concept can be applied <em>beyond</em> linear models. The
Python code demonstrates this by applying best subset selection to a
<strong>K-Nearest Neighbors (KNN) Regressor</strong>, a non-linear
model.“子集选择”的概念可以应用于线性模型<em>之外</em>。</p></li>
</ul>
<h2
id="mathematical-understanding-key-questions-数学理解与关键问题">Mathematical
Understanding &amp; Key Questions 数学理解与关键问题</h2>
<p>This section directly answers the questions posed on your slides.</p>
<h3 id="how-to-compare-which-model-is-better">How to compare which model
is better?</h3>
<p>(From slides <code>...221320.png</code> and
<code>...221326.png</code>)</p>
<p>You cannot use <strong>training error</strong> (like <span
class="math inline">\(R^2\)</span> or RSS) to compare models with
<em>different numbers of predictors</em>. A model with more predictors
will almost always have a better <em>training</em> score, even if those
extra predictors are just noise. This is called
<strong>overfitting</strong>. 不能使用<strong>训练误差</strong>（例如
<span class="math inline">\(R^2\)</span> 或
RSS）来比较具有<em>不同数量预测变量</em>的模型。具有更多预测变量的模型几乎总是具有更好的<em>训练</em>分数，即使这些额外的预测变量只是噪声。这被称为<strong>过拟合</strong>。</p>
<p>To compare models of different sizes (like Model 1 vs. Model 2, or
<span class="math inline">\(M_2\)</span> vs. <span
class="math inline">\(M_5\)</span>), you <strong>must</strong> use a
method that estimates <strong>test error</strong> (how the model
performs on new, unseen data). The slides mention:
要比较不同大小的模型（例如模型 1 与模型 2，或 <span
class="math inline">\(M_2\)</span> 与 <span
class="math inline">\(M_5\)</span>），您<strong>必须</strong>使用一种估算<strong>测试误差</strong>（模型在新的、未见过的数据上的表现）的方法。</p>
<ul>
<li><p><strong>Cross-Validation (CV):</strong> This is the gold
standard. You split your data into “folds,” train the model on some
folds, and test it on the remaining fold. You repeat this and average
the test scores. The model with the best (e.g., lowest) average CV error
is chosen.
将数据分成“折叠”，在一些折叠上训练模型，然后在剩余的折叠上测试模型。重复此操作并取测试分数的平均值。选择平均
CV 误差最小（例如，最小）的模型。</p></li>
<li><p><strong>AIC &amp; BIC:</strong> These are mathematical
adjustments to the training error (like RSS) that add a <em>penalty</em>
for having more predictors. They balance model <em>fit</em> with model
<em>complexity</em>. 这些是对训练误差（如
RSS）的数学调整，会因预测变量较多而增加<em>惩罚</em>。它们平衡了模型<em>拟合度</em>和模型<em>复杂度</em>。</p></li>
</ul>
<h3 id="why-use-r2-in-step-2">Why use <span
class="math inline">\(R^2\)</span> in Step 2?</h3>
<p>(From slide <code>...221333.png</code>)</p>
<p>In Step 2, you are only comparing models <strong>of the same
size</strong> (i.e., all models that have exactly <span
class="math inline">\(k\)</span> predictors). For models with the same
number of parameters, a higher <span class="math inline">\(R^2\)</span>
(or lower RSS) on the training data directly corresponds to a better
fit. You don’t need to penalize for complexity because all models being
compared <em>have the same complexity</em>.
只比较<strong>大小相同</strong>的模型（即所有恰好具有 <span
class="math inline">\(k\)</span>
个预测变量的模型）。对于参数数量相同的模型，训练数据上更高的 <span
class="math inline">\(R^2\)</span>（或更低的
RSS）直接对应着更好的拟合度。您不需要对复杂度进行惩罚，因为所有被比较的模型<em>都具有相同的复杂度</em>。</p>
<h3 id="why-cant-we-use-training-error-in-step-3">Why can’t we use
training error in Step 3?</h3>
<p>(From slide <code>...221333.png</code>)</p>
<p>In Step 3, you are comparing models <strong>of different
sizes</strong> (<span class="math inline">\(M_0\)</span> vs. <span
class="math inline">\(M_1\)</span> vs. <span
class="math inline">\(M_2\)</span>, etc.). As you add predictors, the
training <span class="math inline">\(R^2\)</span> will <em>always</em>
go up (or stay the same), and the training RSS will <em>always</em> go
down (or stay the same). If you used <span
class="math inline">\(R^2\)</span> to pick the best model in Step 3, you
would <em>always</em> pick the most complex model <span
class="math inline">\(M_p\)</span>, which is almost certainly overfit.
将比较<strong>不同大小</strong>的模型（例如 <span
class="math inline">\(M_0\)</span> vs. <span
class="math inline">\(M_1\)</span> vs. <span
class="math inline">\(M_2\)</span> 等）。随着您添加预测变量，训练 <span
class="math inline">\(R^2\)</span>
将<em>始终</em>上升（或保持不变），而训练 RSS
将<em>始终</em>下降（或保持不变）。如果您在步骤 3 中使用 <span
class="math inline">\(R^2\)</span>
来选择最佳模型，那么您<em>始终</em>会选择最复杂的模型 <span
class="math inline">\(M_p\)</span>，而该模型几乎肯定会过拟合。</p>
<p>Therefore, you <em>must</em> use a metric that estimates test error
(like CV) or penalizes for complexity (like AIC, BIC, or Adjusted <span
class="math inline">\(R^2\)</span>) to find the right balance between
fit and simplicity. 因此，您<em>必须</em>使用一个可以估算测试误差（例如
CV）或惩罚复杂度（例如 AIC、BIC 或调整后的 <span
class="math inline">\(R^2\)</span>）的指标来找到拟合度和简单性之间的平衡。</p>
<h2 id="code-analysis">Code Analysis</h2>
<p>The Python code (slides <code>...221249.jpg</code> and
<code>...221303.jpg</code>) implements the <strong>Best Subset
Selection</strong> algorithm using <strong>KNN Regression</strong>.</p>
<h3 id="key-functions">Key Functions</h3>
<ul>
<li><code>main()</code>:
<ol type="1">
<li><strong>Loads Data:</strong> Reads the <code>Credit.csv</code>
file.</li>
<li><strong>Preprocesses Data:</strong>
<ul>
<li>Converts categorical features (‘Gender’, ‘Student’, ‘Married’,
‘Ethnicity’) into numerical ones (dummy variables).
将分类特征（“性别”、“学生”、“已婚”、“种族”）转换为数值特征（虚拟变量）。</li>
<li>Creates the feature matrix <code>X</code> and target variable
<code>y</code> (‘Balance’). 创建特征矩阵 <code>X</code> 和目标变量
<code>y</code>（“余额”）。</li>
<li><strong>Scales</strong> the features using
<code>StandardScaler</code>. This is crucial for KNN, which is sensitive
to the scale of features. 用 <code>StandardScaler</code>
对特征进行<strong>缩放</strong>。这对于 KNN
至关重要，因为它对特征的缩放非常敏感。</li>
</ul></li>
<li><strong>Adds Noise (in the second example):</strong> Slide
<code>...221303.jpg</code> shows code that <em>adds 20 new “noisy”
columns</em> to the data. This is to test if the selection algorithm is
smart enough to ignore them. 向数据中添加 20
个新的“噪声”列的代码。这是为了测试选择算法是否足够智能，能够忽略它们。</li>
<li><strong>Runs Selection:</strong> Calls
<code>best_subset_selection_parallel</code> to do the main work.</li>
<li><strong>Prints Results:</strong> Finds the best subset (lowest
error) and prints the top 20 best-performing subsets.
找到最佳子集（误差最小），并打印出表现最佳的前 20 个子集。</li>
<li><strong>Final Evaluation:</strong> It re-trains a KNN model on
<em>only</em> the best subset and calculates the final cross-validated
RMSE. 仅基于最佳子集重新训练 KNN 模型，并计算最终的交叉验证 RMSE。</li>
</ol></li>
<li><code>evaluate_subset(subset, ...)</code>:
<ul>
<li>This is the “worker” function. It’s called for <em>every single</em>
possible subset.</li>
<li>It takes a <code>subset</code> (a list of feature names, e.g.,
<code>['Income', 'Limit']</code>).</li>
<li>It creates a new <code>X_subset</code> containing <em>only</em>
those columns.</li>
<li>It runs 5-fold cross-validation (<code>cross_val_score</code>) on a
KNN model using this <code>X_subset</code>.</li>
<li>It uses <code>'neg_mean_squared_error'</code> as the metric. This is
negative MSE; a <em>higher</em> score (closer to 0) is better.
它会创建一个新的“X_subset”<em>，仅包含这些列。 它会使用此“X_subset”在
KNN 模型上运行 5 倍交叉验证（“cross_val_score”）。
它使用“neg_mean_squared_error”作为度量标准。这是负
MSE；</em>更高*的分数（越接近 0）越好。</li>
<li>It returns the subset and its average CV score.</li>
</ul></li>
<li><code>best_subset_selection_parallel(model, ...)</code>:
<ul>
<li>This is the “manager” function.这是“管理器”函数。</li>
<li>It iterates from <code>k=1</code> up to the total number of
features.它从“k=1”迭代到特征总数。</li>
<li>For each <code>k</code>, it generates <em>all combinations</em> of
features of that size (this is the <span
class="math inline">\(\binom{p}{k}\)</span> part).
对于每个“k”，它会生成该大小的特征的<em>所有组合</em>（这是 <span
class="math inline">\(\binom{p}{k}\)</span> 部分）。</li>
<li>It uses <code>Parallel</code> and <code>delayed</code> (from
<code>joblib</code>) to run <code>evaluate_subset</code> for all these
combinations <em>in parallel</em>, speeding up the process
significantly. 它使用 <code>Parallel</code> 和
<code>delayed</code>（来自
<code>joblib</code>）对所有这些组合<em>并行</em>运行
<code>evaluate_subset</code>，从而显著加快了处理速度。</li>
<li>It collects all the results and returns
them.它收集所有结果并返回。</li>
</ul></li>
</ul>
<h3 id="analysis-of-the-output">Analysis of the Output</h3>
<ul>
<li><strong>Slide <code>...221255.png</code> (Original Data):</strong>
<ul>
<li>The code runs subset selection on the original dataset.</li>
<li>The “Top 20 Best Feature Subsets” are shown. The CV scores are
negative (they are <code>neg_mean_squared_error</code>), so the scores
<em>closest to zero</em> (smallest magnitude) are best.</li>
<li>The <strong>Best feature subset</strong> is found to be
<code>('Income', 'Limit', 'Rating', 'Student')</code>.</li>
<li>The final cross-validated RMSE for this model is
<strong>105.41</strong>.</li>
</ul></li>
<li><strong>Slide <code>...221309.png</code> (Data with 20 Noisy
Variables):</strong>
<ul>
<li>The code is re-run after adding 20 useless “Noisy” features.</li>
<li>The algorithm <em>still</em> works. It correctly identifies that the
“Noisy” variables are useless.</li>
<li>The <strong>Best feature subset</strong> is now
<code>('Income', 'Limit', 'Student')</code>. (Note: ‘Rating’ was
dropped, likely because it’s highly correlated with ‘Limit’, and the
noisy data made the simpler model perform slightly better in CV).</li>
<li>The final RMSE is <strong>114.94</strong>. This is <em>higher</em>
than the original 105.41, which is expected—the presence of so many
noise variables makes the selection problem harder, but the final model
is still good and, most importantly, <em>it successfully excluded all 20
noisy features</em>. 最终的 RMSE 为 <strong>114.94</strong>。这比最初的
105.41<em>更高</em>，这是预期的——如此多的噪声变量的存在使得选择问题更加困难，但最终模型仍然很好，最重要的是，<em>它成功地排除了所有
20 个噪声特征</em>。</li>
</ul></li>
</ul>
<h2 id="conceptual-overview-the-why">Conceptual Overview: The “Why”</h2>
<p>Slides cover <strong>Chapter 6: Linear Model Selection and
Regularization</strong>, which is all about a fundamental trade-off in
machine learning: the <strong>bias-variance trade-off</strong>.
该部分主要讨论机器学习中的一个基本权衡：<strong>偏差-方差权衡</strong>。</p>
<ul>
<li><p><strong>The Problem (Slide <code>...221320.png</code>):</strong>
Imagine you have a dataset with 50 predictors (<span
class="math inline">\(p=50\)</span>). You want to predict a response
<span class="math inline">\(y\)</span>. 假设你有一个包含 50
个预测变量（p=50）的数据集。你想要预测响应 <span
class="math inline">\(y\)</span>。</p>
<ul>
<li><strong>Model 1 (Full Model):</strong> You use all 50 predictors.
This model is very <strong>flexible</strong>. It will fit the
<em>training data</em> extremely well, resulting in a low
<strong>bias</strong>. However, it’s highly likely that many of those 50
predictors are just “noise” (random, unrelated variables). By fitting to
this noise, the model will be <strong>overfit</strong>. When you show it
new, unseen data (the <em>test data</em>), it will perform poorly. This
is called <strong>high variance</strong>. 你使用了所有 50
个预测变量。这个模型非常<strong>灵活</strong>。它能很好地拟合<em>训练数据</em>，从而产生较低的<strong>偏差</strong>。然而，这
50
个预测变量中很可能有很多只是“噪声”（随机的、不相关的变量）。由于拟合这些噪声，模型会<strong>过拟合</strong>。当你向它展示新的、未见过的数据（<em>测试数据</em>）时，它的表现会很差。这被称为<strong>高方差</strong>。</li>
<li><strong>Model 2 (Subset Model):</strong> You intelligently select
only the 3 predictors (<span class="math inline">\(q=3\)</span>) that
are <em>actually</em> related to <span class="math inline">\(y\)</span>.
This model is less flexible. It won’t fit the <em>training data</em> as
perfectly as Model 1 (it has higher <strong>bias</strong>). But, because
it’s <em>not</em> fitting the noise, it will generalize much better to
new data. It will have a much lower <strong>variance</strong>, and thus
a lower overall <em>test error</em>. 你智能地只选择与 <span
class="math inline">\(y\)</span> <em>真正</em>相关的 3 个预测变量 (<span
class="math inline">\(q=3\)</span>)。这个模型的灵活性较差。它对
<em>训练数据</em> 的拟合度不如模型 1
完美（它的<strong>偏差</strong>更高）。但是，由于它对噪声的拟合度更高，因此对新数据的泛化能力会更好。它的<strong>方差</strong>会更低，因此总体的<em>测试误差</em>也会更低。</li>
</ul></li>
<li><p><strong>The Goal:</strong> The goal is to find the model that has
the <strong>lowest test error</strong>. We need a formal method to
<em>find</em> the best subset (like Model 2) without just guessing.
<strong>目标是找到</strong>测试误差**最低的模型。我们需要一个正式的方法来<em>找到</em>最佳子集（例如模型
2），而不是仅仅靠猜测。</p></li>
<li><p><strong>Two Main Strategies (Slide
<code>...221314.png</code>):</strong></p>
<ol type="1">
<li><p><strong>Subset Selection (Section 6.1):</strong> This is what
we’re focused on. It’s an “all-or-nothing” approach. You either
<em>keep</em> a variable in the model or you <em>discard</em> it
completely. The “Best Subset Selection” algorithm is the most extreme,
“brute-force” way to do this.
是我们关注的重点。这是一种“全有或全无”的方法。你要么在模型中“保留”一个变量，要么“彻底丢弃”它。“最佳子集选择”算法是最极端、最“暴力”的做法。</p></li>
<li><p><strong>Shrinkage/Regularization (Section 6.2):</strong> This is
a more subtle approach (e.g., Ridge Regression, LASSO). Instead of
discarding variables, you <em>keep all <span
class="math inline">\(p\)</span> variables</em> but add a penalty to the
model that “shrinks” the coefficients (<span
class="math inline">\(\beta\)</span>) of the useless variables towards
zero.
这是一种更巧妙的方法（例如，岭回归、LASSO）。你不是丢弃变量，而是<em>保留所有
<span class="math inline">\(p\)</span>
个变量</em>，但会给模型添加一个惩罚项，将无用变量的系数（<span
class="math inline">\(\beta\)</span>）“收缩”到零。</p></li>
</ol></li>
</ul>
<h2 id="questions">Questions 🎯</h2>
<h3 id="q1-how-to-compare-which-model-is-better">Q1: “How to compare
which model is better?”</h3>
<p>(From slides <code>...221320.png</code> and
<code>...221326.png</code>)</p>
<p>This is the most important question. You <strong>cannot</strong> use
metrics based on <em>training data</em> (like <span
class="math inline">\(R^2\)</span> or RSS - Residual Sum of Squares) to
compare models with <em>different numbers of predictors</em>.
这是最重要的问题。您<strong>不能</strong>使用基于<em>训练数据</em>的指标（例如
R^2 或 RSS - 残差平方和）来比较具有<em>不同数量预测变量</em>的模型。</p>
<ul>
<li><p><strong>The Trap:</strong> A model with more predictors will
<em>always</em> have a higher <span class="math inline">\(R^2\)</span>
(or lower RSS) on the data it was trained on. <span
class="math inline">\(R^2\)</span> will <em>always</em> increase as you
add variables, even if they are pure noise. If you used <span
class="math inline">\(R^2\)</span> to compare a 3-predictor model to a
10-predictor model, the 10-predictor model would <em>always</em> look
better on paper, even if it’s terribly overfit.
具有更多预测变量的模型在其训练数据上<em>总是</em>具有更高的
R^2（或更低的 RSS）。随着变量的增加，R^2
会<em>总是</em>增加，即使这些变量是纯噪声。如果您使用 R^2 来比较 3
个预测变量的模型和 10 个预测变量的模型，那么 10
个预测变量的模型在纸面上<em>总是</em>看起来更好，即使它严重过拟合。</p></li>
<li><p><strong>The Correct Way:</strong> You must use a metric that
estimates the <strong>test error</strong>. The slides and code show two
ways:您必须使用一个能够估计<strong>测试误差</strong>的指标。</p>
<ol type="1">
<li><strong>Cross-Validation (CV):</strong> This is the method used in
your Python code. It works by:
<ul>
<li>Splitting your training data into <span
class="math inline">\(k\)</span> “folds” (e.g., 5 folds).
将训练数据拆分成 <span class="math inline">\(k\)</span> 个“折叠”（例如 5
个折叠）。</li>
<li>Training the model on 4 folds and testing it on the 5th fold.
使用其中 4 个折叠训练模型，并使用第 5 个折叠进行测试。</li>
<li>Repeating this 5 times, so each fold gets to be the test set once.
重复此操作 5 次，使每个折叠都作为测试集一次。</li>
<li>Averaging the 5 test errors. 对 5 个测试误差求平均值。 This gives
you a robust estimate of how your model will perform on <em>unseen
data</em>. You then choose the model with the best (lowest) average CV
error.
这可以让你对模型在<em>未见数据</em>上的表现有一个稳健的估计。然后，你可以选择平均
CV 误差最小（最佳）的模型。</li>
</ul></li>
<li><strong>Mathematical Adjustments (AIC, BIC, Adjusted <span
class="math inline">\(R^2\)</span>):</strong> These are formulas that
take the training error (like RSS) and add a <em>penalty</em> for each
predictor (<span class="math inline">\(k\)</span>) you add.
<ul>
<li><span class="math inline">\(AIC \approx RSS +
2k\sigma^2\)</span></li>
<li><span class="math inline">\(BIC \approx RSS +
\log(n)k\sigma^2\)</span> A model with more predictors (larger <span
class="math inline">\(k\)</span>) gets a bigger penalty. To be chosen, a
more complex model must <em>significantly</em> improve the RSS to
overcome this penalty. 预测变量越多（k
越大）的模型，惩罚越大。要被选中，更复杂的模型必须<em>显著</em>提升 RSS
以克服此惩罚。</li>
</ul></li>
</ol></li>
</ul>
<h3 id="q2-why-using-r2-for-step-2">Q2: “Why using <span
class="math inline">\(R^2\)</span> for step 2?”</h3>
<p>(From slide <code>...221333.png</code>)</p>
<p><strong>Step 2</strong> of the “Best Subset Selection” algorithm
says: “For <span class="math inline">\(k = 1, \dots, p\)</span>: Fit all
<span class="math inline">\(\binom{p}{k}\)</span> models… Pick the best
model, that with the largest <span class="math inline">\(R^2\)</span>, …
and call it <span class="math inline">\(M_k\)</span>.” “对于 <span
class="math inline">\(k = 1, \dots, p\)</span>：拟合所有 <span
class="math inline">\(\binom{p}{k}\)</span> 个模型……选择具有最大 <span
class="math inline">\(R^2\)</span> 的最佳模型……并将其命名为 <span
class="math inline">\(M_k\)</span>。”</p>
<ul>
<li><strong>The Reason:</strong> In Step 2, you are <em>only</em>
comparing models <strong>of the same size</strong>. For example, when
<span class="math inline">\(k=3\)</span>, you are comparing all possible
3-predictor models: 步骤 2
中，您<em>仅</em>比较**相同大小的模型。例如，当 <span
class="math inline">\(k=3\)</span> 时，您将比较所有可能的 3
预测变量模型：
<ul>
<li>Model A: (<span class="math inline">\(X_1, X_2, X_3\)</span>)</li>
<li>Model B: (<span class="math inline">\(X_1, X_2, X_4\)</span>)</li>
<li>Model C: (<span class="math inline">\(X_1, X_3, X_5\)</span>)</li>
<li>…and so on.</li>
</ul>
Since all these models have the <em>exact same complexity</em> (they all
have <span class="math inline">\(k=3\)</span> predictors), there is no
risk of unfairly favoring a more complex model. Therefore, you are free
to use a training metric like <span class="math inline">\(R^2\)</span>
(or RSS). The model with the highest <span
class="math inline">\(R^2\)</span> is, by definition, the one that
<em>best fits the training data</em> for that specific size <span
class="math inline">\(k\)</span>.
由于所有这些模型都具有<em>完全相同的复杂度</em>（它们都具有 <span
class="math inline">\(k=3\)</span>
个预测变量），因此不存在不公平地偏向更复杂模型的风险。因此，您可以自由使用像
<span class="math inline">\(R^2\)</span>（或
RSS）这样的训练指标。根据定义，具有最高 <span
class="math inline">\(R^2\)</span> 的模型就是在特定大小 <span
class="math inline">\(k\)</span>
下<em>与训练数据拟合度</em>最高的模型。</li>
</ul>
<h3
id="q3-cannot-use-training-error-in-step-3.-why-not-步骤-3-中不能使用训练误差-为什么">Q3:
“Cannot use training error in Step 3.” Why not? “步骤 3
中不能使用训练误差。” 为什么？</h3>
<p>(From slide <code>...221333.png</code>)</p>
<p><strong>Step 3</strong> says: “Select a single best model from <span
class="math inline">\(M_0, M_1, \dots, M_p\)</span> by cross validation,
AIC, or BIC.”“通过交叉验证、AIC 或 BIC，从 <span
class="math inline">\(M_0、M_1、\dots、M_p\)</span>
中选择一个最佳模型。”</p>
<ul>
<li><p><strong>The Reason:</strong> In Step 3, you are now comparing
models <strong>of different sizes</strong>. You are comparing the best
1-predictor model (<span class="math inline">\(M_1\)</span>) vs. the
best 2-predictor model (<span class="math inline">\(M_2\)</span>)
vs. the best 3-predictor model (<span
class="math inline">\(M_3\)</span>), and so on, all the way up to <span
class="math inline">\(M_p\)</span>. 在步骤 3
中，您正在比较<strong>不同大小</strong>的模型。您正在比较最佳的单预测模型
(<span class="math inline">\(M_1\)</span>)、最佳的双预测模型 (<span
class="math inline">\(M_2\)</span>) 和最佳的三预测模型 (<span
class="math inline">\(M_3\)</span>)，依此类推，直到 <span
class="math inline">\(M_p\)</span>。</p>
<p>As explained in Q1, if you used a training error metric like <span
class="math inline">\(R^2\)</span> here, the <span
class="math inline">\(R^2\)</span> would just keep going up, and you
would <em>always</em> select the largest, most complex model, <span
class="math inline">\(M_p\)</span>. This completely defeats the purpose
of model selection. 如问题 1 所述，如果您在此处使用像 <span
class="math inline">\(R^2\)</span> 这样的训练误差指标，那么 <span
class="math inline">\(R^2\)</span>
会持续上升，并且您<em>总是</em>会选择最大、最复杂的模型 <span
class="math inline">\(M_p\)</span>。这完全违背了模型选择的目的。</p>
<p>Therefore, in Step 3, you <em>must</em> use a method that estimates
<strong>test error</strong> (like Cross-Validation) or one that
<strong>penalizes for complexity</strong> (like AIC or BIC) to find the
“sweet spot” model that balances fit and simplicity. 因此，在步骤 3
中，您<em>必须</em>使用一种估算<strong>测试误差</strong>的方法（例如交叉验证）或<strong>惩罚复杂性</strong>的方法（例如
AIC 或
BIC），以找到在拟合度和简单性之间取得平衡的“最佳点”模型。</p></li>
</ul>
<h2 id="mathematical-deep-dive">Mathematical Deep Dive 🧮</h2>
<ul>
<li><strong><span class="math inline">\(Y = \beta_0 + \beta_1X_1 + \dots
+ \beta_pX_p + \epsilon\)</span>:</strong> The full linear model. The
goal of subset selection is to find a subset of <span
class="math inline">\(X_j\)</span>’s where <span
class="math inline">\(\beta_j \neq 0\)</span> and set all other <span
class="math inline">\(\beta\)</span>’s to 0.
完整的线性模型。子集选择的目标是找到 <span
class="math inline">\(X_j\)</span> 的一个子集，其中 $_j 等于
0，并将所有其他 <span class="math inline">\(\beta\)</span> 设置为
0。</li>
<li><strong><span class="math inline">\(2^p\)</span>
combinations:</strong> (Slide <code>...221333.png</code>) This is the
total number of models you have to check. For each of the <span
class="math inline">\(p\)</span> variables, you have two choices: either
it is <strong>IN</strong> the model or it is
<strong>OUT</strong>.这是你需要检查的模型总数。对于每个 <span
class="math inline">\(p\)</span>
个变量，你有两个选择：要么它在模型<strong>内部</strong>，要么它在模型<strong>外部</strong>。
<ul>
<li>Example: <span class="math inline">\(p=3\)</span> (variables <span
class="math inline">\(X_1, X_2, X_3\)</span>)</li>
<li>The <span class="math inline">\(2^3 = 8\)</span> possible models
are:
<ol type="1">
<li>{} (The null model, <span class="math inline">\(M_0\)</span>)</li>
<li>{ <span class="math inline">\(X_1\)</span> }</li>
<li>{ <span class="math inline">\(X_2\)</span> }</li>
<li>{ <span class="math inline">\(X_3\)</span> }</li>
<li>{ <span class="math inline">\(X_1, X_2\)</span> }</li>
<li>{ <span class="math inline">\(X_1, X_3\)</span> }</li>
<li>{ <span class="math inline">\(X_2, X_3\)</span> }</li>
<li>{ <span class="math inline">\(X_1, X_2, X_3\)</span> } (The full
model, <span class="math inline">\(M_3\)</span>)</li>
</ol></li>
<li>This is why this method is called an <strong>“exhaustive
search”</strong>. It literally checks every single one. For <span
class="math inline">\(p=20\)</span>, <span
class="math inline">\(2^{20}\)</span> is over a million
models!这就是该方法被称为<strong>“穷举搜索”</strong>的原因。它实际上会检查每一个模型。对于
<span class="math inline">\(p=20\)</span>，<span
class="math inline">\(2^{20}\)</span> 就超过一百万个模型！</li>
</ul></li>
<li><strong><span class="math inline">\(\binom{p}{k} =
\frac{p!}{k!(p-k)!}\)</span>:</strong> (Slide
<code>...221333.png</code>) This is the “combinations” formula. It tells
you <em>how many</em> models you fit <em>in Step 2</em> for a specific
<span
class="math inline">\(k\)</span>.这是“组合”公式。它告诉你，对于特定的
<span class="math inline">\(k\)</span>，<em>在步骤 2</em>中，你拟合了
<em>多少</em> 个模型。
<ul>
<li>Example: <span class="math inline">\(p=10\)</span> total
predictors.</li>
<li>For <span class="math inline">\(k=1\)</span>: You fit <span
class="math inline">\(\binom{10}{1} = 10\)</span> models.</li>
<li>For <span class="math inline">\(k=2\)</span>: You fit <span
class="math inline">\(\binom{10}{2} = \frac{10 \times 9}{2 \times 1} =
45\)</span> models.</li>
<li>For <span class="math inline">\(k=3\)</span>: You fit <span
class="math inline">\(\binom{10}{3} = \frac{10 \times 9 \times 8}{3
\times 2 \times 1} = 120\)</span> models.</li>
<li>…and so on. The sum of all these <span
class="math inline">\(\binom{p}{k}\)</span> from <span
class="math inline">\(k=0\)</span> to <span
class="math inline">\(k=p\)</span> equals <span
class="math inline">\(2^p\)</span>.</li>
</ul></li>
</ul>
<h2 id="detailed-code-analysis">Detailed Code Analysis 💻</h2>
<p>Your slides show Python code that applies the <strong>Best Subset
Selection algorithm</strong> to a <strong>KNN Regressor</strong>. This
is a great example of how the <em>selection algorithm</em> is
independent of the <em>model type</em> (as mentioned in slide
<code>...221314.png</code>).</p>
<h3 id="key-functions-1">Key Functions</h3>
<ul>
<li><strong><code>main()</code></strong>
<ol type="1">
<li><strong>Load &amp; Preprocess:</strong> Reads
<code>Credit.csv</code>. The most important step here is converting
categorical text (like ‘Male’/‘Female’) into numbers (1/0).</li>
<li><strong>Scale Data:</strong> <code>scaler = StandardScaler()</code>
and <code>X_scaled = scaler.fit_transform(X)</code>.
<ul>
<li><strong>WHY?</strong> This is <strong>CRITICAL</strong> for KNN. KNN
works by measuring distance. If ‘Income’ (e.g., 50,000) is on a vastly
different scale than ‘Cards’ (e.g., 3), the ‘Income’ feature will
completely dominate the distance calculation, making ‘Cards’ irrelevant.
Scaling resizes all features to have a mean of 0 and standard deviation
of 1, so they all contribute fairly.</li>
</ul></li>
<li><strong>Handle Noisy Data (Slide
<code>...221303.jpg</code>):</strong> This version of the code
<em>intentionally</em> adds 20 columns of useless, random numbers. This
is a test to see if the algorithm is smart enough to ignore them.</li>
<li><strong>Run Selection:</strong>
<code>results_df = best_subset_selection_parallel(...)</code>. This
function does all the heavy lifting (explained next).</li>
<li><strong>Find Best Model:</strong>
<code>results_df.sort_values(by='CV_Score', ascending=False)</code>.
<ul>
<li><strong>WHY <code>ascending=False</code>?</strong> The code uses the
metric <code>'neg_mean_squared_error'</code>. This is MSE, but negative
(e.g., -15000). A <em>better</em> model has an error closer to 0 (e.g.,
-10000). Since -10000 is <em>greater than</em> -15000, you sort in
descending (high-to-low) order to put the best models at the top.</li>
</ul></li>
<li><strong>Final Evaluation (Step 3):</strong>
<code>final_scores = cross_val_score(knn, X_best, y, ...)</code>
<ul>
<li>This is the implementation of Step 3. It takes <em>only</em> the
single best subset (<code>X_best</code>) and runs a <em>new</em>
cross-validation on it. This gives a final, unbiased estimate of how
good that one model is.</li>
</ul></li>
<li><strong>Print RMSE:</strong>
<code>final_rmse = np.sqrt(-final_scores)</code>. It converts the
negative MSE back into a positive RMSE (Root Mean Squared Error), which
is in the same units as the target <span
class="math inline">\(y\)</span> (in this case, ‘Balance’ in
dollars).</li>
</ol></li>
<li><strong><code>best_subset_selection_parallel(model, ...)</code></strong>
<ol type="1">
<li>This is the “manager” function. It implements the loop from Step
2.</li>
<li><code>for k in range(1, n_features + 1):</code> This is the loop
“For <span class="math inline">\(k = 1, \dots, p\)</span>”.</li>
<li><code>subsets = list(combinations(feature_names, k))</code>: This
generates the <span class="math inline">\(\binom{p}{k}\)</span>
combinations for the current <span
class="math inline">\(k\)</span>.</li>
<li><code>results = Parallel(n_jobs=n_jobs)(...)</code>: This is a
non-core, “speed-up” command. It uses the <code>joblib</code> library to
run the evaluations on all your computer’s CPU cores at once (in
parallel). Without this, checking millions of models would take
days.</li>
<li><code>subset_scores = ... [delayed(evaluate_subset)(...) ...]</code>
This line farms out the <em>actual work</em> to the
<code>evaluate_subset</code> function for every single subset.</li>
</ol></li>
<li><strong><code>evaluate_subset(subset, ...)</code></strong>
<ol type="1">
<li>This is the “worker” function. It gets called thousands or millions
of times.</li>
<li>Its job is to evaluate <em>one single subset</em> (e.g.,
<code>('Income', 'Limit', 'Student')</code>).</li>
<li><code>X_subset = X[list(subset)]</code>: It slices the data to get
<em>only</em> these columns.</li>
<li><code>scores = cross_val_score(model, X_subset, ...)</code>:
<strong>This is the most important line.</strong> It takes the subset
and performs a full 5-fold cross-validation on it.</li>
<li><code>return (subset, np.mean(scores))</code>: It returns the subset
and its average CV score.</li>
</ol></li>
</ul>
<h3 id="summary-of-outputs-slides-...221255.png-...221309.png">Summary
of Outputs (Slides <code>...221255.png</code> &amp;
<code>...221309.png</code>)</h3>
<ul>
<li><strong>Original Data (Slide <code>...221255.png</code>):</strong>
<ul>
<li><strong>Best Subset:</strong>
<code>('Income', 'Limit', 'Rating', 'Student')</code></li>
<li><strong>Final RMSE:</strong> ~105.4</li>
</ul></li>
<li><strong>Data with 20 “Noisy” Variables (Slide
<code>...221309.png</code>):</strong>
<ul>
<li><strong>Best Subset:</strong>
<code>('Income', 'Limit', 'Student')</code></li>
<li><strong>Result:</strong> The algorithm <em>successfully</em>
identified that all 20 “Noisy” variables were useless and
<strong>excluded every single one of them</strong> from the best
models.</li>
<li><strong>Final RMSE:</strong> ~114.9</li>
<li><strong>Key Takeaway:</strong> The RMSE is slightly higher, which
makes sense because the selection problem was much harder. But the
<em>method worked perfectly</em>. It filtered all the “noise” and found
a simple, powerful model, just as the theory on slide
<code>...221320.png</code> predicted.</li>
</ul></li>
</ul>
<h1
id="the-core-problem-training-error-vs.-test-error-核心问题训练误差-vs.-测试误差">2.
The Core Problem: Training Error vs. Test Error 核心问题：训练误差
vs. 测试误差</h1>
<p>The central theme of these slides is finding the “best” model. The
problem is that a model with more predictors (more complex) will
<em>always</em> fit the data it was trained on better. This is a trap.
寻找“最佳”模型。问题在于，预测因子越多（越复杂）的模型<em>总是</em>能更好地拟合训练数据。这是一个陷阱。</p>
<ul>
<li><strong>Training Error:</strong> How well the model fits the data we
used to build it. <strong><span class="math inline">\(R^2\)</span> and
<span class="math inline">\(RSS\)</span> measure this.</strong>
模型与我们构建模型时所用数据的拟合程度。<strong><span
class="math inline">\(R^2\)</span> 和 <span
class="math inline">\(RSS\)</span> 衡量了这一点。</strong></li>
<li><strong>Test Error:</strong> How well the model predicts new, unseen
data. This is what we <em>actually</em> care about. A model that is too
complex (e.g., has 10 predictors when only 3 are useful) will have low
training error but very high test error. This is called
<strong>overfitting</strong>.
模型预测新的、未见过的数据的准确程度。这才是我们<em>真正</em>关心的。过于复杂的模型（例如，有
10 个预测因子，但只有 3
个有用）的训练误差会很低，但测试误差会很高。这被称为<strong>过拟合</strong>。</li>
</ul>
<p>The goal is to choose a model that has the lowest <em>test
error</em>. The metrics below (Adjusted <span
class="math inline">\(R^2\)</span>, AIC, BIC) are all attempts to
<em>estimate</em> this test error without having to actually collect new
data. They do this by adding a <strong>penalty</strong> for complexity.
目标是选择一个具有最低<em>测试误差</em>的模型。以下指标（调整后的 <span
class="math inline">\(R^2\)</span>、AIC、BIC）都是在无需实际收集新数据的情况下尝试<em>估计</em>此测试误差。他们通过增加<strong>复杂度惩罚</strong>来实现这一点。</p>
<h2 id="basic-metrics-measures-of-fit">Basic Metrics (Measures of
Fit)</h2>
<p>These formulas from slide 13 describe how well a model fits the
<em>training data</em>.</p>
<h3 id="residue-error-残差误差">Residue (Error) 残差（误差）</h3>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(\hat{\epsilon}_i = y_i - \hat{y}_i = y_i -
\hat{\beta}_0 - \sum_{j=1}^{p} \hat{\beta}_j x_{ij}\)</span></li>
<li><strong>Concept:</strong> This is the most basic building block.
It’s the difference between the <em>actual</em> observed value (<span
class="math inline">\(y_i\)</span>) and the value your model
<em>predicted</em> (<span class="math inline">\(\hat{y}_i\)</span>). It
is the “error” for a single data point.
这是最基本的构建块。它是<em>实际</em>观测值 (<span
class="math inline">\(y_i\)</span>) 与模型*预测值 (<span
class="math inline">\(\hat{y}_i\)</span>)
之间的差值。它是单个数据点的“误差”。</li>
</ul>
<h3 id="residual-sum-of-squares-rss-残差平方和-rss">Residual Sum of
Squares (RSS) 残差平方和 (RSS)</h3>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(RSS =
\sum_{i=1}^{n} \hat{\epsilon}_i^2\)</span></li>
<li><strong>Concept:</strong> This is the overall measure of model
error. You square all the individual errors (residues) to make them
positive and then add them all up.
这是模型误差的总体度量。将所有单个误差（残差）平方，使其为正，然后将它们全部相加。</li>
<li><strong>Goal:</strong> The entire process of linear regression
(called “Ordinary Least Squares”) is designed to find the <span
class="math inline">\(\hat{\beta}\)</span> coefficients that make this
<strong>RSS value as small as possible</strong>.
整个线性回归过程（称为“普通最小二乘法”）旨在找到使<strong>RSS
值尽可能小</strong>的 <span class="math inline">\(\hat{\beta}\)</span>
个系数。</li>
<li><strong>The Flaw 缺陷:</strong> <span
class="math inline">\(RSS\)</span> will <em>always</em> decrease (or
stay the same) as you add more predictors (<span
class="math inline">\(p\)</span>). A model with all 10 predictors will
have a lower <span class="math inline">\(RSS\)</span> than a model with
9, even if that 10th predictor is useless. Therefore, <span
class="math inline">\(RSS\)</span> is useless for choosing
<em>between</em> models of different sizes. 随着预测变量 (<span
class="math inline">\(p\)</span>) 的增加，<span
class="math inline">\(RSS\)</span>
总是会减小（或保持不变）。一个包含所有 10 个预测变量的模型的 <span
class="math inline">\(RSS\)</span> 会低于一个包含 9
个预测变量的模型，即使第 10 个预测变量毫无用处。因此，<span
class="math inline">\(RSS\)</span>
对于在不同规模的模型之间进行选择毫无用处。</li>
</ul>
<h3 id="r-squared-r2">R-squared (<span
class="math inline">\(R^2\)</span>)</h3>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(R^2 = 1 -
\frac{SS_{error}}{SS_{total}} = 1 - \frac{RSS}{\sum_{i=1}^{n} (y_i -
\bar{y})^2}\)</span></li>
<li><strong>Concept:</strong> This metric reframes <span
class="math inline">\(RSS\)</span> into a more interpretable
percentage.此指标将 <span class="math inline">\(RSS\)</span>
重新定义为更易于解释的百分比。
<ul>
<li><span class="math inline">\(SS_{total}\)</span> (the denominator)
represents the <em>total variance</em> of the data. It’s the error you
would get if your “model” was just guessing the average value (<span
class="math inline">\(\bar{y}\)</span>) for every single observation.
（分母）表示数据的<em>总方差</em>。如果你的“模型”只是猜测每个观测值的平均值
(<span
class="math inline">\(\bar{y}\)</span>)，那么你就会得到这个误差。</li>
<li><span class="math inline">\(SS_{error}\)</span> (the <span
class="math inline">\(RSS\)</span>) is the error <em>after</em> using
your model. 是“模型解释的总方差的比例”。 <span
class="math inline">\(R^2\)</span> 为 0.75
意味着你的模型可以解释响应变量 75% 的变异。</li>
<li><span class="math inline">\(R^2\)</span> is the “proportion of total
variance explained by the model.” An <span
class="math inline">\(R^2\)</span> of 0.75 means your model can explain
75% of the variation in the response variable.</li>
</ul></li>
<li><strong>The Flaw 缺陷:</strong> Just like <span
class="math inline">\(RSS\)</span>, <span
class="math inline">\(R^2\)</span> will <em>always</em> increase (or
stay the same) as you add more predictors. This is visually confirmed in
Figure 6.1, where the red line for <span
class="math inline">\(R^2\)</span> only goes up. It will always pick the
most complex model. 与 <span class="math inline">\(RSS\)</span>
一样，随着预测变量的增加，<span class="math inline">\(R^2\)</span>
会<em>始终</em>增加（或保持不变）。图 6.1 直观地证实了这一点，其中 <span
class="math inline">\(R^2\)</span>
的红线只会上升。它总是会选择最复杂的模型。</li>
</ul>
<h2
id="advanced-metrics-for-model-selection-高级指标用于模型选择">Advanced
Metrics (For Model Selection) 高级指标（用于模型选择）</h2>
<p>These metrics “fix” the flaw of <span
class="math inline">\(R^2\)</span> by including a penalty for the number
of predictors.</p>
<h3 id="adjusted-r2">Adjusted <span
class="math inline">\(R^2\)</span></h3>
<ul>
<li><strong>Formula:</strong> <span class="math display">\[
  \text{Adjusted } R^2 = 1 - \frac{RSS / (n - p - 1)}{SS_{total} / (n -
1)}
  \]</span></li>
<li><strong>Mathematical Concept:</strong> This formula replaces the
“Sum of Squares” (<span class="math inline">\(SS\)</span>) with “Mean
Squares” (<span class="math inline">\(MS\)</span>).
<ul>
<li><span class="math inline">\(MS_{error} =
\frac{RSS}{n-p-1}\)</span></li>
<li><span class="math inline">\(MS_{total} =
\frac{SS_{total}}{n-1}\)</span></li>
</ul></li>
<li><strong>The “Penalty” Explained:</strong> The penalty is
<strong>degrees of freedom</strong>.
<ul>
<li><span class="math inline">\(n\)</span> = number of data points.</li>
<li><span class="math inline">\(p\)</span> = number of predictors.</li>
<li>The term <span class="math inline">\(n-p-1\)</span> is the degrees
of freedom for the residuals. You start with <span
class="math inline">\(n\)</span> data points, but you “use up” one
degree of freedom to estimate the intercept (<span
class="math inline">\(\hat{\beta}_0\)</span>) and <span
class="math inline">\(p\)</span> more to estimate the <span
class="math inline">\(p\)</span> slopes.</li>
</ul></li>
<li><strong>How it Works:</strong>
<ol type="1">
<li>When you add a new predictor (increase <span
class="math inline">\(p\)</span>), <span
class="math inline">\(RSS\)</span> goes down, which makes the numerator
(<span class="math inline">\(MS_{error}\)</span>) smaller.</li>
<li>…But, increasing <span class="math inline">\(p\)</span>
<em>also</em> decreases the denominator (<span
class="math inline">\(n-p-1\)</span>), which makes the numerator (<span
class="math inline">\(MS_{error}\)</span>) <em>larger</em>.</li>
</ol>
<ul>
<li>This creates a “tug-of-war.” If the new predictor is
<strong>useful</strong>, it will drop <span
class="math inline">\(RSS\)</span> a lot, and Adjusted <span
class="math inline">\(R^2\)</span> will <strong>increase</strong>. If
the new predictor is <strong>useless</strong>, <span
class="math inline">\(RSS\)</span> will barely change, and the penalty
from decreasing the denominator will win, causing Adjusted <span
class="math inline">\(R^2\)</span> to <strong>decrease</strong>.</li>
</ul></li>
<li><strong>Goal:</strong> You select the model with the
<strong>highest</strong> Adjusted <span
class="math inline">\(R^2\)</span>.</li>
</ul>
<h3 id="akaike-information-criterion-aic">Akaike Information Criterion
(AIC)</h3>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(AIC =
-2 \log \ell(\hat{\theta}) + 2d\)</span></li>
<li><strong>Concept Breakdown:</strong>
<ul>
<li><span class="math inline">\(\ell(\hat{\theta})\)</span>: This is the
<strong>Maximized Likelihood Function</strong>.
<ul>
<li>The <strong>Likelihood Function</strong> <span
class="math inline">\(\ell(\theta)\)</span> asks: “Given a set of model
parameters <span class="math inline">\(\theta\)</span>, how probable is
the data we observed?”</li>
<li>The <strong>Maximum Likelihood Estimate (MLE)</strong> <span
class="math inline">\(\hat{\theta}\)</span> is the specific set of
parameters (the <span class="math inline">\(\hat{\beta}\)</span>’s) that
<em>maximizes</em> this probability.</li>
</ul></li>
<li><span class="math inline">\(\log \ell(\hat{\theta})\)</span>: The
<strong>log-likelihood</strong>. This is just a number that represents
the <em>best possible fit</em> the model can achieve for the data. A
higher number is a better fit.</li>
<li><span class="math inline">\(-2 \log \ell(\hat{\theta})\)</span>:
This is the <strong>Deviance</strong>. Since a higher log-likelihood is
better, a <em>lower</em> deviance is better. This term measures
<strong>poorness-of-fit</strong>.</li>
<li><span class="math inline">\(d\)</span>: The number of parameters
estimated by the model. (e.g., <span class="math inline">\(p\)</span>
predictors + 1 intercept).</li>
<li><span class="math inline">\(2d\)</span>: This is the <strong>Penalty
Term</strong>.</li>
</ul></li>
<li><strong>How it Works:</strong> <span class="math inline">\(AIC =
(\text{Poorness-of-Fit}) + (\text{Complexity Penalty})\)</span>. As you
add predictors, the fit gets better (the deviance term goes down), but
the penalty term (<span class="math inline">\(2d\)</span>) goes up.</li>
<li><strong>Goal:</strong> You select the model with the
<strong>lowest</strong> AIC.</li>
</ul>
<h3 id="bayesian-information-criterion-bic">Bayesian Information
Criterion (BIC)</h3>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(BIC =
-2 \log \ell(\hat{\theta}) + \log(n)d\)</span></li>
<li><strong>Concept:</strong> This is mathematically identical to AIC,
but the penalty term is different.
<ul>
<li><strong>AIC Penalty:</strong> <span
class="math inline">\(2d\)</span></li>
<li><strong>BIC Penalty:</strong> <span
class="math inline">\(\log(n)d\)</span></li>
</ul></li>
<li><strong>Comparison:</strong>
<ul>
<li><span class="math inline">\(n\)</span> is the number of observations
in your dataset.</li>
<li>As long as your dataset has 8 or more observations (<span
class="math inline">\(n \ge 8\)</span>), <span
class="math inline">\(\log(n)\)</span> will be greater than 2.</li>
<li>This means <strong>BIC applies a much harsher penalty for
complexity</strong> than AIC.</li>
</ul></li>
<li><strong>Consequence:</strong> BIC will tend to choose
<em>simpler</em> models (fewer predictors) than AIC.</li>
<li><strong>Goal:</strong> You select the model with the
<strong>lowest</strong> BIC.</li>
</ul>
<h2 id="the-deeper-theory-why-aic-works">The Deeper Theory: Why AIC
Works</h2>
<p>Slide 27 (“Understanding AIC”) gives the deep mathematical
justification.</p>
<ul>
<li><strong>Goal:</strong> We have a <em>true</em>, unknown process
<span class="math inline">\(p\)</span> that generates our data. We are
creating a model <span class="math inline">\(\hat{p}_j\)</span>. We want
our model to be as “close” to the truth as possible.</li>
<li><strong>Kullback-Leibler (K-L) Distance:</strong> This is a function
<span class="math inline">\(K(p, \hat{p}_j)\)</span> that measures the
“information lost” when you use your model <span
class="math inline">\(\hat{p}_j\)</span> to approximate the truth <span
class="math inline">\(p\)</span>. You want to <em>minimize</em> this
distance.</li>
<li><strong>The Math:</strong>
<ol type="1">
<li><span class="math inline">\(K(p, \hat{p}_j) = \int p(y) \log \left(
\frac{p(y)}{\hat{p}_j(y)} \right) dy\)</span></li>
<li>This splits into: <span class="math inline">\(K(p, \hat{p}_j) =
\underbrace{\int p(y) \log(p(y)) dy}_{\text{Constant}} -
\underbrace{\int p(y) \log(\hat{p}_j(y)) dy}_{\text{This is what we need
to maximize}}\)</span></li>
</ol></li>
<li><strong>The Problem:</strong> We can’t calculate that second term
because it requires knowing the <em>true</em> function <span
class="math inline">\(p\)</span>.</li>
<li><strong>Akaike’s Insight:</strong> Akaike proved that the
log-likelihood we <em>can</em> calculate, <span
class="math inline">\(\log \ell(\hat{\theta})\)</span>, is a
<em>biased</em> estimator of that target. He also proved that the bias
is approximately <span class="math inline">\(-d\)</span>.</li>
<li><strong>The Solution:</strong> An <em>unbiased</em> estimate of the
target is <span class="math inline">\(\log \ell(\hat{\theta}) -
d\)</span>.</li>
<li><strong>Final Step:</strong> For historical and statistical reasons,
he multiplied this by <span class="math inline">\(-2\)</span> to create
the final AIC formula.</li>
<li><strong>Conclusion:</strong> AIC is not just a random formula. It is
a carefully derived estimate of how much information your model loses
compared to the “truth” (i.e., its expected performance on new
data).</li>
</ul>
<h2 id="aicbic-for-linear-regression">AIC/BIC for Linear Regression</h2>
<p>Slide 26 shows how these general formulas simplify for linear
regression (assuming normal, Gaussian errors).</p>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(AIC =
-2 \log \ell(\hat{\theta}) + 2d\)</span></li>
<li><strong>Linear Regression Formula:</strong> <span
class="math inline">\(AIC = \frac{1}{n\hat{\sigma}^2}(RSS +
2d\hat{\sigma}^2)\)</span></li>
</ul>
<p><strong>Key Insight:</strong> For linear regression, the
“poorness-of-fit” term (<span class="math inline">\(-2 \log
\ell(\hat{\theta})\)</span>) is <em>directly proportional to</em> the
<span class="math inline">\(RSS\)</span>.</p>
<p>This makes it much easier to understand. You can just think of the
formulas as: * <strong>AIC <span class="math inline">\(\approx\)</span>
<span class="math inline">\(RSS + 2d\hat{\sigma}^2\)</span></strong> *
<strong>BIC <span class="math inline">\(\approx\)</span> <span
class="math inline">\(RSS + \log(n)d\hat{\sigma}^2\)</span></strong></p>
<p>(Here <span class="math inline">\(\hat{\sigma}^2\)</span> is an
estimate of the error variance, which can often be treated as a
constant).</p>
<p>This clearly shows the trade-off: We want a model with a low
<strong><span class="math inline">\(RSS\)</span></strong> (good fit) and
a low <strong><span class="math inline">\(d\)</span></strong> (low
complexity). These two goals are in direct competition.</p>
<p><strong>Mallow’s <span class="math inline">\(C_p\)</span>:</strong>
The slide notes that <span class="math inline">\(C_p\)</span> is
equivalent to AIC for linear regression. The <span
class="math inline">\(C_p\)</span> formula is <span
class="math inline">\(C_p = \frac{1}{n}(RSS +
2d\hat{\sigma}^2_{full})\)</span>, where <span
class="math inline">\(\hat{\sigma}^2_{full}\)</span> is the error
variance estimated from the <em>full</em> model. Since <span
class="math inline">\(n\)</span> and <span
class="math inline">\(\hat{\sigma}^2_{full}\)</span> are constants,
minimizing <span class="math inline">\(C_p\)</span> is mathematically
identical to minimizing <span class="math inline">\(RSS +
2d\hat{\sigma}^2_{full}\)</span>, which is the same logic as AIC.</p>
<p>Here is a detailed breakdown of the mathematical formulas and
concepts from your slides.</p>
<h2 id="the-core-problem-training-error-vs.-test-error">The Core
Problem: Training Error vs. Test Error</h2>
<p>The central theme of these slides is finding the “best” model. The
problem is that a model with more predictors (more complex) will
<em>always</em> fit the data it was trained on better. This is a
trap.</p>
<ul>
<li><strong>Training Error:</strong> How well the model fits the data we
used to build it. <strong><span class="math inline">\(R^2\)</span> and
<span class="math inline">\(RSS\)</span> measure this.</strong></li>
<li><strong>Test Error:</strong> How well the model predicts new, unseen
data. This is what we <em>actually</em> care about. A model that is too
complex (e.g., has 10 predictors when only 3 are useful) will have low
training error but very high test error. This is called
<strong>overfitting</strong>.</li>
</ul>
<p>The goal is to choose a model that has the lowest <em>test
error</em>. The metrics below (Adjusted <span
class="math inline">\(R^2\)</span>, AIC, BIC) are all attempts to
<em>estimate</em> this test error without having to actually collect new
data. They do this by adding a <strong>penalty</strong> for
complexity.</p>
<h2 id="basic-metrics-measures-of-fit-1">Basic Metrics (Measures of
Fit)</h2>
<p>These formulas from slide 13 describe how well a model fits the
<em>training data</em>.</p>
<h3 id="residue-error">Residue (Error)</h3>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(\hat{\epsilon}_i = y_i - \hat{y}_i = y_i -
\hat{\beta}_0 - \sum_{j=1}^{p} \hat{\beta}_j x_{ij}\)</span></li>
<li><strong>Concept:</strong> This is the most basic building block.
It’s the difference between the <em>actual</em> observed value (<span
class="math inline">\(y_i\)</span>) and the value your model
<em>predicted</em> (<span class="math inline">\(\hat{y}_i\)</span>). It
is the “error” for a single data point.</li>
</ul>
<h3 id="residual-sum-of-squares-rss">Residual Sum of Squares (RSS)</h3>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(RSS =
\sum_{i=1}^{n} \hat{\epsilon}_i^2\)</span></li>
<li><strong>Concept:</strong> This is the overall measure of model
error. You square all the individual errors (residues) to make them
positive and then add them all up.</li>
<li><strong>Goal:</strong> The entire process of linear regression
(called “Ordinary Least Squares”) is designed to find the <span
class="math inline">\(\hat{\beta}\)</span> coefficients that make this
<strong>RSS value as small as possible</strong>.</li>
<li><strong>The Flaw:</strong> <span class="math inline">\(RSS\)</span>
will <em>always</em> decrease (or stay the same) as you add more
predictors (<span class="math inline">\(p\)</span>). A model with all 10
predictors will have a lower <span class="math inline">\(RSS\)</span>
than a model with 9, even if that 10th predictor is useless. Therefore,
<span class="math inline">\(RSS\)</span> is useless for choosing
<em>between</em> models of different sizes.</li>
</ul>
<h3 id="r-squared-r2-1">R-squared (<span
class="math inline">\(R^2\)</span>)</h3>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(R^2 = 1 -
\frac{SS_{error}}{SS_{total}} = 1 - \frac{RSS}{\sum_{i=1}^{n} (y_i -
\bar{y})^2}\)</span></li>
<li><strong>Concept:</strong> This metric reframes <span
class="math inline">\(RSS\)</span> into a more interpretable percentage.
<ul>
<li><span class="math inline">\(SS_{total}\)</span> (the denominator)
represents the <em>total variance</em> of the data. It’s the error you
would get if your “model” was just guessing the average value (<span
class="math inline">\(\bar{y}\)</span>) for every single
observation.</li>
<li><span class="math inline">\(SS_{error}\)</span> (the <span
class="math inline">\(RSS\)</span>) is the error <em>after</em> using
your model.</li>
<li><span class="math inline">\(R^2\)</span> is the “proportion of total
variance explained by the model.” An <span
class="math inline">\(R^2\)</span> of 0.75 means your model can explain
75% of the variation in the response variable.</li>
</ul></li>
<li><strong>The Flaw:</strong> Just like <span
class="math inline">\(RSS\)</span>, <span
class="math inline">\(R^2\)</span> will <em>always</em> increase (or
stay the same) as you add more predictors. This is visually confirmed in
Figure 6.1, where the red line for <span
class="math inline">\(R^2\)</span> only goes up. It will always pick the
most complex model.</li>
</ul>
<h2 id="advanced-metrics-for-model-selection">Advanced Metrics (For
Model Selection)</h2>
<p>These metrics “fix” the flaw of <span
class="math inline">\(R^2\)</span> by including a penalty for the number
of predictors.</p>
<h3 id="adjusted-r2-1">Adjusted <span
class="math inline">\(R^2\)</span></h3>
<ul>
<li><strong>Formula:</strong> <span class="math display">\[
  \text{Adjusted } R^2 = 1 - \frac{RSS / (n - p - 1)}{SS_{total} / (n -
1)}
  \]</span></li>
<li><strong>Mathematical Concept:</strong> This formula replaces the
“Sum of Squares” (<span class="math inline">\(SS\)</span>) with “Mean
Squares” (<span class="math inline">\(MS\)</span>).
<ul>
<li><span class="math inline">\(MS_{error} =
\frac{RSS}{n-p-1}\)</span></li>
<li><span class="math inline">\(MS_{total} =
\frac{SS_{total}}{n-1}\)</span></li>
</ul></li>
<li><strong>The “Penalty” Explained:</strong> The penalty is
<strong>degrees of freedom</strong>.
<ul>
<li><span class="math inline">\(n\)</span> = number of data points.</li>
<li><span class="math inline">\(p\)</span> = number of predictors.</li>
<li>The term <span class="math inline">\(n-p-1\)</span> is the degrees
of freedom for the residuals. You start with <span
class="math inline">\(n\)</span> data points, but you “use up” one
degree of freedom to estimate the intercept (<span
class="math inline">\(\hat{\beta}_0\)</span>) and <span
class="math inline">\(p\)</span> more to estimate the <span
class="math inline">\(p\)</span> slopes.</li>
</ul></li>
<li><strong>How it Works:</strong>
<ol type="1">
<li>When you add a new predictor (increase <span
class="math inline">\(p\)</span>), <span
class="math inline">\(RSS\)</span> goes down, which makes the numerator
(<span class="math inline">\(MS_{error}\)</span>) smaller.</li>
<li>…But, increasing <span class="math inline">\(p\)</span>
<em>also</em> decreases the denominator (<span
class="math inline">\(n-p-1\)</span>), which makes the numerator (<span
class="math inline">\(MS_{error}\)</span>) <em>larger</em>.</li>
</ol>
<ul>
<li>This creates a “tug-of-war.” If the new predictor is
<strong>useful</strong>, it will drop <span
class="math inline">\(RSS\)</span> a lot, and Adjusted <span
class="math inline">\(R^2\)</span> will <strong>increase</strong>. If
the new predictor is <strong>useless</strong>, <span
class="math inline">\(RSS\)</span> will barely change, and the penalty
from decreasing the denominator will win, causing Adjusted <span
class="math inline">\(R^2\)</span> to <strong>decrease</strong>.</li>
</ul></li>
<li><strong>Goal:</strong> You select the model with the
<strong>highest</strong> Adjusted <span
class="math inline">\(R^2\)</span>.</li>
</ul>
<h3 id="akaike-information-criterion-aic-1">Akaike Information Criterion
(AIC)</h3>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(AIC =
-2 \log \ell(\hat{\theta}) + 2d\)</span></li>
<li><strong>Concept Breakdown:</strong>
<ul>
<li><span class="math inline">\(\ell(\hat{\theta})\)</span>: This is the
<strong>Maximized Likelihood Function</strong>.
<ul>
<li>The <strong>Likelihood Function</strong> <span
class="math inline">\(\ell(\theta)\)</span> asks: “Given a set of model
parameters <span class="math inline">\(\theta\)</span>, how probable is
the data we observed?”</li>
<li>The <strong>Maximum Likelihood Estimate (MLE)</strong> <span
class="math inline">\(\hat{\theta}\)</span> is the specific set of
parameters (the <span class="math inline">\(\hat{\beta}\)</span>’s) that
<em>maximizes</em> this probability.</li>
</ul></li>
<li><span class="math inline">\(\log \ell(\hat{\theta})\)</span>: The
<strong>log-likelihood</strong>. This is just a number that represents
the <em>best possible fit</em> the model can achieve for the data. A
higher number is a better fit.</li>
<li><span class="math inline">\(-2 \log \ell(\hat{\theta})\)</span>:
This is the <strong>Deviance</strong>. Since a higher log-likelihood is
better, a <em>lower</em> deviance is better. This term measures
<strong>poorness-of-fit</strong>.</li>
<li><span class="math inline">\(d\)</span>: The number of parameters
estimated by the model. (e.g., <span class="math inline">\(p\)</span>
predictors + 1 intercept).</li>
<li><span class="math inline">\(2d\)</span>: This is the <strong>Penalty
Term</strong>.</li>
</ul></li>
<li><strong>How it Works:</strong> <span class="math inline">\(AIC =
(\text{Poorness-of-Fit}) + (\text{Complexity Penalty})\)</span>. As you
add predictors, the fit gets better (the deviance term goes down), but
the penalty term (<span class="math inline">\(2d\)</span>) goes up.</li>
<li><strong>Goal:</strong> You select the model with the
<strong>lowest</strong> AIC.</li>
</ul>
<h3 id="bayesian-information-criterion-bic-1">Bayesian Information
Criterion (BIC)</h3>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(BIC =
-2 \log \ell(\hat{\theta}) + \log(n)d\)</span></li>
<li><strong>Concept:</strong> This is mathematically identical to AIC,
but the penalty term is different.
<ul>
<li><strong>AIC Penalty:</strong> <span
class="math inline">\(2d\)</span></li>
<li><strong>BIC Penalty:</strong> <span
class="math inline">\(\log(n)d\)</span></li>
</ul></li>
<li><strong>Comparison:</strong>
<ul>
<li><span class="math inline">\(n\)</span> is the number of observations
in your dataset.</li>
<li>As long as your dataset has 8 or more observations (<span
class="math inline">\(n \ge 8\)</span>), <span
class="math inline">\(\log(n)\)</span> will be greater than 2.</li>
<li>This means <strong>BIC applies a much harsher penalty for
complexity</strong> than AIC.</li>
</ul></li>
<li><strong>Consequence:</strong> BIC will tend to choose
<em>simpler</em> models (fewer predictors) than AIC.</li>
<li><strong>Goal:</strong> You select the model with the
<strong>lowest</strong> BIC.</li>
</ul>
<h2 id="the-deeper-theory-why-aic-works-1">The Deeper Theory: Why AIC
Works</h2>
<p>Slide 27 (“Understanding AIC”) gives the deep mathematical
justification.</p>
<ul>
<li><strong>Goal:</strong> We have a <em>true</em>, unknown process
<span class="math inline">\(p\)</span> that generates our data. We are
creating a model <span class="math inline">\(\hat{p}_j\)</span>. We want
our model to be as “close” to the truth as possible.</li>
<li><strong>Kullback-Leibler (K-L) Distance:</strong> This is a function
<span class="math inline">\(K(p, \hat{p}_j)\)</span> that measures the
“information lost” when you use your model <span
class="math inline">\(\hat{p}_j\)</span> to approximate the truth <span
class="math inline">\(p\)</span>. You want to <em>minimize</em> this
distance.</li>
<li><strong>The Math:</strong>
<ol type="1">
<li><span class="math inline">\(K(p, \hat{p}_j) = \int p(y) \log \left(
\frac{p(y)}{\hat{p}_j(y)} \right) dy\)</span></li>
<li>This splits into: <span class="math inline">\(K(p, \hat{p}_j) =
\underbrace{\int p(y) \log(p(y)) dy}_{\text{Constant}} -
\underbrace{\int p(y) \log(\hat{p}_j(y)) dy}_{\text{This is what we need
to maximize}}\)</span></li>
</ol></li>
<li><strong>The Problem:</strong> We can’t calculate that second term
because it requires knowing the <em>true</em> function <span
class="math inline">\(p\)</span>.</li>
<li><strong>Akaike’s Insight:</strong> Akaike proved that the
log-likelihood we <em>can</em> calculate, <span
class="math inline">\(\log \ell(\hat{\theta})\)</span>, is a
<em>biased</em> estimator of that target. He also proved that the bias
is approximately <span class="math inline">\(-d\)</span>.</li>
<li><strong>The Solution:</strong> An <em>unbiased</em> estimate of the
target is <span class="math inline">\(\log \ell(\hat{\theta}) -
d\)</span>.</li>
<li><strong>Final Step:</strong> For historical and statistical reasons,
he multiplied this by <span class="math inline">\(-2\)</span> to create
the final AIC formula.</li>
<li><strong>Conclusion:</strong> AIC is not just a random formula. It is
a carefully derived estimate of how much information your model loses
compared to the “truth” (i.e., its expected performance on new
data).</li>
</ul>
<h2 id="aicbic-for-linear-regression-1">AIC/BIC for Linear
Regression</h2>
<p>Slide 26 shows how these general formulas simplify for linear
regression (assuming normal, Gaussian errors).</p>
<ul>
<li><strong>General Formula:</strong> <span class="math inline">\(AIC =
-2 \log \ell(\hat{\theta}) + 2d\)</span></li>
<li><strong>Linear Regression Formula:</strong> <span
class="math inline">\(AIC = \frac{1}{n\hat{\sigma}^2}(RSS +
2d\hat{\sigma}^2)\)</span></li>
</ul>
<p><strong>Key Insight:</strong> For linear regression, the
“poorness-of-fit” term (<span class="math inline">\(-2 \log
\ell(\hat{\theta})\)</span>) is <em>directly proportional to</em> the
<span class="math inline">\(RSS\)</span>.</p>
<p>This makes it much easier to understand. You can just think of the
formulas as: * <strong>AIC <span class="math inline">\(\approx\)</span>
<span class="math inline">\(RSS + 2d\hat{\sigma}^2\)</span></strong> *
<strong>BIC <span class="math inline">\(\approx\)</span> <span
class="math inline">\(RSS + \log(n)d\hat{\sigma}^2\)</span></strong></p>
<p>(Here <span class="math inline">\(\hat{\sigma}^2\)</span> is an
estimate of the error variance, which can often be treated as a
constant).</p>
<p>This clearly shows the trade-off: We want a model with a low
<strong><span class="math inline">\(RSS\)</span></strong> (good fit) and
a low <strong><span class="math inline">\(d\)</span></strong> (low
complexity). These two goals are in direct competition.</p>
<p><strong>Mallow’s <span class="math inline">\(C_p\)</span>:</strong>
The slide notes that <span class="math inline">\(C_p\)</span> is
equivalent to AIC for linear regression. The <span
class="math inline">\(C_p\)</span> formula is <span
class="math inline">\(C_p = \frac{1}{n}(RSS +
2d\hat{\sigma}^2_{full})\)</span>, where <span
class="math inline">\(\hat{\sigma}^2_{full}\)</span> is the error
variance estimated from the <em>full</em> model. Since <span
class="math inline">\(n\)</span> and <span
class="math inline">\(\hat{\sigma}^2_{full}\)</span> are constants,
minimizing <span class="math inline">\(C_p\)</span> is mathematically
identical to minimizing <span class="math inline">\(RSS +
2d\hat{\sigma}^2_{full}\)</span>, which is the same logic as AIC.</p>
<h1 id="variable-selection">3. Variable Selection</h1>
<h2 id="core-concept-the-problem-of-variable-selection">Core Concept:
The Problem of Variable Selection</h2>
<p>In regression, we want to model a response variable <span
class="math inline">\(Y\)</span> using a set of <span
class="math inline">\(p\)</span> predictor variables <span
class="math inline">\(X_1, X_2, ..., X_p\)</span>.</p>
<ul>
<li><p><strong>The “Kitchen Sink” Problem:</strong> A common temptation
is to include all available predictors in the model: <span
class="math display">\[Y = \beta_0 + \beta_1X_1 + \beta_2X_2 + ... +
\beta_pX_p + \epsilon\]</span> This often leads to
<strong>overfitting</strong>. The model may fit the training data well
but will perform poorly on new, unseen data. It’s also hard to interpret
a model with dozens of predictors.</p></li>
<li><p><strong>The Solution: Subset Selection.</strong> The goal is to
find a smaller subset of the predictors that builds a model that is:</p>
<ol type="1">
<li><strong>Accurate:</strong> Has low prediction error.</li>
<li><strong>Parsimonious:</strong> Uses the fewest predictors
necessary.</li>
<li><strong>Interpretable:</strong> Is simple enough for a human to
understand.</li>
</ol></li>
</ul>
<p>Your slides present two main methods to achieve this: <strong>Best
Subset Selection</strong> and <strong>Forward Stepwise
Selection</strong>.</p>
<h2 id="method-1-best-subset-selection-bss">Method 1: Best Subset
Selection (BSS)</h2>
<p>This is the “brute force” approach. It considers <em>every single
possible model</em>.</p>
<h3 id="conceptual-algorithm">Conceptual Algorithm</h3>
<ol type="1">
<li>Fit all models with <span class="math inline">\(k=1\)</span>
predictor (there are <span class="math inline">\(p\)</span> of these).
Find the best one (lowest RSS) and call it <span
class="math inline">\(M_1\)</span>.</li>
<li>Fit all models with <span class="math inline">\(k=2\)</span>
predictors (there are <span class="math inline">\(\binom{p}{2}\)</span>
of these). Find the best one and call it <span
class="math inline">\(M_2\)</span>.</li>
<li>…</li>
<li>Fit the one model with <span class="math inline">\(k=p\)</span>
predictors (the full model), <span
class="math inline">\(M_p\)</span>.</li>
<li>You now have a list of <span class="math inline">\(p\)</span> “best”
models: <span class="math inline">\(M_1, M_2, ..., M_p\)</span>.</li>
<li>Use a selection criterion (like <strong>Adjusted <span
class="math inline">\(R^2\)</span></strong>, <strong>BIC</strong>,
<strong>AIC</strong>, or <strong><span
class="math inline">\(C_p\)</span></strong>) to choose the single best
model from this list.</li>
</ol>
<h3
id="mathematical-computational-cost-from-slide-225641.png">Mathematical
&amp; Computational Cost (from slide <code>225641.png</code>)</h3>
<ul>
<li>For each predictor, there are two possibilities: it’s either
<strong>IN</strong> the model or <strong>OUT</strong>.</li>
<li>With <span class="math inline">\(p\)</span> predictors, the total
number of models to test is <span class="math inline">\(2 \times 2
\times ... \times 2\)</span> (<span class="math inline">\(p\)</span>
times).</li>
<li><strong>Total Models = <span
class="math inline">\(2^p\)</span></strong></li>
<li>This is a “combinatorial explosion.” As the slide notes, if <span
class="math inline">\(p=20\)</span>, <span class="math inline">\(2^{20}
= 1,048,576\)</span> models. This is computationally infeasible for
large <span class="math inline">\(p\)</span>.</li>
</ul>
<h2 id="method-2-forward-stepwise-selection-fss">Method 2: Forward
Stepwise Selection (FSS)</h2>
<p>This is a “greedy” algorithm. It’s an efficient alternative to BSS
that does <em>not</em> test every model.</p>
<h3
id="conceptual-algorithm-from-slides-225645.png-225648.png">Conceptual
Algorithm (from slides <code>225645.png</code> &amp;
<code>225648.png</code>)</h3>
<ul>
<li><p><strong>Step 1:</strong> Start with the <strong>null
model</strong>, <span class="math inline">\(M_0\)</span>, which has no
predictors. <span class="math display">\[M_0: Y = \beta_0 +
\epsilon\]</span> The prediction is just the sample mean of <span
class="math inline">\(Y\)</span>.</p></li>
<li><p><strong>Step 2 (Iterative):</strong></p>
<ul>
<li><strong>For <span class="math inline">\(k=0\)</span> (to get <span
class="math inline">\(M_1\)</span>):</strong> Fit all <span
class="math inline">\(p\)</span> models that add <em>one</em> predictor
to <span class="math inline">\(M_0\)</span>. Choose the best one (lowest
<strong>RSS</strong> or highest <strong><span
class="math inline">\(R^2\)</span></strong>). This is <span
class="math inline">\(M_1\)</span>. Let’s say it contains <span
class="math inline">\(X_1\)</span>.</li>
<li><strong>For <span class="math inline">\(k=1\)</span> (to get <span
class="math inline">\(M_2\)</span>):</strong> <em>Keep</em> <span
class="math inline">\(X_1\)</span> in the model. Fit all <span
class="math inline">\(p-1\)</span> models that add <em>one more</em>
predictor to <span class="math inline">\(M_1\)</span> (e.g., <span
class="math inline">\(M_1+X_2\)</span>, <span
class="math inline">\(M_1+X_3\)</span>, …). Choose the best of these.
This is <span class="math inline">\(M_2\)</span>.</li>
<li><strong>Repeat:</strong> Continue this process, adding one variable
at a time, until all <span class="math inline">\(p\)</span> predictors
are in the model <span class="math inline">\(M_p\)</span>.</li>
</ul></li>
<li><p><strong>Step 3:</strong> You now have a sequence of <span
class="math inline">\(p+1\)</span> models: <span
class="math inline">\(M_0, M_1, ..., M_p\)</span>. Choose the single
best model from this sequence using <strong>Adjusted <span
class="math inline">\(R^2\)</span></strong>, <strong>AIC</strong>,
<strong>BIC</strong>, or <strong><span
class="math inline">\(C_p\)</span></strong>.</p></li>
</ul>
<h3
id="mathematical-computational-cost-from-slide-225651.png">Mathematical
&amp; Computational Cost (from slide <code>225651.png</code>)</h3>
<ul>
<li>To find <span class="math inline">\(M_1\)</span>, you fit <span
class="math inline">\(p\)</span> models.</li>
<li>To find <span class="math inline">\(M_2\)</span>, you fit <span
class="math inline">\(p-1\)</span> models.</li>
<li>To find <span class="math inline">\(M_p\)</span>, you fit <span
class="math inline">\(1\)</span> model.</li>
<li>The null model <span class="math inline">\(M_0\)</span> is 1
model.</li>
<li><strong>Total Models = <span class="math inline">\(1 +
\sum_{k=0}^{p-1} (p-k) = 1 + p + (p-1) + ... + 1 = 1 +
\frac{p(p+1)}{2}\)</span></strong></li>
<li>As the slide notes, if <span class="math inline">\(p=20\)</span>,
this is only <span class="math inline">\(1 + 20(21)/2 = 211\)</span>
models. This is vastly more efficient than BSS.</li>
<li><strong>Key weakness:</strong> The method is “greedy.” If it adds
<span class="math inline">\(X_1\)</span> in Step 1, it can
<em>never</em> be removed. It’s possible the true best 2-variable model
is <span class="math inline">\((X_2, X_3)\)</span>, but if FSS chose
<span class="math inline">\(X_1\)</span> as the best 1-variable model,
it will never find <span class="math inline">\((X_2, X_3)\)</span>.</li>
</ul>
<h2 id="how-to-choose-the-best-model-the-criteria">4. How to Choose the
“Best” Model: The Criteria</h2>
<p>You can’t use <strong>RSS</strong> or <strong><span
class="math inline">\(R^2\)</span></strong> to compare models with
<em>different numbers of predictors</em> (<span
class="math inline">\(k\)</span>). This is because RSS always decreases
(and <span class="math inline">\(R^2\)</span> always increases) as you
add more variables. You <em>must</em> use a criterion that penalizes
complexity.</p>
<ul>
<li><p><strong>RSS (Residual Sum of Squares):</strong> Goal is to
<strong>minimize</strong>. <span class="math display">\[RSS =
\sum_{i=1}^{n} (y_i - \hat{y}_i)^2\]</span> Good for comparing models
<em>of the same size <span
class="math inline">\(k\)</span></em>.</p></li>
<li><p><strong>Adjusted R-squared (<span class="math inline">\(Adj.
R^2\)</span>):</strong> Goal is to <strong>maximize</strong>. <span
class="math display">\[Adj. R^2 = 1 -
\frac{(1-R^2)(n-1)}{n-p-1}\]</span> This “adjusts” <span
class="math inline">\(R^2\)</span> by adding a penalty for having more
predictors (<span class="math inline">\(p\)</span>). Adding a useless
predictor will make <span class="math inline">\(Adj. R^2\)</span> go
down.</p></li>
<li><p><strong>Mallow’s <span
class="math inline">\(C_p\)</span>:</strong> Goal is to
<strong>minimize</strong>. <span class="math display">\[C_p \approx
\frac{1}{n}(RSS + 2p\hat{\sigma}^2)\]</span> Here, <span
class="math inline">\(\hat{\sigma}^2\)</span> is an estimate of the
error variance from the <em>full model</em> (with all <span
class="math inline">\(p\)</span> predictors). A good model will have
<span class="math inline">\(C_p \approx p\)</span>.</p></li>
<li><p><strong>AIC (Akaike Information Criterion) &amp; BIC (Bayesian
Information Criterion):</strong> Goal is to <strong>minimize</strong>.
<span class="math display">\[AIC = 2p - 2\ln(\hat{L})\]</span> <span
class="math display">\[BIC = p\ln(n) - 2\ln(\hat{L})\]</span> Here,
<span class="math inline">\(\hat{L}\)</span> is the maximized likelihood
of the model. You don’t need to calculate this by hand; software
provides it.</p>
<ul>
<li><strong>Key difference:</strong> BIC’s penalty for <span
class="math inline">\(p\)</span> is <span
class="math inline">\(p\ln(n)\)</span>, while AIC’s is <span
class="math inline">\(2p\)</span>. Since <span
class="math inline">\(\ln(n)\)</span> is almost always <span
class="math inline">\(&gt; 2\)</span> (for <span
class="math inline">\(n&gt;7\)</span>), <strong>BIC applies a much
heavier penalty for complexity</strong>.</li>
<li>This means <strong>BIC tends to choose smaller, more parsimonious
models</strong> than AIC or <span class="math inline">\(Adj.
R^2\)</span>.</li>
</ul></li>
</ul>
<h2 id="python-code-analysis-slide-225546.jpg">5. Python Code Analysis
(Slide <code>225546.jpg</code>)</h2>
<p>This slide shows the Python code for <strong>Best Subset
Selection</strong> (BSS).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import necessary libraries</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations <span class="comment"># &lt;-- This is the BSS engine</span></span><br></pre></td></tr></table></figure>
<h3 id="block-1-load-the-credit-dataset">Block 1: Load the Credit
dataset</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Load the Credit dataset</span></span><br><span class="line">Credit = pd.read_csv(<span class="string">&#x27;Credit.csv&#x27;</span>)</span><br><span class="line">Credit[<span class="string">&#x27;ID&#x27;</span>] = Credit[<span class="string">&#x27;ID&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">(num_samples, num_predictors) = Credit.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert categorical text data to numerical (dummy variables)</span></span><br><span class="line">Credit[<span class="string">&#x27;Gender&#x27;</span>] = Credit[<span class="string">&#x27;Gender&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;Male&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Female&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Credit[<span class="string">&#x27;Student&#x27;</span>] = Credit[<span class="string">&#x27;Student&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;Yes&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;No&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Credit[<span class="string">&#x27;Married&#x27;</span>] = Credit[<span class="string">&#x27;Married&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;Yes&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;No&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Credit[<span class="string">&#x27;Ethnicity&#x27;</span>] = Credit[<span class="string">&#x27;Ethnicity&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;Asian&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Caucasian&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;African American&#x27;</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>pd.read_csv</code></strong>: Reads the data into a
<code>pandas</code> DataFrame.</li>
<li><strong><code>.map()</code></strong>: This is a crucial
preprocessing step. Regression models require numbers, not text like
‘Yes’ or ‘Male’. This line converts those strings into <code>1</code>s
and <code>0</code>s.</li>
</ul>
<h3 id="block-2-plot-scatterplot-matrix">Block 2: Plot scatterplot
matrix</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. Plot scatterplot matrix</span></span><br><span class="line">selected_columns = [<span class="string">&#x27;Balance&#x27;</span>, <span class="string">&#x27;Education&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Cards&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>, <span class="string">&#x27;Limit&#x27;</span>, <span class="string">&#x27;Income&#x27;</span>]</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;ticks&quot;</span>)</span><br><span class="line">sns.pairplot(Credit[selected_columns], diag_kind=<span class="string">&#x27;kde&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">&#x27;Scatterplot Matrix&#x27;</span>, y=<span class="number">1.02</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>sns.pairplot</code></strong>: A powerful visualization
from the <code>seaborn</code> library. The resulting plot (right side of
the slide) is a grid.
<ul>
<li><strong>Diagonal plots (kde)</strong>: Show the distribution (Kernel
Density Estimate) of a single variable (e.g., ‘Balance’ is skewed
right).</li>
<li><strong>Off-diagonal plots (scatter)</strong>: Show the relationship
between two variables (e.g., ‘Limit’ and ‘Rating’ are almost perfectly
linear). This helps you visually spot potentially strong
predictors.</li>
</ul></li>
</ul>
<h3 id="block-3-best-subset-selection">Block 3: Best Subset
Selection</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Best Subset Selection</span></span><br><span class="line"><span class="comment"># (This code is incomplete on the slide, I&#x27;ll fill in the logic)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define target and predictors</span></span><br><span class="line">target = <span class="string">&#x27;Balance&#x27;</span></span><br><span class="line">predictors = [col <span class="keyword">for</span> col <span class="keyword">in</span> Credit.columns <span class="keyword">if</span> col != target] </span><br><span class="line">nvmax = <span class="number">10</span> <span class="comment"># Max number of predictors to test (up to 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize lists to store model statistics</span></span><br><span class="line">model_stats = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over number of predictors from 1 to nvmax</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nvmax + <span class="number">1</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Generate all possible combinations of predictors of size k</span></span><br><span class="line">    <span class="comment"># This is the core of BSS</span></span><br><span class="line">    <span class="keyword">for</span> subset <span class="keyword">in</span> <span class="built_in">list</span>(combinations(predictors, k)):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the design matrix (X)</span></span><br><span class="line">        X_subset = Credit[<span class="built_in">list</span>(subset)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add a constant (intercept) term to the model</span></span><br><span class="line">        <span class="comment"># Y = B0 + B1*X1 -&gt; statsmodels needs B0 to be added manually</span></span><br><span class="line">        X_subset_const = sm.add_constant(X_subset)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the target variable (y)</span></span><br><span class="line">        y_target = Credit[target]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Fit the Ordinary Least Squares (OLS) model</span></span><br><span class="line">        model = sm.OLS(y_target, X_subset_const).fit()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate RSS</span></span><br><span class="line">        RSS = ((model.resid) ** <span class="number">2</span>).<span class="built_in">sum</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># (The full code would also calculate R-squared, Adj. R-sq, BIC, etc. here)</span></span><br><span class="line">        <span class="comment"># model_stats.append(&#123;&#x27;k&#x27;: k, &#x27;subset&#x27;: subset, &#x27;RSS&#x27;: RSS, ...&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>for k in range(1, nvmax + 1)</code></strong>: This is
the <em>outer</em> loop that iterates from <span
class="math inline">\(k=1\)</span> (1 predictor) to <span
class="math inline">\(k=10\)</span> (10 predictors).</li>
<li><strong><code>list(combinations(predictors, k))</code></strong>:
This is the <em>inner</em> loop and the <strong>most important
line</strong>. The <code>itertools.combinations</code> function is a
highly efficient way to generate all unique subsets.
<ul>
<li>When <span class="math inline">\(k=1\)</span>, it returns
<code>[('Income',), ('Limit',), ('Rating',), ...]</code>.</li>
<li>When <span class="math inline">\(k=2\)</span>, it returns
<code>[('Income', 'Limit'), ('Income', 'Rating'), ('Limit', 'Rating'), ...]</code>.</li>
<li>This is what generates the <span class="math inline">\(2^p\)</span>
(or in this case, <span class="math inline">\(\sum_{k=1}^{10}
\binom{p}{k}\)</span>) models to test.</li>
</ul></li>
<li><strong><code>sm.add_constant(X_subset)</code></strong>: Your
regression equation is <span class="math inline">\(Y = \beta_0 +
\beta_1X_1\)</span>. The <span class="math inline">\(X_1\)</span> is
your <code>X_subset</code>. The <code>sm.add_constant</code> function
adds a column of <code>1</code>s to your data, which allows the
<code>statsmodels</code> library to estimate the <span
class="math inline">\(\beta_0\)</span> (intercept) term.</li>
<li><strong><code>sm.OLS(y_target, X_subset_const).fit()</code></strong>:
This fits the Ordinary Least Squares (OLS) model, which finds the <span
class="math inline">\(\beta\)</span> coefficients that <strong>minimize
the RSS</strong>.</li>
<li><strong><code>model.resid</code></strong>: This attribute of the
fitted model contains the residuals (<span class="math inline">\(e_i =
y_i - \hat{y}_i\)</span>) for each data point.</li>
<li><strong><code>((model.resid) ** 2).sum()</code></strong>: This line
is the direct code implementation of the formula <span
class="math inline">\(RSS = \sum e_i^2\)</span>.</li>
</ul>
<h2 id="synthesizing-the-results-the-plots">Synthesizing the Results
(The Plots)</h2>
<p>After running the BSS code, you get the data used in the plots and
the table.</p>
<ul>
<li><p><strong>Image <code>225550.png</code> (Adjusted
R-squared)</strong></p>
<ul>
<li><strong>Goal:</strong> Maximize.</li>
<li><strong>What it shows:</strong> The gray dots are <em>all</em> the
models tested for each <span class="math inline">\(k\)</span>. The red
line connects the single <em>best</em> model for each <span
class="math inline">\(k\)</span>.</li>
<li><strong>Conclusion:</strong> The plot shows a sharp “elbow.” The
<span class="math inline">\(Adj. R^2\)</span> increases dramatically up
to <span class="math inline">\(k=4\)</span>, then increases very slowly.
The maximum is around <span class="math inline">\(k=6\)</span> or <span
class="math inline">\(k=7\)</span>, but the gain after <span
class="math inline">\(k=4\)</span> is minimal.</li>
</ul></li>
<li><p><strong>Image <code>225554.png</code> (BIC)</strong></p>
<ul>
<li><strong>Goal:</strong> Minimize.</li>
<li><strong>What it shows:</strong> BIC heavily penalizes
complexity.</li>
<li><strong>Conclusion:</strong> The plot shows a very clear minimum.
The BIC value plummets from <span class="math inline">\(k=2\)</span> to
<span class="math inline">\(k=3\)</span> and hits its lowest point at
<strong><span class="math inline">\(k=4\)</span></strong>. After <span
class="math inline">\(k=4\)</span>, the penalty for adding more
variables is <em>larger</em> than the benefit in model fit, so the BIC
score starts to rise. This is a very strong vote for the 4-predictor
model.</li>
</ul></li>
<li><p><strong>Image <code>225635.png</code> (Mallow’s <span
class="math inline">\(C_p\)</span>)</strong></p>
<ul>
<li><strong>Goal:</strong> Minimize.</li>
<li><strong>What it shows:</strong> A very similar story to BIC.</li>
<li><strong>Conclusion:</strong> The <span
class="math inline">\(C_p\)</span> value drops significantly and hits
its minimum at <strong><span
class="math inline">\(k=4\)</span></strong>.</li>
</ul></li>
<li><p><strong>Image <code>225638.png</code> (Summary
Table)</strong></p>
<ul>
<li>This is the <strong>most important image</strong> for the final
conclusion. It summarizes the red line from all the plots.</li>
<li>Look at the row for <code>Num_Predictors = 4</code>. The predictors
are <strong>(Income, Limit, Cards, Student)</strong>.</li>
<li>Now look at the columns for <code>BIC</code> and <code>Cp</code>.
<ul>
<li><strong>BIC:</strong> <code>4841.615607</code>. This is the lowest
value in the entire <code>BIC</code> column (the value at <span
class="math inline">\(k=3\)</span> is <code>4865.352851</code>).</li>
<li><strong>Cp:</strong> <code>7.122228</code>. This is also the lowest
value in the <code>Cp</code> column.</li>
</ul></li>
<li>The <code>Adj_R_squared</code> at <span
class="math inline">\(k=4\)</span> is <code>0.953580</code>, which is
very close to its maximum of <code>~0.954</code> at <span
class="math inline">\(k=7-10\)</span>.</li>
</ul></li>
</ul>
<p><strong>Final Conclusion:</strong> All three “penalized” criteria
(Adjusted <span class="math inline">\(R^2\)</span>, BIC, and <span
class="math inline">\(C_p\)</span>) point to the same conclusion. While
<span class="math inline">\(Adj. R^2\)</span> is a bit ambiguous,
<strong>BIC and <span class="math inline">\(C_p\)</span> provide a clear
signal that the best, most parsimonious model is the 4-predictor model
using <code>Income</code>, <code>Limit</code>, <code>Cards</code>, and
<code>Student</code></strong>.</p>
<h1 id="subset-selection">4. Subset Selection</h1>
<h2 id="summary-of-subset-selection">Summary of Subset Selection</h2>
<p>These slides introduce <strong>subset selection</strong>, a process
in statistical learning used to identify the best subset of predictors
(variables) for a regression model. The goal is to find a model that has
low prediction error and avoids overfitting by excluding irrelevant
variables.</p>
<p>The slides cover two main “greedy” (stepwise) algorithms and the
criteria used to select the final best model.</p>
<h2 id="stepwise-selection-algorithms">Stepwise Selection
Algorithms</h2>
<p>Instead of testing all <span class="math inline">\(2^p\)</span>
possible models (which is “best subset selection” and computationally
unfeasible), stepwise methods build a single path of models.</p>
<h3 id="forward-stepwise-selection">Forward Stepwise Selection</h3>
<p>This is an <strong>additive</strong> (bottom-up) approach:</p>
<ol type="1">
<li><strong>Start</strong> with the null model (no predictors).</li>
<li><strong>Find</strong> the best 1-variable model (the one that gives
the lowest Residual Sum of Squares, or RSS).</li>
<li><strong>Add</strong> the single variable that, when added to the
current model, results in the <em>new</em> best model (lowest RSS).</li>
<li><strong>Repeat</strong> this process until all <span
class="math inline">\(p\)</span> predictors are in the model.</li>
<li>This generates a sequence of <span
class="math inline">\(p+1\)</span> models, from <span
class="math inline">\(\mathcal{M}_0\)</span> to <span
class="math inline">\(\mathcal{M}_p\)</span>.</li>
</ol>
<h3 id="backward-stepwise-selection">Backward Stepwise Selection</h3>
<p>This is a <strong>subtractive</strong> (top-down) approach:</p>
<ol type="1">
<li><strong>Start</strong> with the full model containing all <span
class="math inline">\(p\)</span> predictors.</li>
<li><strong>Find</strong> the best <span
class="math inline">\((p-1)\)</span>-variable model by <em>removing</em>
the single variable that results in the <em>lowest RSS</em> (or highest
<span class="math inline">\(R^2\)</span>). This variable is considered
the least significant.</li>
<li><strong>Remove</strong> the next variable that, when removed from
the current best model, gives the new best model.</li>
<li><strong>Repeat</strong> until only the null model remains.</li>
<li>This also generates a sequence of <span
class="math inline">\(p+1\)</span> models.</li>
</ol>
<h4 id="pros-and-cons-backward-selection">Pros and Cons (Backward
Selection)</h4>
<ul>
<li><strong>Pro:</strong> Computationally efficient compared to best
subset. It fits <span class="math inline">\(1 + \sum_{k=0}^{p-1}(p-k) =
\mathbf{1 + p(p+1)/2}\)</span> models, which is much less than <span
class="math inline">\(2^p\)</span>. (e.g., for <span
class="math inline">\(p=20\)</span>, it’s 211 models vs. &gt;1
million).</li>
<li><strong>Con:</strong> <strong>Cannot be used if <span
class="math inline">\(p &gt; n\)</span></strong> (more predictors than
observations), because the initial full model cannot be fit.</li>
<li><strong>Con (for both):</strong> These methods are
<strong>greedy</strong>. A variable added in forward selection is
<em>never removed</em>, and a variable removed in backward selection is
<em>never added back</em>. This means they are not guaranteed to find
the true best model.</li>
</ul>
<h2 id="choosing-the-final-best-model">Choosing the Final Best
Model</h2>
<p>Both forward and backward selection give you a set of candidate
models (e.g., the best 1-variable model, best 2-variable model, etc.).
You must then choose the <em>single best</em> one. The slides show two
main approaches:</p>
<h3 id="a.-direct-error-estimation">A. Direct Error Estimation</h3>
<p>Use a validation set or cross-validation (CV) to estimate the test
error for each model (e.g., the 1-variable, 2-variable… models).
<strong>Choose the model with the lowest estimated test
error.</strong></p>
<h3 id="b.-adjusted-metrics-penalizing-for-complexity">B. Adjusted
Metrics (Penalizing for Complexity)</h3>
<p>Standard RSS and <span class="math inline">\(R^2\)</span> will always
improve as you add variables, leading to overfitting. Instead, use
metrics that <em>penalize</em> the model for having too many
predictors.</p>
<ul>
<li><p><strong>Mallows’ <span
class="math inline">\(C_p\)</span>:</strong> An estimate of test Mean
Squared Error (MSE). <span class="math display">\[C_p = \frac{1}{n} (RSS
+ 2d\hat{\sigma}^2)\]</span> (where <span
class="math inline">\(d\)</span> is the number of predictors, and <span
class="math inline">\(\hat{\sigma}^2\)</span> is an estimate of the
error variance). <strong>You want to find the model with the
<em>minimum</em> <span
class="math inline">\(C_p\)</span>.</strong></p></li>
<li><p><strong>BIC (Bayesian Information Criterion):</strong> <span
class="math display">\[BIC = \frac{1}{n} (RSS +
\log(n)d\hat{\sigma}^2)\]</span> BIC’s penalty <span
class="math inline">\(\log(n)\)</span> is stronger than <span
class="math inline">\(C_p\)</span>’s (or AIC’s) penalty of <span
class="math inline">\(2\)</span>, so it tends to select <em>smaller</em>
(more parsimonious) models. <strong>You want to find the model with the
<em>minimum</em> BIC.</strong></p></li>
<li><p><strong>Adjusted <span
class="math inline">\(R^2\)</span>:</strong> <span
class="math display">\[R^2_{adj} = 1 -
\frac{RSS/(n-d-1)}{TSS/(n-1)}\]</span> (where <span
class="math inline">\(TSS\)</span> is the Total Sum of Squares). Unlike
<span class="math inline">\(R^2\)</span>, this metric can decrease if
adding a variable doesn’t help enough. <strong>You want to find the
model with the <em>maximum</em> Adjusted <span
class="math inline">\(R^2\)</span>.</strong></p></li>
</ul>
<h2 id="python-code-understanding">Python Code Understanding</h2>
<p>The slides use the <code>regsubsets()</code> function from the
<code>leaps</code> package in <strong>R</strong>.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># R Code from slides</span></span><br><span class="line">library<span class="punctuation">(</span>leaps<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Forward Selection</span></span><br><span class="line">regfit.fwd <span class="operator">&lt;-</span> regsubsets<span class="punctuation">(</span>Balance<span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Credit<span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&quot;forward&quot;</span><span class="punctuation">,</span> nvmax<span class="operator">=</span><span class="number">11</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Backward Selection</span></span><br><span class="line">regfit.bwd <span class="operator">&lt;-</span> regsubsets<span class="punctuation">(</span>Balance<span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Credit<span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&quot;backward&quot;</span><span class="punctuation">,</span> nvmax<span class="operator">=</span><span class="number">11</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>In <strong>Python</strong>, the standard tool for this is
<code>SequentialFeatureSelector</code> from
<strong><code>scikit-learn</code></strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SequentialFeatureSelector</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume &#x27;Credit&#x27; is a pandas DataFrame with &#x27;Balance&#x27; as the target</span></span><br><span class="line">X = Credit.drop(<span class="string">&#x27;Balance&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">y = Credit[<span class="string">&#x27;Balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the linear regression estimator</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Forward Selection ---</span></span><br><span class="line"><span class="comment"># direction=&#x27;forward&#x27; starts with 0 features and adds them</span></span><br><span class="line"><span class="comment"># To get the best 4-variable model, for example:</span></span><br><span class="line">sfs_forward = SequentialFeatureSelector(</span><br><span class="line">    model,</span><br><span class="line">    n_features_to_select=<span class="number">4</span>,</span><br><span class="line">    direction=<span class="string">&#x27;forward&#x27;</span>,</span><br><span class="line">    cv=<span class="literal">None</span> <span class="comment"># Or use cross-validation, e.g., cv=10</span></span><br><span class="line">)</span><br><span class="line">sfs_forward.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Forward selection best 4 features:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sfs_forward.get_feature_names_out())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Backward Selection ---</span></span><br><span class="line"><span class="comment"># direction=&#x27;backward&#x27; starts with all features and removes them</span></span><br><span class="line">sfs_backward = SequentialFeatureSelector(</span><br><span class="line">    model,</span><br><span class="line">    n_features_to_select=<span class="number">4</span>,</span><br><span class="line">    direction=<span class="string">&#x27;backward&#x27;</span>,</span><br><span class="line">    cv=<span class="literal">None</span></span><br><span class="line">)</span><br><span class="line">sfs_backward.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nBackward selection best 4 features:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sfs_backward.get_feature_names_out())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: To replicate the plots, you would loop this process,</span></span><br><span class="line"><span class="comment"># changing &#x27;n_features_to_select&#x27; from 1 to p,</span></span><br><span class="line"><span class="comment"># record the model scores (e.g., RSS, AIC, BIC) at each step,</span></span><br><span class="line"><span class="comment"># and then plot the results.</span></span><br></pre></td></tr></table></figure>
<h2 id="important-images">Important Images</h2>
<ol type="1">
<li><p><strong>Slide <code>...230014.png</code> (Forward Selection
Plots) &amp; <code>...230036.png</code> (Backward Selection
Plots):</strong></p>
<ul>
<li><strong>What they are:</strong> These <span class="math inline">\(2
\times 2\)</span> plot grids are the most important visuals. They show
<strong>Residual Sum of Squares (RSS)</strong>, <strong>Adjusted <span
class="math inline">\(R^2\)</span></strong>, <strong>BIC</strong>, and
<strong>Mallows’ <span class="math inline">\(C_p\)</span></strong>
plotted against the <em>Number of Variables</em>.</li>
<li><strong>Why they’re important:</strong> They are the
<strong>decision-making tool</strong>. You use these plots to choose the
best model.
<ul>
<li>You look for the “elbow” or <strong>minimum</strong> value for BIC
and <span class="math inline">\(C_p\)</span>.</li>
<li>You look for the “peak” or <strong>maximum</strong> value for
Adjusted <span class="math inline">\(R^2\)</span>.</li>
<li>(RSS is not used for selection as it always decreases).</li>
</ul></li>
</ul></li>
<li><p><strong>Slide <code>...230040.png</code> (Find the best
model):</strong></p>
<ul>
<li><strong>What it is:</strong> This slide shows a close-up of the
<span class="math inline">\(C_p\)</span>, BIC, and Adjusted <span
class="math inline">\(R^2\)</span> plots, with the “best” model (the
min/max) marked with a blue ‘x’.</li>
<li><strong>Why it’s important:</strong> It explicitly states the
selection criteria. The text highlights that BIC suggests a 4-variable
model, while the other two are “rather flat” after 4, making the choice
less obvious but pointing to a simple model.</li>
</ul></li>
<li><p><strong>Slide <code>...230045.png</code> (BIC vs. Validation
vs. CV):</strong></p>
<ul>
<li><strong>What it is:</strong> This shows three plots for selecting
the best model using different criteria: BIC, Validation Set Error, and
Cross-Validation Error.</li>
<li><strong>Why it’s important:</strong> It shows that <strong>different
selection criteria can lead to different “best” models</strong>. Here,
BIC (a mathematical adjustment) picks a 4-variable model, while
validation and CV (direct error estimation) both pick a 6-variable
model.</li>
</ul></li>
</ol>
<p>The slides use the <code>Credit</code> dataset to demonstrate two key
tasks: 1. <strong>Running</strong> different subset selection algorithms
(forward, backward, best). 2. <strong>Using</strong> various statistical
metrics (BIC, <span class="math inline">\(C_p\)</span>, CV error) to
choose the single best model.</p>
<h2 id="comparing-selection-algorithms-the-path">Comparing Selection
Algorithms (The Path)</h2>
<p>This part of the example compares the <em>sequence</em> of models
selected by “Forward Stepwise” selection versus “Best Subset”
selection.</p>
<p><strong>Key Result (from Table 6.1):</strong></p>
<p>This table is the most important result for comparing the
algorithms.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Variables</th>
<th style="text-align: left;">Best Subset</th>
<th style="text-align: left;">Forward Stepwise</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>one</strong></td>
<td style="text-align: left;"><code>rating</code></td>
<td style="text-align: left;"><code>rating</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>two</strong></td>
<td style="text-align: left;"><code>rating</code>,
<code>income</code></td>
<td style="text-align: left;"><code>rating</code>,
<code>income</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>three</strong></td>
<td style="text-align: left;"><code>rating</code>, <code>income</code>,
<code>student</code></td>
<td style="text-align: left;"><code>rating</code>, <code>income</code>,
<code>student</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>four</strong></td>
<td style="text-align: left;"><code>cards</code>, <code>income</code>,
<code>student</code>, <code>limit</code></td>
<td style="text-align: left;"><code>rating</code>, <code>income</code>,
<code>student</code>, <code>limit</code></td>
</tr>
</tbody>
</table>
<p><strong>Summary of this result:</strong></p>
<ul>
<li><strong>Identical for 1, 2, and 3 variables:</strong> Both methods
agree on the best one-variable model (<code>rating</code>), the best
two-variable model (<code>rating</code>, <code>income</code>), and the
best three-variable model (<code>rating</code>, <code>income</code>,
<code>student</code>).</li>
<li><strong>They Diverge at 4 variables:</strong>
<ul>
<li><strong>Forward selection</strong> is <em>greedy</em>. It started
with <code>rating</code>, <code>income</code>, <code>student</code> and
was “stuck” with them. It then added <code>limit</code>, as that was the
best variable to <em>add</em> to its existing 3-variable model.</li>
<li><strong>Best subset selection</strong> is <em>not</em> greedy. It
tests all possible 4-variable combinations. It discovered that the model
<code>cards</code>, <code>income</code>, <code>student</code>,
<code>limit</code> has a slightly lower RSS than the model forward
selection found.</li>
</ul></li>
<li><strong>Main Takeaway:</strong> This demonstrates the limitation of
a greedy algorithm. Forward selection missed the “true” best 4-variable
model because it was locked into its previous choices and couldn’t “swap
out” <code>rating</code> for <code>cards</code>.</li>
</ul>
<h2 id="choosing-the-single-best-model-the-destination">Choosing the
Single Best Model (The Destination)</h2>
<p>This is the most critical part of the analysis. After running a
selection algorithm (like forward, backward, or best subset), you get a
list of the “best” models for each size (best 1-variable, best
2-variable, etc.). Now you must decide: <strong>is the best model the
4-variable one, the 6-variable one, or another?</strong></p>
<p>The slides show several plots to help make this decision, all plotted
against the “Number of Predictors.”</p>
<p><strong>Summary of Plot Results:</strong></p>
<p>Here’s what each plot tells you:</p>
<ul>
<li><strong>Residual Sum of Squares (RSS)</strong> (e.g., in slide
<code>...230014.png</code>, top-left)
<ul>
<li><strong>What it shows:</strong> RSS <em>always</em> decreases as you
add more variables. It drops sharply until 4 variables, then flattens
out.</li>
<li><strong>Conclusion:</strong> This plot is <strong>not useful for
picking the best model</strong> because it will always pick the full
model, which is overfit. It’s only used to see the diminishing returns
of adding new variables.</li>
</ul></li>
<li><strong>Adjusted <span class="math inline">\(R^2\)</span></strong>
(e.g., in slide <code>...230040.png</code>, right)
<ul>
<li><strong>What it shows:</strong> This metric penalizes adding useless
variables. The plot rises quickly, then flattens, peaking at its
<strong>maximum value around 6 or 7 variables</strong>.</li>
<li><strong>Conclusion:</strong> This metric suggests a <strong>6 or
7-variable model</strong>.</li>
</ul></li>
<li><strong>Mallows’ <span class="math inline">\(C_p\)</span></strong>
(e.g., in slide <code>...230040.png</code>, left)
<ul>
<li><strong>What it shows:</strong> This is an estimate of test error.
We want the model with the <strong>minimum <span
class="math inline">\(C_p\)</span></strong>. The plot drops to a low
value at 4 variables and stays low, with its absolute minimum around
<strong>6 or 7 variables</strong>.</li>
<li><strong>Conclusion:</strong> This metric also suggests a <strong>6
or 7-variable model</strong>.</li>
</ul></li>
<li><strong>BIC (Bayesian Information Criterion)</strong> (e.g., in
slide <code>...230040.png</code>, center)
<ul>
<li><strong>What it shows:</strong> This is another estimate of test
error, but it has a <em>stronger penalty</em> for model complexity. The
plot shows a clear “U” shape, reaching its <strong>minimum value at 4
variables</strong> and then <em>increasing</em> afterward.</li>
<li><strong>Conclusion:</strong> This metric strongly suggests a
<strong>4-variable model</strong>.</li>
</ul></li>
<li><strong>Validation Set &amp; Cross-Validation (CV) Error</strong>
(Slide <code>...230045.png</code>)
<ul>
<li><strong>What it shows:</strong> These plots show the <em>direct</em>
estimate of test error (not a mathematical adjustment like BIC or <span
class="math inline">\(C_p\)</span>). Both the validation set error and
the 10-fold CV error show a “U” shape.</li>
<li><strong>Conclusion:</strong> Both methods reach their
<strong>minimum error at 6 variables</strong>. This is considered a very
reliable result.</li>
</ul></li>
</ul>
<h2 id="final-summary-of-results">Final Summary of Results</h2>
<p>The analysis of the <code>Credit</code> dataset reveals two strong
candidates for the “best” model, depending on your goal:</p>
<ol type="1">
<li><p><strong>The 6-Variable Model:</strong> This model is supported by
the <strong>Adjusted <span class="math inline">\(R^2\)</span></strong>,
<strong>Mallows’ <span class="math inline">\(C_p\)</span></strong>, and
(most importantly) the <strong>Validation Set</strong> and
<strong>10-fold Cross-Validation</strong> results. These metrics all
indicate that the 6-variable model has the <strong>lowest prediction
error</strong> on new data.</p></li>
<li><p><strong>The 4-Variable Model:</strong> This model is supported by
<strong>BIC</strong>. Because BIC penalizes complexity more heavily, it
selects a simpler (more <em>parsimonious</em>) model.</p></li>
</ol>
<p><strong>Overall Conclusion:</strong> If your primary goal is
<strong>maximum predictive accuracy</strong>, you should choose the
<strong>6-variable model</strong>. If your goal is a <strong>simpler,
more interpretable model</strong> that is still very good (and avoids
any risk of overfitting), the <strong>4-variable model</strong> is an
excellent choice.</p>
<h1
id="two-main-strategies-for-controlling-model-complexity-in-linear-regression">5.
Two main strategies for controlling model complexity in linear
regression</h1>
<p>This presentation covers two main strategies for controlling model
complexity in linear regression: <strong>Subset Selection</strong>
(choosing <em>which</em> variables to include) and <strong>Shrinkage
Methods</strong> (keeping all variables but <em>reducing the impact</em>
of their coefficients).</p>
<h2 id="subset-selection-1">Subset Selection</h2>
<p>This method involves selecting a subset of the <span
class="math inline">\(p\)</span> total predictors to use in the
model.</p>
<h3 id="key-concepts-formulas">Key Concepts &amp; Formulas</h3>
<ul>
<li><p><strong>The Model:</strong> The standard linear regression model
is represented in matrix form: <span class="math display">\[\mathbf{y} =
\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\epsilon}\]</span> The goal
of subset selection is to find a coefficient vector <span
class="math inline">\(\boldsymbol{\beta}\)</span> that is
<strong>sparse</strong>, meaning it has many zero entries.</p></li>
<li><p><strong>Forward Selection:</strong> This is a <em>greedy
algorithm</em> that starts with an empty model and iteratively adds the
single predictor that most improves the fit.</p></li>
<li><p><strong>Theoretical Guarantee:</strong> Can forward selection
find the <em>true</em> sparse set of variables?</p>
<ul>
<li>Yes, <em>if</em> the predictors are not strongly correlated.</li>
<li>This is quantified by the <strong>Mutual Coherence
Condition</strong>. Assuming the predictors <span
class="math inline">\(\mathbf{x}_i\)</span> are normalized, the method
is guaranteed to work if: <span class="math display">\[\mu = \max_{i
\neq j} |\langle \mathbf{x}_i, \mathbf{x}_j \rangle| &lt; \frac{1}{2s -
1}\]</span> where <span class="math inline">\(s\)</span> is the number
of true non-zero coefficients and <span class="math inline">\(\langle
\mathbf{x}_i, \mathbf{x}_j \rangle\)</span> represents the correlation
between predictors.</li>
</ul></li>
</ul>
<h3 id="practical-application-finding-the-best-model-size">Practical
Application: Finding the Best Model Size</h3>
<p>How do you know whether to choose a model with 3, 4, or 5 variables?
You use <strong>Cross-Validation (CV)</strong>.</p>
<ul>
<li><p><strong>Important Image:</strong> The plot titled “10-fold CV”
(from the first slide) is the most important visual. It plots the
estimated test error (CV Error) on the y-axis against the number of
variables in the model on the x-axis.</p></li>
<li><p><strong>The “One Standard Deviation Rule”:</strong> Looking at
the plot, the error drops sharply and then flattens. The absolute
minimum error might be at 6 variables, but it’s only slightly better
than the 3-variable model.</p>
<ol type="1">
<li>Find the model with the <em>lowest</em> CV error.</li>
<li>Calculate the standard error for that error estimate.</li>
<li>Select the <strong>simplest model</strong> (fewest variables) whose
error is <em>within one standard deviation</em> of the minimum.</li>
<li>This follows <strong>Occam’s razor</strong>: choose the simplest
explanation (model) that fits the data well enough. In the example
given, this rule selects the 3-variable model.</li>
</ol></li>
</ul>
<h3 id="code-interpretation-r-vs.-python">Code Interpretation (R
vs. Python)</h3>
<p>The R code in the first slide performs this 10-fold CV manually for
forward selection:</p>
<ol type="1">
<li>It loops from <code>p = 1</code> to <code>10</code> (model
sizes).</li>
<li>Inside the loop, it identifies the <code>p</code> variables chosen
by a pre-computed forward selection model
(<code>regfit.fwd</code>).</li>
<li>It fits a new model (<code>glm.fit</code>) using <em>only</em> those
<code>p</code> variables.</li>
<li>It runs 10-fold CV (<code>cv.glm</code>) on <em>that specific
model</em> to get its test error.</li>
<li>It stores the error in <code>CV10.err[p]</code>.</li>
<li>Finally, it plots the results.</li>
</ol>
<p><strong>In Python (with <code>scikit-learn</code>):</strong> This
entire process is often automated.</p>
<ul>
<li>You would use <code>sklearn.feature_selection.RFECV</code>
(Recursive Feature Elimination with Cross-Validation).</li>
<li><code>RFECV</code> automatically performs cross-validation to find
the optimal number of features, effectively producing the same plot and
result as the R code.</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conceptual Python equivalent for finding the best model size</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFECV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"></span><br><span class="line"><span class="comment"># X, y = load_your_data()</span></span><br><span class="line">X, y = make_regression(n_samples=<span class="number">100</span>, n_features=<span class="number">10</span>, n_informative=<span class="number">3</span>, noise=<span class="number">10</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">estimator = LinearRegression()</span><br><span class="line"><span class="comment"># RFECV will test models with 1 feature, 2 features, etc.,</span></span><br><span class="line"><span class="comment"># and use cross-validation (cv=10) to find the best number.</span></span><br><span class="line">selector = RFECV(estimator, step=<span class="number">1</span>, cv=<span class="number">10</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line">selector = selector.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Optimal number of features: <span class="subst">&#123;selector.n_features_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># You can plot selector.cv_results_[&#x27;mean_test_score&#x27;] to get the CV curve</span></span><br></pre></td></tr></table></figure>
<h2 id="shrinkage-methods-regularization">Shrinkage Methods
(Regularization)</h2>
<p>Instead of explicitly removing variables, shrinkage methods keep all
<span class="math inline">\(p\)</span> variables but <em>shrink</em>
their coefficients <span class="math inline">\(\beta_j\)</span> towards
zero.</p>
<h3 id="ridge-regression">Ridge Regression</h3>
<p>Ridge regression is a prime example of a shrinkage method.</p>
<ul>
<li><p><strong>Objective Function:</strong> It finds the coefficients
<span class="math inline">\(\boldsymbol{\beta}\)</span> that minimize a
new quantity: <span class="math display">\[\underbrace{\sum_{i=1}^{n}
(y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij})^2}_{\text{RSS (Goodness
of Fit)}} + \underbrace{\lambda \sum_{j=1}^{p}
\beta_j^2}_{\text{$\ell_2$ Penalty (Shrinkage)}}\]</span></p></li>
<li><p><strong>The <span class="math inline">\(\lambda\)</span> Tuning
Parameter:</strong> This parameter controls the strength of the
penalty:</p>
<ul>
<li><strong>If <span class="math inline">\(\lambda =
0\)</span>:</strong> The penalty term disappears. Ridge regression is
identical to standard Ordinary Least Squares (OLS).</li>
<li><strong>If <span class="math inline">\(\lambda \to
\infty\)</span>:</strong> The penalty is “infinitely” strong. To
minimize the function, all coefficients <span
class="math inline">\(\beta_j\)</span> (for <span
class="math inline">\(j=1...p\)</span>) are forced to be zero. The model
becomes an intercept-only model.</li>
<li><strong>Note:</strong> The intercept <span
class="math inline">\(\beta_0\)</span> is <em>not penalized</em>.</li>
</ul></li>
<li><p><strong>The Bias-Variance Trade-off:</strong> This is the core
concept of regularization.</p>
<ul>
<li>Standard OLS has low bias but can have high variance (it
overfits).</li>
<li>Ridge regression adds a <em>small amount of bias</em> (the
coefficients are “wrong” on purpose) to <strong>significantly reduce the
model’s variance</strong>.</li>
<li>This trade-off often leads to a model with a lower overall test
error.</li>
</ul></li>
<li><p><strong>Matrix Solution:</strong> The discussion slide asks “What
is the solution?”. While OLS has the solution <span
class="math inline">\(\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\)</span>, the Ridge
solution is: <span class="math display">\[\hat{\boldsymbol{\beta}}^R =
(\mathbf{X}^T\mathbf{X} + \lambda
\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}\]</span> where <span
class="math inline">\(\mathbf{I}\)</span> is the identity matrix. The
<span class="math inline">\(\lambda \mathbf{I}\)</span> term adds a
“ridge” to the diagonal, making the matrix invertible even if <span
class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> is singular (which
happens if <span class="math inline">\(p &gt; n\)</span> or predictors
are collinear).</p></li>
</ul>
<h3 id="an-essential-step-standardization">An Essential Step:
Standardization</h3>
<ul>
<li><strong>Problem:</strong> The <span
class="math inline">\(\ell_2\)</span> penalty <span
class="math inline">\(\lambda \sum \beta_j^2\)</span> is applied equally
to all coefficients. If predictor <span
class="math inline">\(x_1\)</span> (e.g., house size in sq-ft) is on a
much larger scale than <span class="math inline">\(x_2\)</span> (e.g.,
number of rooms), its coefficient <span
class="math inline">\(\beta_1\)</span> will naturally be much smaller
than <span class="math inline">\(\beta_2\)</span>. The penalty will
unfairly punish <span class="math inline">\(\beta_2\)</span> more.</li>
<li><strong>Solution:</strong> You <strong>must standardize</strong>
your inputs <em>before</em> fitting a Ridge model.</li>
<li><strong>Formula:</strong> For each predictor <span
class="math inline">\(X_j\)</span>, all its observations <span
class="math inline">\(x_{ij}\)</span> are rescaled: <span
class="math display">\[\tilde{x}_{ij} = \frac{x_{ij} -
\bar{x}_j}{\sigma_j}\]</span> (where <span
class="math inline">\(\bar{x}_j\)</span> is the mean of the predictor
and <span class="math inline">\(\sigma_j\)</span> is its standard
deviation). This puts all predictors on a common scale (mean=0,
std=1).</li>
</ul>
<p><strong>In Python (with <code>scikit-learn</code>):</strong></p>
<ul>
<li>You use <code>sklearn.preprocessing.StandardScaler</code> to
standardize your data.</li>
<li>You use <code>sklearn.linear_model.Ridge</code> to fit the
model.</li>
<li>You use <code>sklearn.linear_model.RidgeCV</code> to automatically
find the best value for <span class="math inline">\(\lambda\)</span>
(called <code>alpha</code> in scikit-learn) using cross-validation.</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conceptual Python code for Ridge Regression</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># X, y = load_your_data()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a pipeline that first standardizes the data,</span></span><br><span class="line"><span class="comment"># then fits a Ridge model.</span></span><br><span class="line"><span class="comment"># RidgeCV tests a range of alphas (lambdas) automatically.</span></span><br><span class="line">model = make_pipeline(</span><br><span class="line">    StandardScaler(),</span><br><span class="line">    RidgeCV(alphas=[<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">100.0</span>], scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best alpha (lambda): <span class="subst">&#123;model.named_steps[<span class="string">&#x27;ridgecv&#x27;</span>].alpha_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Model coefficients: <span class="subst">&#123;model.named_steps[<span class="string">&#x27;ridgecv&#x27;</span>].coef_&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="subset-selection-2">Subset Selection</h2>
<p>This section is about choosing <em>which</em> predictors (variables)
to include in your linear model. The main idea is to find a “sparse”
model (one with few variables) that performs well.</p>
<h3 id="the-model-and-the-goal">The Model and The Goal</h3>
<ul>
<li><strong>Slide: “Forward selection in Linear
Regression”</strong></li>
<li><strong>Formula:</strong> The standard linear regression model is
<span class="math inline">\(\mathbf{y} = \mathbf{X}\boldsymbol{\beta} +
\boldsymbol{\epsilon}\)</span>
<ul>
<li><span class="math inline">\(\mathbf{y}\)</span> is the <span
class="math inline">\(n \times 1\)</span> vector of outcomes.</li>
<li><span class="math inline">\(\mathbf{X}\)</span> is the <span
class="math inline">\(n \times (p+1)\)</span> matrix of predictors (with
a leading column of 1s for the intercept).</li>
<li><span class="math inline">\(\boldsymbol{\beta}\)</span> is the <span
class="math inline">\((p+1) \times 1\)</span> vector of coefficients
(<span class="math inline">\(\beta_0, \beta_1, ...,
\beta_p\)</span>).</li>
<li><span class="math inline">\(\boldsymbol{\epsilon}\)</span> is the
<span class="math inline">\(n \times 1\)</span> vector of irreducible
error.</li>
</ul></li>
<li><strong>Key Question:</strong> “If <span
class="math inline">\(\boldsymbol{\beta}\)</span> is sparse with at most
<span class="math inline">\(s\)</span> non-zero entries, can forward
selection find those variables?”
<ul>
<li><strong>Sparse</strong> means most coefficients are zero.</li>
<li><strong>Forward Selection</strong> is a <em>greedy algorithm</em>:
<ol type="1">
<li>Start with no variables.</li>
<li>Add the one variable that gives the best fit.</li>
<li>Add the <em>next</em> best variable to the existing model.</li>
<li>Repeat until you have a model with <span
class="math inline">\(s\)</span> variables.</li>
</ol></li>
<li>The slide suggests the answer is <strong>yes</strong>, but only
under certain conditions.</li>
</ul></li>
</ul>
<h3 id="the-condition-for-success">The Condition for Success</h3>
<ul>
<li><strong>Slide: “Orthogonal Matching Pursuit”</strong></li>
<li><strong>Key Concept:</strong> Forward selection can provably find
the correct variables if those variables are not strongly
correlated.</li>
<li><strong>Formula:</strong> This is formalized by the <strong>Mutual
Coherence Condition</strong>: <span class="math display">\[\mu = \max_{i
\neq j} |\langle \mathbf{x}_i, \mathbf{x}_j \rangle| &lt; \frac{1}{2s -
1}\]</span>
<ul>
<li><strong>What it means:</strong>
<ul>
<li><code>assuming $\mathbf&#123;x&#125;_i$'s are normalized</code> means we’ve
scaled them to have a length of 1.</li>
<li><span class="math inline">\(\langle \mathbf{x}_i, \mathbf{x}_j
\rangle\)</span> is the dot product, which is just their
<strong>correlation</strong> since they are normalized.</li>
<li><span class="math inline">\(\mu\)</span> (mu) is the <strong>largest
absolute correlation</strong> you can find between any two
<em>different</em> predictors.</li>
<li><span class="math inline">\(s\)</span> is the true number of
important variables.</li>
</ul></li>
<li><strong>In English:</strong> If the maximum correlation between any
of your predictors is less than this threshold, the greedy forward
selection algorithm is guaranteed to find the true, sparse set of
variables.</li>
</ul></li>
</ul>
<h3 id="how-to-choose-the-model-size-practice">How to Choose the Model
Size (Practice)</h3>
<p>The theory is nice, but in practice, you don’t know <span
class="math inline">\(s\)</span>. How many variables should you
pick?</p>
<ul>
<li><p><strong>Slide: “10-fold CV Errors”</strong></p></li>
<li><p><strong>This is the most important practical slide for this
section.</strong></p></li>
<li><p><strong>What the plot shows:</strong></p>
<ul>
<li><strong>X-axis:</strong> “Number of Variables” (from 1 to 10).</li>
<li><strong>Y-axis:</strong> “CV Error” (the 10-fold cross-validated
Mean Squared Error).</li>
<li><strong>The Curve:</strong> The error drops very fast as we add the
first 2-3 variables. Then, it flattens out. Adding more than 3 variables
doesn’t really help much.</li>
</ul></li>
<li><p><strong>Slide: “The one standard deviation
rule”</strong></p></li>
<li><p>This rule helps you pick the “best” model from the CV plot.</p>
<ol type="1">
<li>Find the model with the absolute <em>minimum</em> CV error (in the
plot, this looks to be around 6 or 7 variables).</li>
<li>Calculate the standard error of that minimum CV error.</li>
<li>Draw a “tolerance” line at
<code>(minimum error) + (one standard error)</code>.</li>
<li>Choose the <strong>simplest model</strong> (fewest variables) whose
CV error is <em>below</em> this tolerance line.</li>
</ol>
<!-- end list -->
<ul>
<li>The slide states this rule “gives the model with 3 variable” for
this example. This is because the 3-variable model is much simpler than
the 6-variable one, and its error is “good enough” (within one standard
deviation of the minimum). This is an application of <strong>Occam’s
razor</strong>.</li>
</ul></li>
</ul>
<h3 id="code-r-vs.-python">Code: R vs. Python</h3>
<p>The R code on the “10-fold CV Errors” slide generates that exact
plot.</p>
<ul>
<li><p><strong>R Code Explained:</strong></p>
<ul>
<li><code>library(boot)</code>: Loads the cross-validation library.</li>
<li><code>CV10.err=rep(0,10)</code>: Creates an empty vector to store
the 10 error scores.</li>
<li><code>for(p in 1:10)</code>: A loop that will test model sizes from
1 to 10.</li>
<li><code>x&lt;-which(summary(regfit.fwd)$which[p,])</code>: Gets the
<em>names</em> of the <span class="math inline">\(p\)</span> variables
chosen by a pre-run forward selection (<code>regfit.fwd</code>).</li>
<li><code>glm.fit=glm(Balance~.,data=newCred)</code>: Fits a model using
<em>only</em> those <span class="math inline">\(p\)</span>
variables.</li>
<li><code>cv.err=cv.glm(newCred,glm.fit,K=10)</code>: Performs 10-fold
CV on <em>that specific <span class="math inline">\(p\)</span>-variable
model</em>.</li>
<li><code>CV10.err[p]&lt;-cv.err$delta[1]</code>: Stores the CV
error.</li>
<li><code>plot(...)</code>: Plots the 10 errors against the 10 model
sizes.</li>
</ul></li>
<li><p><strong>Python Equivalent (Conceptual):</strong></p>
<ul>
<li>In <code>scikit-learn</code>, this process is often automated. You
wouldn’t write the CV loop yourself.</li>
<li>You would use <code>sklearn.feature_selection.RFECV</code>
(Recursive Feature Elimination with Cross-Validation). This tool
automatically wraps a model (like <code>LinearRegression</code>),
performs cross-validation, and finds the optimal number of features,
effectively producing the same plot and result.</li>
</ul></li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Python equivalent for 6.1 ---</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFECV</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="comment"># Assume X and y are your data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Create a pipeline</span></span><br><span class="line"><span class="comment"># (Note: It&#x27;s good practice to scale, even for OLS, if you&#x27;re comparing)</span></span><br><span class="line">pipeline = make_pipeline(</span><br><span class="line">    StandardScaler(),</span><br><span class="line">    LinearRegression()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Create the RFECV (Recursive Feature Elimination w/ CV) object</span></span><br><span class="line"><span class="comment"># This is an *alternative* to forward selection, but serves the same purpose</span></span><br><span class="line"><span class="comment"># It will test models with 1, 2, 3... features using 10-fold CV</span></span><br><span class="line">feature_selector = RFECV(</span><br><span class="line">    estimator=pipeline, </span><br><span class="line">    min_features_to_select=<span class="number">1</span>, </span><br><span class="line">    step=<span class="number">1</span>, </span><br><span class="line">    cv=<span class="number">10</span>, </span><br><span class="line">    scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span> <span class="comment"># We want to minimize error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Fit it</span></span><br><span class="line">feature_selector.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Optimal number of features found: <span class="subst">&#123;feature_selector.n_features_&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You could then plot feature_selector.cv_results_[&#x27;mean_test_score&#x27;]</span></span><br><span class="line"><span class="comment"># to replicate the R plot.</span></span><br></pre></td></tr></table></figure>
<h2 id="shrinkage-methods-by-regularization">Shrinkage Methods by
Regularization</h2>
<p>This is a different approach. Instead of <em>removing</em> variables,
we keep all <span class="math inline">\(p\)</span> variables but
<em>shrink</em> their coefficients <span
class="math inline">\(\beta_j\)</span> towards 0.</p>
<h3 id="ridge-regression-the-core-idea">Ridge Regression: The Core
Idea</h3>
<ul>
<li><strong>Slide: “Ridge regression”</strong></li>
<li><strong>Formula:</strong> Ridge regression minimizes a new objective
function: <span class="math display">\[\min_{\boldsymbol{\beta}} \left(
\sum_{i=1}^{n} (y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij})^2 +
\lambda \sum_{j=1}^{p} \beta_j^2 \right)\]</span>
<ul>
<li><strong>Term 1: <span class="math inline">\(\text{RSS}\)</span>
(Residual Sum of Squares).</strong> This is the original OLS “goodness
of fit” term. We want this to be small.</li>
<li><strong>Term 2: <span class="math inline">\(\lambda \sum
\beta_j^2\)</span>.</strong> This is the <strong><span
class="math inline">\(\ell_2\)</span> penalty</strong> or “shrinkage
penalty”. It adds a “cost” for having large coefficients.</li>
</ul></li>
<li><strong>The <span class="math inline">\(\lambda\)</span> (lambda)
Parameter:</strong>
<ul>
<li>This is the <strong>tuning parameter</strong> that controls the
trade-off between fit and simplicity.</li>
<li><code>$\lambda = 0$</code>: No penalty. The objective is just to
minimize RSS. The solution <span
class="math inline">\(\hat{\boldsymbol{\beta}}^R\)</span> is identical
to the OLS solution <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>.</li>
<li><code>$\lambda = \infty$</code>: Infinite penalty. The only way to
minimize the cost is to make all <span class="math inline">\(\beta_j =
0\)</span> (for <span class="math inline">\(j \ge 1\)</span>). The model
becomes an intercept-only model.</li>
<li><code>Large $\lambda$</code>: Heavy penalty, more shrinkage.</li>
<li><strong>Crucial Note:</strong> The intercept <span
class="math inline">\(\beta_0\)</span> is <strong>not
penalized</strong>. This is because <span
class="math inline">\(\beta_0\)</span> just represents the mean of <span
class="math inline">\(y\)</span> when all <span
class="math inline">\(x\)</span>’s are 0; shrinking it makes no
sense.</li>
</ul></li>
</ul>
<h3 id="the-need-for-standardization">The Need for Standardization</h3>
<ul>
<li><strong>Slide: “Standardize the inputs”</strong></li>
<li><strong>Problem:</strong> The penalty <span
class="math inline">\(\lambda \sum \beta_j^2\)</span> is applied to all
coefficients. But what if <span class="math inline">\(x_1\)</span> is
“house size in sq-ft” (values 1000-5000) and <span
class="math inline">\(x_2\)</span> is “number of bedrooms” (values 1-5)?
<ul>
<li>The coefficient <span class="math inline">\(\beta_1\)</span> for
house size will naturally be <em>tiny</em>, while the coefficient <span
class="math inline">\(\beta_2\)</span> for bedrooms will be
<em>large</em>, even if they are equally important.</li>
<li>Ridge regression would unfairly and heavily penalize <span
class="math inline">\(\beta_2\)</span> while barely touching <span
class="math inline">\(\beta_1\)</span>.</li>
</ul></li>
<li><strong>Solution:</strong> You <strong>must</strong> standardize all
predictors <em>before</em> fitting a Ridge model.</li>
<li><strong>Formula:</strong> For each observation <span
class="math inline">\(i\)</span> of each predictor <span
class="math inline">\(j\)</span>: <span
class="math display">\[\tilde{x}_{ij} = \frac{x_{ij} -
\bar{x}_j}{\sqrt{(1/n) \sum_{i=1}^{n} (x_{ij} - \bar{x}_j)^2}}\]</span>
<ul>
<li>This formula rescales every predictor to have a mean of 0 and a
standard deviation of 1.</li>
<li>Now, all coefficients <span class="math inline">\(\beta_j\)</span>
are on a “level playing field” and can be penalized fairly.</li>
</ul></li>
</ul>
<h3 id="answering-the-discussion-questions">Answering the Discussion
Questions</h3>
<ul>
<li><strong>Slide: “DISCUSSION”</strong>
<ul>
<li><code>What is the solution of Ridge regression?</code></li>
<li><code>What is the bias and the variance?</code></li>
</ul></li>
</ul>
<h4 id="what-is-the-solution-of-ridge-regression">1. What is the
solution of Ridge regression?</h4>
<p>The solution can be written in matrix form, which is very
elegant.</p>
<ul>
<li><p><strong>Standard OLS Solution:</strong> The coefficients <span
class="math inline">\(\hat{\boldsymbol{\beta}}^{\text{OLS}}\)</span>
that minimize RSS are found by: <span
class="math display">\[\hat{\boldsymbol{\beta}}^{\text{OLS}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p></li>
<li><p><strong>Ridge Regression Solution:</strong> The coefficients
<span class="math inline">\(\hat{\boldsymbol{\beta}}^{R}\)</span> that
minimize the Ridge objective are: <span
class="math display">\[\hat{\boldsymbol{\beta}}^{R} =
(\mathbf{X}^T\mathbf{X} + \lambda
\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><strong>Explanation:</strong>
<ul>
<li><span class="math inline">\(\mathbf{I}\)</span> is the
<strong>identity matrix</strong> (a matrix of 1s on the diagonal, 0s
everywhere else).</li>
<li>By adding <span class="math inline">\(\lambda\mathbf{I}\)</span>, we
are adding a positive value <span class="math inline">\(\lambda\)</span>
to the <em>diagonal</em> of the <span
class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> matrix.</li>
<li>This addition <strong>stabilizes</strong> the matrix. <span
class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> might not be
invertible (if <span class="math inline">\(p &gt; n\)</span> or if
predictors are perfectly collinear), but <span
class="math inline">\((\mathbf{X}^T\mathbf{X} + \lambda
\mathbf{I})\)</span> is <em>always</em> invertible for <span
class="math inline">\(\lambda &gt; 0\)</span>.</li>
<li>This addition is what mathematically “shrinks” the coefficients
toward zero.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="what-is-the-bias-and-the-variance">2. What is the bias and the
variance?</h4>
<p>This is the <strong>most important concept</strong> in
regularization. It’s the <strong>bias-variance trade-off</strong>.</p>
<ul>
<li><p><strong>Standard OLS (where <span
class="math inline">\(\lambda=0\)</span>):</strong></p>
<ul>
<li><strong>Bias: Low.</strong> The OLS estimator is
<strong>unbiased</strong>, meaning that if you took many samples and fit
many OLS models, their average <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> would be the
<em>true</em> <span
class="math inline">\(\boldsymbol{\beta}\)</span>.</li>
<li><strong>Variance: High.</strong> The OLS solution can be
<em>highly</em> sensitive to the training data. If you change a few data
points, the coefficients can swing wildly. This is especially true if
<span class="math inline">\(p\)</span> is large or predictors are
correlated. This “sensitivity” is high variance, which leads to
<strong>overfitting</strong>.</li>
</ul></li>
<li><p><strong>Ridge Regression (where <span
class="math inline">\(\lambda &gt; 0\)</span>):</strong></p>
<ul>
<li><strong>Bias: High(er).</strong> Ridge regression is a
<strong>biased</strong> estimator. By adding the penalty, we are
<em>purposefully</em> pulling the coefficients away from the OLS
solution and towards zero. The average <span
class="math inline">\(\hat{\boldsymbol{\beta}}^R\)</span> from many
samples will <em>not</em> equal the true <span
class="math inline">\(\boldsymbol{\beta}\)</span>. We have
<em>introduced</em> bias into our model.</li>
<li><strong>Variance: Low(er).</strong> In exchange for this bias, we
get a massive <em>reduction in variance</em>. The <span
class="math inline">\(\lambda\mathbf{I}\)</span> term stabilizes the
solution. The coefficients won’t change wildly even if the training data
changes. The model is more robust and less sensitive.</li>
</ul></li>
</ul>
<p><strong>The Trade-off:</strong> The total expected test error of a
model is: <span class="math inline">\(\text{Error} = \text{Bias}^2 +
\text{Variance} + \text{Irreducible Error}\)</span></p>
<p>By using Ridge regression, we <em>increase</em> the <span
class="math inline">\(\text{Bias}^2\)</span> term a little, but we
<em>decrease</em> the <span
class="math inline">\(\text{Variance}\)</span> term a lot. The goal is
to find a <span class="math inline">\(\lambda\)</span> where the
<em>total error</em> is minimized. Ridge regression reduces variance
<em>at the cost of</em> increased bias.</p>
<h3 id="python-equivalent-for-6.2">Python Equivalent for 6.2</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Python equivalent for 6.2 ---</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="comment"># Assume X and y are your data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Create a pipeline that AUTOMATICALLY</span></span><br><span class="line"><span class="comment">#    - Standardizes the data</span></span><br><span class="line"><span class="comment">#    - Fits a Ridge Regression model</span></span><br><span class="line"><span class="comment">#    - Uses Cross-Validation to find the BEST lambda (alpha in scikit-learn)</span></span><br><span class="line">alphas_to_test = [<span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">100.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># RidgeCV handles everything for us</span></span><br><span class="line">pipeline = make_pipeline(</span><br><span class="line">    StandardScaler(),</span><br><span class="line">    RidgeCV(alphas=alphas_to_test, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, cv=<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Fit the pipeline</span></span><br><span class="line">pipeline.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Get the results</span></span><br><span class="line">best_lambda = pipeline.named_steps[<span class="string">&#x27;ridgecv&#x27;</span>].alpha_</span><br><span class="line">ridge_coefficients = pipeline.named_steps[<span class="string">&#x27;ridgecv&#x27;</span>].coef_</span><br><span class="line">intercept = pipeline.named_steps[<span class="string">&#x27;ridgecv&#x27;</span>].intercept_</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best lambda (alpha) found by CV: <span class="subst">&#123;best_lambda&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Model intercept (beta_0): <span class="subst">&#123;intercept&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Model coefficients (beta_j): <span class="subst">&#123;ridge_coefficients&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="the-why-of-ridge-regression">6. The “Why” of Ridge
Regression</h1>
<h2 id="core-concepts-the-why-of-ridge-regression">Core Concepts: The
“Why” of Ridge Regression</h2>
<p>Your slides explain that ridge regression is a “shrinkage method”
designed to solve a major problem with standard Ordinary Least Squares
(OLS) regression: <strong>high variance</strong>.</p>
<h3 id="the-bias-variance-tradeoff-slide-3">The Bias-Variance Tradeoff
(Slide 3)</h3>
<p>This is the most important theoretical concept. In prediction, the
total error (Mean Squared Error, or MSE) of a model is composed of three
parts: <span class="math inline">\(\text{Error} = \text{Variance} +
\text{Bias}^2 + \text{Irreducible Error}\)</span></p>
<ul>
<li><strong>Ordinary Least Squares (OLS):</strong> Aims to be unbiased
(low bias). However, when you have many predictors (<span
class="math inline">\(p\)</span>), especially if they are correlated, or
if <span class="math inline">\(p\)</span> is large compared to the
number of samples <span class="math inline">\(n\)</span> (<span
class="math inline">\(p \approx n\)</span> or <span
class="math inline">\(p &gt; n\)</span>), the OLS model becomes highly
<em>unstable</em>. A small change in the training data can cause the
coefficients to change wildly. This is <strong>high variance</strong>.
(See Slide 6, “Remarks”).</li>
<li><strong>Ridge Regression:</strong> By adding a penalty, ridge
<em>intentionally</em> introduces a small amount of
<strong>bias</strong> (it pulls coefficients away from their “true” OLS
values). In return, it achieves a <em>massive</em> reduction in
<strong>variance</strong>.</li>
</ul>
<p>As <strong>Slide 3</strong> shows:</p>
<ul>
<li>The <strong>green line (Variance)</strong> starts very high for low
<span class="math inline">\(\lambda\)</span> (left side) and drops
quickly.</li>
<li>The <strong>black line (Squared Bias)</strong> starts at zero (for
OLS at <span class="math inline">\(\lambda=0\)</span>) and slowly
increases as <span class="math inline">\(\lambda\)</span> grows.</li>
<li>The <strong>purple line (Test MSE)</strong> is the sum of the two.
It’s U-shaped. The goal of ridge is to find the <span
class="math inline">\(\lambda\)</span> (marked by the ‘x’) at the
<em>bottom</em> of this “U,” which gives the lowest possible total
error.</li>
</ul>
<h3 id="why-is-it-called-ridge-the-3d-spatial-meaning-slide-5">Why Is It
Called “Ridge”? The 3D Spatial Meaning (Slide 5)</h3>
<p>This slide explains the problem of <strong>collinearity</strong> and
the origin of the name.</p>
<ul>
<li><strong>Left Plot (Least Squares):</strong> Imagine a model with two
correlated predictors, <span class="math inline">\(\beta_1\)</span> and
<span class="math inline">\(\beta_2\)</span>. The y-axis (SS1) is the
error (RSS). Because the predictors are correlated, there isn’t one
single “point” that is the minimum. Instead, there’s a long, flat
<em>valley</em> or <em>trough</em> (marked “unstable”). Many different
combinations of <span class="math inline">\(\beta_1\)</span> and <span
class="math inline">\(\beta_2\)</span> along this valley give a
similarly low error. The OLS solution is unstable because it can pick
<em>any</em> point in this flat-bottomed valley.</li>
<li><strong>Right Plot (Ridge):</strong> The ridge objective function
adds a penalty term: <span class="math inline">\(\lambda(\beta_1^2 +
\beta_2^2)\)</span>. This penalty term, by itself, is a perfect circular
bowl centered at (0,0). When you add this “bowl” to the OLS “valley,” it
<em>stabilizes</em> the function. It pulls the minimum towards (0,0) and
creates a single, stable, well-defined minimum.</li>
<li><strong>The “Ridge” Name:</strong> The penalty <span
class="math inline">\(\lambda\mathbf{I}\)</span> (from the matrix
formula) adds a “ridge” of values to the diagonal of the <span
class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> matrix, which
geometrically turns the unstable flat valley into a stable bowl.</li>
</ul>
<h2 id="mathematical-formulas">Mathematical Formulas</h2>
<p>The key difference between OLS and Ridge is the function they try to
minimize.</p>
<ol type="1">
<li><p><strong>OLS Objective Function:</strong> Minimize the Residual
Sum of Squares (RSS). <span class="math display">\[\text{RSS} =
\sum_{i=1}^{n} \left( y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij}
\right)^2\]</span></p></li>
<li><p><strong>Ridge Objective Function (Slide 6):</strong> Minimize the
RSS <em>plus</em> an L2 penalty term. <span
class="math display">\[\text{Minimize: } \left[ \sum_{i=1}^{n} \left(
y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij} \right)^2 \right] +
\lambda \sum_{j=1}^{p} \beta_j^2\]</span></p>
<ul>
<li><span class="math inline">\(\lambda\)</span> is the <strong>tuning
parameter</strong> controlling the penalty strength.</li>
<li><span class="math inline">\(\sum_{j=1}^{p} \beta_j^2\)</span> is the
<strong>L2-norm</strong> (squared) of the coefficients. It penalizes
large coefficients.</li>
</ul></li>
<li><p><strong>L2 Norm (Slide 1):</strong> The L2 norm of a vector <span
class="math inline">\(\mathbf{a}\)</span> is its standard Euclidean
length. The plot on Slide 1 uses this to show the <em>total
magnitude</em> of the ridge coefficients. <span
class="math display">\[\|\mathbf{a}\|_2 = \sqrt{\sum_{j=1}^p
a_j^2}\]</span></p></li>
<li><p><strong>Matrix Solution (Slide 6):</strong> This is the
“closed-form” solution for the ridge coefficients <span
class="math inline">\(\hat{\beta}^R\)</span>. <span
class="math display">\[\hat{\beta}^R = (\mathbf{X}^T\mathbf{X} +
\lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{I}\)</span> is the identity
matrix.</li>
<li>The term <span class="math inline">\(\lambda\mathbf{I}\)</span> is
what stabilizes the <span
class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> matrix, making it
invertible even if it’s singular (due to <span class="math inline">\(p
&gt; n\)</span> or collinearity).</li>
</ul></li>
</ol>
<h2 id="walkthrough-of-the-credit-data-example-all-slides">Walkthrough
of the “Credit Data” Example (All Slides)</h2>
<p>Here is the logical story of the R code, from start to finish.</p>
<h3 id="step-1-data-preparation-slide-8">Step 1: Data Preparation (Slide
8)</h3>
<ul>
<li><code>x=scale(model.matrix(Balance~., Credit)[,-1])</code>
<ul>
<li><code>model.matrix(...)</code> creates the predictor matrix
<code>x</code>.</li>
<li><code>scale(...)</code> is <strong>critically important</strong>. It
standardizes all predictors to have a mean of 0 and a standard deviation
of 1. This is necessary because the ridge penalty <span
class="math inline">\(\lambda \sum \beta_j^2\)</span> is
<em>unit-dependent</em>. If <code>Income</code> (in 10,000s) and
<code>Cards</code> (1-10) were unscaled, the penalty would unfairly
crush the <code>Income</code> coefficient. Scaling puts all predictors
on a level playing field.</li>
</ul></li>
<li><code>y=Credit$Balance</code>
<ul>
<li>This sets the <code>y</code> (target) variable.</li>
</ul></li>
</ul>
<h3 id="step-2-fit-the-ridge-model-slide-8">Step 2: Fit the Ridge Model
(Slide 8)</h3>
<ul>
<li><code>grid=10^seq(4,-2,length=100)</code>
<ul>
<li>This creates a <em>grid</em> of 100 <span
class="math inline">\(\lambda\)</span> values to test, ranging from
<span class="math inline">\(10^4\)</span> (a huge penalty) down to <span
class="math inline">\(10^{-2}\)</span> (a tiny penalty).</li>
</ul></li>
<li><code>ridge.mod=glmnet(x,y,alpha=0,lambda=grid)</code>
<ul>
<li>This is the main command. It fits a <em>separate</em> ridge model
for <em>every single <span class="math inline">\(\lambda\)</span></em>
in the <code>grid</code>.</li>
<li><code>alpha=0</code> is the specific command that tells
<code>glmnet</code> to perform <strong>Ridge Regression</strong>.
(Setting <code>alpha=1</code> would be LASSO).</li>
</ul></li>
<li><code>coef(ridge.mod)[,50]</code>
<ul>
<li>This inspects the model. It pulls out the vector of coefficients for
the 50th <span class="math inline">\(\lambda\)</span> in the grid (which
is <span class="math inline">\(\lambda=10.72\)</span>).</li>
</ul></li>
</ul>
<h3
id="step-3-visualize-the-coefficient-solution-path-slides-1-4-9">Step 3:
Visualize the Coefficient “Solution Path” (Slides 1, 4, 9)</h3>
<p>These plots all show the same thing: how the coefficients change as
<span class="math inline">\(\lambda\)</span> changes.</p>
<ul>
<li><strong>Slide 9 Plot:</strong> This plots the standardized
coefficients for 4 predictors (<code>Income</code>, <code>Limit</code>,
<code>Rating</code>, <code>Student</code>) against the <em>index</em> (1
to 100). Index 1 (left) is the largest <span
class="math inline">\(\lambda\)</span>, and index 100 (right) is the
smallest <span class="math inline">\(\lambda\)</span> (closest to OLS).
You can see the coefficients “grow” from 0 as the penalty (<span
class="math inline">\(\lambda\)</span>) gets smaller.</li>
<li><strong>Slide 1 (Left Plot):</strong> This is the <em>same plot</em>
as Slide 9, but more professional. It plots the coefficients against
<span class="math inline">\(\lambda\)</span> on a log scale. You can
clearly see all coefficients (gray lines) being “shrunk” toward zero as
<span class="math inline">\(\lambda\)</span> increases (moves right).
The key predictors (<code>Income</code>, <code>Rating</code>, etc.) are
highlighted.</li>
<li><strong>Slide 1 (Right Plot):</strong> This is the <em>exact same
data</em> again, but with a different x-axis: <span
class="math inline">\(\|\hat{\beta}_\lambda^R\|_2 /
\|\hat{\beta}\|_2\)</span>.
<ul>
<li><strong>1.0</strong> on the right means <span
class="math inline">\(\lambda=0\)</span>. The ratio of the ridge norm to
the OLS norm is 1 (they are the same).</li>
<li><strong>0.0</strong> on the left means <span
class="math inline">\(\lambda=\infty\)</span>. The ridge coefficients
are all 0, so their norm is 0.</li>
<li>This axis shows the “fraction” of the full OLS coefficient magnitude
that the model is using.</li>
</ul></li>
<li><strong>Slide 4 Plot:</strong> This plots the <em>total L2 norm</em>
of <em>all</em> coefficients (<span
class="math inline">\(\|\hat{\beta}_\lambda^R\|_2\)</span>) against the
index. As the index goes from 1 to 100 (i.e., <span
class="math inline">\(\lambda\)</span> gets smaller), the total
magnitude of the coefficients gets larger, which is exactly what we
expect.</li>
</ul>
<h3
id="step-4-find-the-best-lambda-using-cross-validation-slides-4-7">Step
4: Find the <em>Best</em> <span class="math inline">\(\lambda\)</span>
using Cross-Validation (Slides 4 &amp; 7)</h3>
<p>We have 100 models. Which one is best?</p>
<ul>
<li><p><strong>The “Manual” Way (Slide 4):</strong></p>
<ul>
<li>The code splits the data into a <code>train</code> and
<code>test</code> set.</li>
<li>It fits a model <em>only</em> on the <code>train</code> set.</li>
<li>It tests two <span class="math inline">\(\lambda\)</span> values:
<ul>
<li><code>s=4</code>: Gives a test MSE of <code>10293.33</code>.</li>
<li><code>s=10</code>: Gives a test MSE of <code>168981.1</code> (much
worse!).</li>
</ul></li>
<li>This shows that <span class="math inline">\(\lambda=4\)</span> is
better than <span class="math inline">\(\lambda=10\)</span>, but we
don’t know if it’s the <em>best</em>.</li>
</ul></li>
<li><p><strong>The “Automatic” Way (Slide 7):</strong></p>
<ul>
<li><code>cv.out=cv.glmnet(x[train,], y[train], alpha=0)</code></li>
<li>This runs <strong>10-fold Cross-Validation</strong> on the training
set. It automatically splits the training set into 10 “folds,” trains on
9, tests on 1, and repeats this 10 times for <em>every <span
class="math inline">\(\lambda\)</span></em>.</li>
<li><strong>The Plot:</strong> The plot on this slide is the result. It
shows the average MSE (y-axis) for each <span
class="math inline">\(\log(\lambda)\)</span> (x-axis). This is the
<em>real-data version</em> of the theoretical purple curve from Slide
3.</li>
<li><code>bestlam=cv.out$lambda.min</code></li>
<li>This command finds the <span class="math inline">\(\lambda\)</span>
at the <em>very bottom</em> of the U-shaped curve. The output shows
<code>bestlam</code> is <strong>41.6</strong>.</li>
<li><code>ridge.pred=predict(ridge.mod, s=bestlam, newx=x[test,])</code></li>
<li>Now, we use this <em>one best <span
class="math inline">\(\lambda\)</span></em> to make predictions on our
held-out <code>test</code> set.</li>
<li><code>mean((ridge.pred-y.test)^2)</code></li>
<li>The final, reliable test MSE is <strong>16129.68</strong>. This is
our best estimate of how the model will perform on new, unseen
data.</li>
</ul></li>
</ul>
<h2 id="python-scikit-learn-equivalents">Python
(<code>scikit-learn</code>) Equivalents</h2>
<p>Here is how you would perform the entire R workflow from your slides
in Python.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge, RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. Load and Prepare Data (like Slide 8) ---</span></span><br><span class="line"><span class="comment"># Assuming &#x27;Credit&#x27; is a pandas DataFrame</span></span><br><span class="line"><span class="comment"># X = Credit.drop(&#x27;Balance&#x27;, axis=1)</span></span><br><span class="line"><span class="comment"># y = Credit[&#x27;Balance&#x27;]</span></span><br><span class="line"><span class="comment"># ... (need to handle categorical variables first, e.g., with pd.get_dummies) ...</span></span><br><span class="line"><span class="comment"># For this example, let&#x27;s assume X and y are already loaded and numeric.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Standardize the predictors (CRITICAL)</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. Train/Test Split (like Slide 4) ---</span></span><br><span class="line"><span class="comment"># test_size=0.5 and random_state=1 mimic the R code</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X_scaled, y, test_size=<span class="number">0.5</span>, random_state=<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. Find Best Lambda (alpha) with Cross-Validation (like Slide 7) ---</span></span><br><span class="line"><span class="comment"># Create the same log-spaced grid of lambdas (sklearn calls it &#x27;alpha&#x27;)</span></span><br><span class="line">lambda_grid = np.logspace(<span class="number">4</span>, -<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RidgeCV performs cross-validation to find the best alpha</span></span><br><span class="line"><span class="comment"># cv=10 matches the 10-fold CV</span></span><br><span class="line"><span class="comment"># store_cv_values=True is needed to plot the CV error curve</span></span><br><span class="line">cv_model = RidgeCV(alphas=lambda_grid, store_cv_values=<span class="literal">True</span>, cv=<span class="number">10</span>)</span><br><span class="line">cv_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the best lambda found</span></span><br><span class="line">best_lambda = cv_model.alpha_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best lambda (alpha) found by CV: <span class="subst">&#123;best_lambda&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the CV error curve (like Slide 7 plot)</span></span><br><span class="line"><span class="comment"># cv_model.cv_values_ has shape (n_samples, n_alphas)</span></span><br><span class="line"><span class="comment"># We need to average over the samples for each alpha</span></span><br><span class="line">mse_path = np.mean(cv_model.cv_values_, axis=<span class="number">0</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.log10(cv_model.alphas_), mse_path, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Log(lambda)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Mean Squared Error&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Cross-Validation Error Path&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. Evaluate on Test Set (like Slide 7) ---</span></span><br><span class="line"><span class="comment"># &#x27;cv_model&#x27; is already refit on the full training set using the best_lambda</span></span><br><span class="line">test_pred = cv_model.predict(X_test)</span><br><span class="line">final_test_mse = mean_squared_error(y_test, test_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Final Test MSE with best lambda: <span class="subst">&#123;final_test_mse&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 5. Get Final Coefficients (like Slide 7, bottom) ---</span></span><br><span class="line"><span class="comment"># The coefficients from the CV-trained model:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Intercept: <span class="subst">&#123;cv_model.intercept_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Coefficients:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> coef, feature <span class="keyword">in</span> <span class="built_in">zip</span>(cv_model.coef_, X.columns):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;feature&#125;</span>: <span class="subst">&#123;coef&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 6. Plot the Solution Path (like Slide 1) ---</span></span><br><span class="line"><span class="comment"># To do this, we fit a Ridge model for each lambda and store the coefficients</span></span><br><span class="line">coefs = []</span><br><span class="line"><span class="keyword">for</span> lam <span class="keyword">in</span> lambda_grid:</span><br><span class="line">    model = Ridge(alpha=lam)</span><br><span class="line">    model.fit(X_scaled, y)  <span class="comment"># Fit on all data</span></span><br><span class="line">    coefs.append(model.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.log10(lambda_grid), coefs)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Log(lambda)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Standardized Coefficients&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Ridge Solution Path&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="shrinkage-methods-regularization-1">7. Shrinkage Methods
(Regularization)</h1>
<p>These slides cover <strong>Shrinkage Methods</strong>, also known as
<strong>Regularization</strong>, which are techniques used to improve on
the standard least squares model, particularly when dealing with many
variables or multicollinearity. The main focus is on
<strong>LASSO</strong> regression.</p>
<h2 id="key-mathematical-formulas">Key Mathematical Formulas</h2>
<p>The slides present two main, but equivalent, ways to formulate these
methods.</p>
<h3 id="penalized-formulation-slide-1">1. Penalized Formulation (Slide
1)</h3>
<p>This is the most common formulation. The goal is to minimize a
function that is a combination of the <strong>Residual Sum of Squares
(RSS)</strong> and a <strong>penalty term</strong>. The penalty
discourages large coefficients.</p>
<ul>
<li><strong>LASSO (Least Absolute Shrinkage and Selection
Operator):</strong> The goal is to find coefficients (<span
class="math inline">\(\beta_0, \beta_j\)</span>) that minimize: <span
class="math display">\[\sum_{i=1}^{n} (y_i - \beta_0 - \sum_{j=1}^{p}
\beta_j x_{ij})^2 + \lambda \sum_{j=1}^{p} |\beta_j|\]</span>
<ul>
<li><strong>Penalty:</strong> The <span
class="math inline">\(L_1\)</span> norm (<span
class="math inline">\(\|\beta\|_1\)</span>), which is the sum of the
<em>absolute values</em> of the coefficients.</li>
<li><strong>Key Property:</strong> This penalty can force some
coefficients to be <strong>exactly zero</strong>, effectively performing
automatic variable selection.</li>
</ul></li>
</ul>
<h3 id="constrained-formulation-slide-2">2. Constrained Formulation
(Slide 2)</h3>
<p>This alternative formulation minimizes the RSS <em>subject to a
constraint</em> (a “budget”) on the size of the coefficients.</p>
<ul>
<li><p><strong>For Lasso:</strong> Minimize RSS subject to: <span
class="math display">\[\sum_{j=1}^{p} |\beta_j| \le s\]</span> (The sum
of the absolute values of the coefficients must be less than some budget
<span class="math inline">\(s\)</span>.)</p></li>
<li><p><strong>For Ridge:</strong> Minimize RSS subject to: <span
class="math display">\[\sum_{j=1}^{p} \beta_j^2 \le s\]</span> (The sum
of the <em>squares</em> of the coefficients (<span
class="math inline">\(L_2\)</span> norm) must be less than <span
class="math inline">\(s\)</span>.)</p></li>
</ul>
<p><strong>Equivalence (Slide 3):</strong> For any penalty value <span
class="math inline">\(\lambda\)</span> used in the first formulation,
there is a corresponding budget <span class="math inline">\(s\)</span>
in the second formulation that will give the exact same set of
coefficients. <span class="math inline">\(\lambda\)</span> and <span
class="math inline">\(s\)</span> are inversely related: a large <span
class="math inline">\(\lambda\)</span> (high penalty) corresponds to a
small <span class="math inline">\(s\)</span> (small budget).</p>
<h2 id="important-plots-and-interpretation">Important Plots and
Interpretation</h2>
<p>Your slides show the two most important plots for understanding and
using LASSO.</p>
<h3 id="the-cross-validation-cv-plot-slide-5">1. The Cross-Validation
(CV) Plot (Slide 5)</h3>
<p>This plot is crucial for <strong>choosing the best tuning parameter
(<span class="math inline">\(\lambda\)</span>)</strong>.</p>
<ul>
<li><strong>X-axis:</strong> <span
class="math inline">\(\text{Log}(\lambda)\)</span>. This is the penalty
strength.
<ul>
<li><strong>Right side (high <span
class="math inline">\(\lambda\)</span>):</strong> High penalty, simple
model (many coefficients are 0), high bias, high Mean-Squared Error
(MSE).</li>
<li><strong>Left side (low <span
class="math inline">\(\lambda\)</span>):</strong> Low penalty, complex
model (like standard linear regression), high variance, MSE starts to
increase (overfitting).</li>
</ul></li>
<li><strong>Y-axis:</strong> Mean-Squared Error (MSE) from
cross-validation.</li>
<li><strong>Goal:</strong> Find the <span
class="math inline">\(\lambda\)</span> at the <strong>bottom of the “U”
shape</strong>, which gives the <em>lowest</em> MSE. This is the optimal
trade-off between bias and variance. The top axis shows how many
variables are included in the model at each <span
class="math inline">\(\lambda\)</span>.</li>
</ul>
<h3 id="the-coefficient-path-plot-slide-6">2. The Coefficient Path Plot
(Slide 6)</h3>
<p>This plot is the best visualization for <strong>understanding what
LASSO does</strong>.</p>
<ul>
<li><strong>Left Plot (vs. <span
class="math inline">\(\lambda\)</span>):</strong>
<ul>
<li><strong>X-axis:</strong> The penalty strength <span
class="math inline">\(\lambda\)</span>.</li>
<li><strong>Y-axis:</strong> The standardized value of each
coefficient.</li>
<li><strong>How to read it:</strong> Start from the
<strong>right</strong> (high <span
class="math inline">\(\lambda\)</span>). All coefficients are 0. As you
move <strong>left</strong>, <span class="math inline">\(\lambda\)</span>
<em>decreases</em>, and the penalty is relaxed. Variables “enter” the
model one by one (their coefficients become non-zero). You can see that
‘Rating’, ‘Income’, and ‘Student’ are the most important variables, as
they are the first to become non-zero.</li>
</ul></li>
<li><strong>Right Plot (vs. <span class="math inline">\(L_1\)</span>
Norm Ratio):</strong>
<ul>
<li>This shows the exact same information as the left plot, but the
x-axis is reversed and rescaled. An axis value of 0.0 means full penalty
(all <span class="math inline">\(\beta=0\)</span>), and 1.0 means no
penalty.</li>
</ul></li>
</ul>
<h2 id="code-understanding-r-to-python">Code Understanding (R to
Python)</h2>
<p>The slides use the <code>glmnet</code> package in R. The equivalent
and most popular library in Python is <strong>scikit-learn</strong>.</p>
<h3 id="finding-the-best-lambda-cv">1. Finding the Best <span
class="math inline">\(\lambda\)</span> (CV)</h3>
<p>The R code <code>cv.out=cv.glmnet(x[train,],y[train],alpha=1)</code>
performs cross-validation to find the best <span
class="math inline">\(\lambda\)</span>.</p>
<ul>
<li><strong>Python Equivalent:</strong> Use <code>LassoCV</code>. It
does the same thing: tests many <span
class="math inline">\(\lambda\)</span> values (called
<code>alphas</code> in scikit-learn) and picks the best one.</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LassoCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the LassoCV object</span></span><br><span class="line"><span class="comment"># cv=5 means 5-fold cross-validation</span></span><br><span class="line">lasso_cv = LassoCV(cv=<span class="number">5</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model to the training data</span></span><br><span class="line">lasso_cv.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the best lambda (called alpha_ in sklearn)</span></span><br><span class="line">best_lambda = lasso_cv.alpha_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best lambda (alpha): <span class="subst">&#123;best_lambda&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the MSEs</span></span><br><span class="line"><span class="comment"># This is what&#x27;s plotted in the CV plot</span></span><br><span class="line"><span class="built_in">print</span>(lasso_cv.mse_path_)</span><br></pre></td></tr></table></figure>
<h3 id="fitting-with-the-best-lambda-and-getting-coefficients">2.
Fitting with the Best <span class="math inline">\(\lambda\)</span> and
Getting Coefficients</h3>
<p>The R code
<code>lasso.coef=predict(out,type="coefficients",s=bestlam)</code> gets
the coefficients for the best <span
class="math inline">\(\lambda\)</span>.</p>
<ul>
<li><strong>Python Equivalent:</strong> The <code>LassoCV</code> object
is <em>already</em> refitted on the full training data using the best
<span class="math inline">\(\lambda\)</span>. You can also fit a new
<code>Lasso</code> model with that specific <span
class="math inline">\(\lambda\)</span>.</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Option 1: Use the already-fitted LassoCV object ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Coefficients from LassoCV:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lasso_cv.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions on the test set</span></span><br><span class="line">y_pred = lasso_cv.predict(X_test)</span><br><span class="line">test_mse = mean_squared_error(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Test MSE: <span class="subst">&#123;test_mse&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Option 2: Fit a new Lasso model with the best lambda ---</span></span><br><span class="line">final_lasso = Lasso(alpha=best_lambda)</span><br><span class="line">final_lasso.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get coefficients (Slide 7 shows this)</span></span><br><span class="line"><span class="comment"># Note how some are 0!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCoefficients from new Lasso model:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(final_lasso.coef_)</span><br></pre></td></tr></table></figure>
<h2 id="the-core-problem-two-equivalent-formulas">The Core Problem: Two
Equivalent Formulas</h2>
<p>The slides show two ways of writing the <em>same problem</em>.
Understanding this equivalence is key.</p>
<h3 id="formulation-1-the-penalized-method-slides-1-4">Formulation 1:
The Penalized Method (Slides 1 &amp; 4)</h3>
<ul>
<li><p><strong>Formula:</strong> <span
class="math display">\[\min_{\beta} \left( \sum_{i=1}^{n} (y_i -
\mathbf{x}_i^T \beta)^2 + \lambda \|\beta\|_1 \right)\]</span></p>
<ul>
<li><strong><span class="math inline">\(\sum (y_i - \mathbf{x}_i^T
\beta)^2\)</span></strong>: This is the normal <strong>Residual Sum of
Squares (RSS)</strong>. We want to make this small (fit the data
well).</li>
<li><strong><span class="math inline">\(\lambda
\|\beta\|_1\)</span></strong>: This is the <strong><span
class="math inline">\(L_1\)</span> penalty</strong>.
<ul>
<li><span class="math inline">\(\|\beta\|_1 = \sum_{j=1}^{p}
|\beta_j|\)</span> is the sum of the absolute values of the
coefficients.</li>
<li><span class="math inline">\(\lambda\)</span> (lambda) is a tuning
parameter. Think of it as a <strong>“penalty knob”</strong>.</li>
</ul></li>
</ul></li>
<li><p><strong>How to think about <span
class="math inline">\(\lambda\)</span></strong>:</p>
<ul>
<li><strong>If <span class="math inline">\(\lambda =
0\)</span>:</strong> There is no penalty. This is just standard Ordinary
Least Squares (OLS) regression. The model will likely overfit.</li>
<li><strong>If <span class="math inline">\(\lambda\)</span> is
<em>small</em>:</strong> There’s a small penalty. Coefficients will
shrink a <em>little</em> bit.</li>
<li><strong>If <span class="math inline">\(\lambda\)</span> is <em>very
large</em>:</strong> The penalty is severe. The <em>only</em> way to
make the penalty term small is to make the coefficients (<span
class="math inline">\(\beta\)</span>) themselves small. The model will
eventually shrink all coefficients to <strong>exactly 0</strong>.</li>
</ul></li>
</ul>
<h3 id="formulation-2-the-constrained-method-slides-2-3">Formulation 2:
The Constrained Method (Slides 2 &amp; 3)</h3>
<ul>
<li><p><strong>Formula:</strong> <span
class="math display">\[\min_{\beta} \sum_{i=1}^{n} (y_i - \mathbf{x}_i^T
\beta)^2 \quad \text{subject to} \quad \|\beta\|_1 \le
s\]</span></p></li>
<li><p><strong>How to think about <span
class="math inline">\(s\)</span></strong>:</p>
<ul>
<li>This says: “Find the best-fitting model (minimize RSS) <em>but</em>
you have a limited <strong>‘budget’ <span
class="math inline">\(s\)</span></strong> for the total size of your
coefficients.”</li>
<li><strong>If <span class="math inline">\(s\)</span> is <em>very
large</em>:</strong> The budget is huge. This constraint does nothing.
You get the standard OLS solution.</li>
<li><strong>If <span class="math inline">\(s\)</span> is
<em>small</em>:</strong> The budget is tight. You <em>must</em> shrink
your coefficients to stay under the budget <span
class="math inline">\(s\)</span>. To get the best fit, the model will be
forced to set unimportant coefficients to 0 and only “spend” its budget
on the most important variables.</li>
</ul></li>
</ul>
<p><strong>The Equivalence:</strong> These two forms are equivalent. For
any <span class="math inline">\(\lambda\)</span> you pick, there’s a
corresponding budget <span class="math inline">\(s\)</span> that gives
the <em>exact same solution</em>.</p>
<ul>
<li>High <span class="math inline">\(\lambda\)</span> (strong penalty)
<span class="math inline">\(\iff\)</span> Small <span
class="math inline">\(s\)</span> (tight budget)</li>
<li>Low <span class="math inline">\(\lambda\)</span> (weak penalty)
<span class="math inline">\(\iff\)</span> Large <span
class="math inline">\(s\)</span> (loose budget)</li>
</ul>
<p>This equivalence is why you see plots with both <span
class="math inline">\(\lambda\)</span> and <span
class="math inline">\(L_1\)</span> Norm on the x-axis. They are just two
different ways of looking at the same “penalty” spectrum.</p>
<h2 id="detailed-plot-code-analysis">Detailed Plot &amp; Code
Analysis</h2>
<p>Let’s look at the plots and code, which answer the practical
questions: <strong>(1)</strong> How do we pick the <em>best</em> <span
class="math inline">\(\lambda\)</span>? and <strong>(2)</strong> What
does LASSO <em>do</em> to the coefficients?</p>
<h3 id="question-1-how-to-pick-the-best-lambda-slide-5">Question 1: How
to pick the best <span class="math inline">\(\lambda\)</span>? (Slide
5)</h3>
<p>This is the <strong>Cross-Validation (CV) Plot</strong>. Its one and
only job is to help you find the optimal <span
class="math inline">\(\lambda\)</span>.</p>
<ul>
<li><strong>R Code:</strong>
<code>cv.out=cv.glmnet(x[train,],y[train],alpha=1)</code>
<ul>
<li><code>cv.glmnet</code>: This R function <em>automatically</em> does
K-fold cross-validation. <code>alpha=1</code> explicitly tells it to use
<strong>LASSO</strong> (alpha=0 would be Ridge).</li>
<li>It tries a whole range of <span
class="math inline">\(\lambda\)</span> values, calculates the
Mean-Squared Error (MSE) for each, and stores the results in
<code>cv.out</code>.</li>
</ul></li>
<li><strong>Plot Analysis:</strong>
<ul>
<li><strong>X-axis:</strong> <span
class="math inline">\(\text{Log}(\lambda)\)</span>. The penalty
strength. <strong>Right = High Penalty</strong> (simple model),
<strong>Left = Low Penalty</strong> (complex model).</li>
<li><strong>Y-axis:</strong> Mean-Squared Error (MSE). <strong>Lower is
better.</strong></li>
<li><strong>Red Dots:</strong> The average MSE for each <span
class="math inline">\(\lambda\)</span>.</li>
<li><strong>Gray Bars:</strong> The error bars (standard error).</li>
<li><strong>The “U” Shape:</strong> This is the classic
<strong>bias-variance trade-off</strong>.
<ul>
<li><strong>Right Side (High <span
class="math inline">\(\lambda\)</span>):</strong> The model is <em>too
simple</em> (too many coefficients are 0). It’s “underfitting.” The
error is high (high bias).</li>
<li><strong>Left Side (High <span
class="math inline">\(\lambda\)</span>):</strong> The model is <em>too
complex</em> (low penalty, like OLS). It’s “overfitting” the training
data. The error on new data is high (high variance).</li>
<li><strong>Bottom of the “U”:</strong> This is the “sweet spot.” The
<span class="math inline">\(\lambda\)</span> at the very bottom (marked
by the left vertical dotted line) gives the <strong>lowest possible
MSE</strong>. This is <code>lambda.min</code>.</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Answer:</strong> You pick the <span
class="math inline">\(\lambda\)</span> that corresponds to the lowest
point on this graph.</p>
<h3 id="question-2-what-does-lasso-do-slides-5-6-7">Question 2: What
does LASSO <em>do</em>? (Slides 5, 6, 7)</h3>
<p>These slides all show the <em>effect</em> of LASSO.</p>
<p><strong>A. The Coefficient Path Plots (Slides 5 &amp; 6)</strong></p>
<p>These plots visualize how coefficients change. They show the <em>same
information</em> just with different x-axes.</p>
<ul>
<li><strong>Left Plot (Slide 6) vs. <span
class="math inline">\(\lambda\)</span>:</strong>
<ul>
<li><strong>How to read:</strong> Read from <strong>RIGHT to
LEFT</strong>.</li>
<li>At the far right (<span class="math inline">\(\lambda\)</span> is
large), all coefficients are 0.</li>
<li>As you move left, <span class="math inline">\(\lambda\)</span> gets
smaller, and the penalty is relaxed. Variables “enter” the model one by
one as their coefficients become non-zero.</li>
<li>You can see ‘Rating’ (red-dashed), ‘Student’ (black-solid), and
‘Income’ (blue-dotted) are the first to enter, suggesting they are the
most important predictors.</li>
</ul></li>
<li><strong>Right Plot (Slide 6) vs. <span
class="math inline">\(L_1\)</span> Norm Ratio:</strong>
<ul>
<li>This is the <em>same plot</em>, just flipped and rescaled. The
x-axis is <span class="math inline">\(\|\hat{\beta}_\lambda\|_1 /
\|\hat{\beta}_{OLS}\|_1\)</span>.</li>
<li><strong>How to read:</strong> Read from <strong>LEFT to
RIGHT</strong>.</li>
<li><strong>At 0.0:</strong> This is a “0% budget” (like <span
class="math inline">\(s=0\)</span> or <span
class="math inline">\(\lambda=\infty\)</span>). All coefficients are
0.</li>
<li><strong>At 1.0:</strong> This is a “100% budget” (like <span
class="math inline">\(s=\infty\)</span> or <span
class="math inline">\(\lambda=0\)</span>). This is the full OLS
model.</li>
<li>This view clearly shows the coefficients “growing” from 0 as their
“budget” (<span class="math inline">\(L_1\)</span> Norm) increases.</li>
</ul></li>
</ul>
<p><strong>B. The Code Output (Slide 7) - This is the most important
“answer”</strong></p>
<p>This slide <em>explicitly demonstrates</em> variable selection by
comparing the coefficients from two different <span
class="math inline">\(\lambda\)</span> values.</p>
<ul>
<li><p><strong>First Block (The “Optimal” Model):</strong></p>
<ul>
<li><code>bestlam.cv &lt;- cv.out$lambda.min</code>: This gets the <span
class="math inline">\(\lambda\)</span> from the bottom of the “U” in the
CV plot.</li>
<li><code>lasso.conf &lt;- predict(out,type="coefficients",s=bestlam.cv)[1:12,]</code>:
This gets the coefficients using that <em>best</em> <span
class="math inline">\(\lambda\)</span>.</li>
<li><code>lasso.conf[lasso.conf!=0]</code>: This R command filters the
list to show <em>only the non-zero coefficients</em>.</li>
<li><strong>Result:</strong> The optimal model <em>still keeps 10
variables</em> (‘Income’, ‘Limit’, ‘Rating’, etc.). It has shrunk them,
but it hasn’t set many to 0.</li>
</ul></li>
<li><p><strong>Second Block (The “High Penalty” Model):</strong></p>
<ul>
<li>The slide text says “if we choose a larger regularization
parameter.” Here, they’ve picked an arbitrary <em>larger</em> value,
<code>s=10</code>. (Note: R’s <code>predict.glmnet</code> can be
confusing; <code>s=10</code> here means <span
class="math inline">\(\lambda=10\)</span>).</li>
<li><code>lasso.conf &lt;- predict(out,type="coefficients",s=10)[1:12,]</code>:
This gets the coefficients using a <em>stronger penalty</em> (<span
class="math inline">\(\lambda=10\)</span>).</li>
<li><code>lasso.conf[lasso.conf!=0]</code>: Again, show only the
non-zero coefficients.</li>
<li><strong>Result:</strong> Look! The list is much shorter. The
coefficients for ‘Age’, ‘Education’, ‘GenderFemale’, ‘MarriedYes’, and
‘Ethnicity’ are <em>all gone</em> (shrunk to 0.000000). The model has
decided these are not important enough to “spend” budget on.</li>
</ul></li>
</ul>
<p><strong>Conclusion:</strong> LASSO performs <strong>automatic
variable selection</strong>. By increasing <span
class="math inline">\(\lambda\)</span>, you create a
<strong>sparser</strong> (simpler) model. Slide 7 is the concrete
proof.</p>
<h2 id="python-equivalents-in-more-detail">Python Equivalents (in more
detail)</h2>
<p>Here is how you would replicate the <em>entire</em> workflow from the
slides in Python.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, LassoCV, lasso_path</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Assume X_train, y_train, X_test, y_test are loaded ---</span></span><br><span class="line"><span class="comment"># Example: </span></span><br><span class="line"><span class="comment"># data = pd.read_csv(&#x27;Credit.csv&#x27;)</span></span><br><span class="line"><span class="comment"># X = pd.get_dummies(data.drop([&#x27;ID&#x27;, &#x27;Balance&#x27;], axis=1), drop_first=True)</span></span><br><span class="line"><span class="comment"># y = data[&#x27;Balance&#x27;]</span></span><br><span class="line"><span class="comment"># X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It&#x27;s CRITICAL to scale data before regularization</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line">feature_names = X.columns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Replicate the CV Plot (Slide 5: ...000200.png)</span></span><br><span class="line"><span class="comment"># LassoCV does what cv.glmnet does: finds the best lambda (alpha)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Running LassoCV to find best lambda (alpha)...&quot;</span>)</span><br><span class="line"><span class="comment"># &#x27;alphas&#x27; is the list of lambdas to try. We can let it choose automatically.</span></span><br><span class="line"><span class="comment"># cv=10 means 10-fold cross-validation.</span></span><br><span class="line">lasso_cv = LassoCV(cv=<span class="number">10</span>, random_state=<span class="number">1</span>, max_iter=<span class="number">10000</span>)</span><br><span class="line">lasso_cv.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The best lambda found</span></span><br><span class="line">best_lambda = lasso_cv.alpha_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best lambda (alpha) found: <span class="subst">&#123;best_lambda&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Plotting the CV (MSE vs. Log(Lambda)) ---</span></span><br><span class="line"><span class="comment"># This recreates the R plot</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># lasso_cv.mse_path_ is a (n_alphas, n_folds) array of MSEs</span></span><br><span class="line"><span class="comment"># We take the mean across the folds (axis=1)</span></span><br><span class="line">mean_mses = np.mean(lasso_cv.mse_path_, axis=<span class="number">1</span>)</span><br><span class="line">log_lambdas = np.log10(lasso_cv.alphas_)</span><br><span class="line"></span><br><span class="line">plt.plot(log_lambdas, mean_mses, <span class="string">&#x27;r.-&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log(Lambda / Alpha)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Mean-Squared Error&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;LASSO Cross-Validation Path (Replicating R Plot)&#x27;</span>)</span><br><span class="line"><span class="comment"># Plot a vertical line at the best lambda</span></span><br><span class="line">plt.axvline(np.log10(best_lambda), linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;k&#x27;</span>, label=<span class="string">f&#x27;Best Lambda (alpha) = <span class="subst">&#123;best_lambda:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.gca().invert_xaxis() <span class="comment"># High lambda is on the right in R plot</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Replicate the Coefficient Path Plot (Slide 6: ...000206.png)</span></span><br><span class="line"><span class="comment"># We can use the lasso_path function, or just use the CV object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The lasso_cv object already calculated the paths!</span></span><br><span class="line">coefs = lasso_cv.path(X_train_scaled, y_train, alphas=lasso_cv.alphas_)[<span class="number">1</span>].T</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_train_scaled.shape[<span class="number">1</span>]):</span><br><span class="line">    plt.plot(log_lambdas, coefs[:, i], label=feature_names[i])</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log(Lambda / Alpha)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Standardized Coefficients&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;LASSO Coefficient Path (Replicating R Plot)&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.gca().invert_xaxis()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Replicate the Code Output (Slide 7: ...000202.png)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- Replicating R Output ---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- First Block: Coefficients with BEST lambda ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Coefficients using best lambda (alpha = <span class="subst">&#123;best_lambda:<span class="number">.4</span>f&#125;</span>):&quot;</span>)</span><br><span class="line"><span class="comment"># The lasso_cv object is already fitted with the best lambda</span></span><br><span class="line">best_coefs = lasso_cv.coef_</span><br><span class="line">coef_series_best = pd.Series(best_coefs, index=feature_names)</span><br><span class="line"><span class="comment"># This is like R&#x27;s `lasso.conf[lasso.conf != 0]`</span></span><br><span class="line"><span class="built_in">print</span>(coef_series_best[coef_series_best != <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Second Block: Coefficients with a LARGER lambda ---</span></span><br><span class="line"><span class="comment"># Let&#x27;s pick a larger lambda, e.g., 10 (like the slide)</span></span><br><span class="line">large_lambda = <span class="number">10</span> </span><br><span class="line">lasso_high_penalty = Lasso(alpha=large_lambda)</span><br><span class="line">lasso_high_penalty.fit(X_train_scaled, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nCoefficients using larger lambda (alpha = <span class="subst">&#123;large_lambda&#125;</span>):&quot;</span>)</span><br><span class="line">high_pen_coefs = lasso_high_penalty.coef_</span><br><span class="line">coef_series_high = pd.Series(high_pen_coefs, index=feature_names)</span><br><span class="line"><span class="comment"># This is the second R command: `lasso.conf[lasso.conf != 0]`</span></span><br><span class="line"><span class="built_in">print</span>(coef_series_high[coef_series_high != <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Final Prediction ---</span></span><br><span class="line"><span class="comment"># This is R&#x27;s `mean((lasso.pred-y.test)^2)`</span></span><br><span class="line">y_pred = lasso_cv.predict(X_test_scaled)</span><br><span class="line">test_mse = mean_squared_error(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nTest MSE using best lambda: <span class="subst">&#123;test_mse:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="the-game-of-regularization">The “Game” of Regularization</h3>
<p>First, let’s understand what these plots are showing. This is a “map”
of a constrained optimization problem.</p>
<ul>
<li><strong>The Red Ellipses (RSS Contours):</strong> Think of these as
contour lines on a topographic map.
<ul>
<li><strong>The Center (<span
class="math inline">\(\hat{\beta}\)</span>):</strong> This point is the
“bottom of the valley.” It represents the <em>perfect</em>,
unconstrained solution—the standard Ordinary Least Squares (OLS)
coefficients. This point has the lowest possible Residual Sum of Squares
(RSS), or error.</li>
<li><strong>The Lines:</strong> Every point on a single red ellipse has
the <em>exact same</em> RSS. As the ellipses get bigger (moving away
from the center <span class="math inline">\(\hat{\beta}\)</span>), the
error gets higher.</li>
</ul></li>
<li><strong>The Blue Shaded Area (Constraint Region):</strong> This is
the “rule” of the game.
<ul>
<li>This is our “budget.” We are <em>only allowed</em> to pick a
solution (<span class="math inline">\(\beta_1, \beta_2\)</span>) from
<em>inside or on the boundary</em> of this blue shape.</li>
<li><strong>LASSO:</strong> The constraint is <span
class="math inline">\(|\beta_1| + |\beta_2| \le s\)</span>. This
equation forms a <strong>diamond</strong> (or a rotated square).</li>
<li><strong>Ridge:</strong> The constraint is <span
class="math inline">\(\beta_1^2 + \beta_2^2 \le s\)</span>. This
equation forms a <strong>circle</strong>.</li>
</ul></li>
<li><strong>The Goal:</strong> Find the “best” point that is <em>inside
the blue area</em>.
<ul>
<li>The “best” point is the one with the lowest possible error
(RSS).</li>
<li>Geometrically, this means we start at the center (<span
class="math inline">\(\hat{\beta}\)</span>) and expand our ellipse
outward. The <em>very first point</em> where the ellipse
<strong>touches</strong> the blue constraint region is our
solution.</li>
</ul></li>
</ul>
<h3 id="why-lasso-performs-variable-selection-the-diamond">Why LASSO
Performs Variable Selection (The Diamond) 🎯</h3>
<p>This is the most important concept. Look at the LASSO diagrams.</p>
<ul>
<li><strong>The Shape:</strong> The LASSO constraint is a
<strong>diamond</strong>.</li>
<li><strong>The Key Feature:</strong> This diamond has <strong>sharp
corners</strong> (vertices). And most importantly, these corners lie
<strong>exactly on the axes</strong>.
<ul>
<li>The top corner is at <span class="math inline">\((\beta_1=0,
\beta_2=s)\)</span>.</li>
<li>The right corner is at <span class="math inline">\((\beta_1=s,
\beta_2=0)\)</span>.</li>
</ul></li>
<li><strong>The “Collision”:</strong> Now, imagine the red ellipses
(representing our error) expanding from the OLS solution (<span
class="math inline">\(\hat{\beta}\)</span>). They will almost always
“hit” the blue diamond at one of its <strong>sharp corners</strong>.
<ul>
<li>Look at your textbook diagram (slide <code>...000304.png</code>).
The ellipse clearly makes contact with the diamond at the top corner,
where <span class="math inline">\(\beta_1 = 0\)</span>.</li>
<li>Look at your example (slide <code>...000259.jpg</code>). The center
of the ellipses is at (4, 0.1). The closest point on the diamond that
the expanding ellipses will hit is the corner at (2, 0). At this
solution, <strong><span class="math inline">\(y\)</span> is exactly
0</strong>.</li>
</ul></li>
</ul>
<p><strong>Conclusion:</strong> Because the <span
class="math inline">\(L_1\)</span> “diamond” has corners on the axes,
the optimal solution is very likely to land on one of them. When it
does, the coefficient for the <em>other</em> axis is set to
<strong>exactly zero</strong>. This is the <strong>variable selection
property</strong>.</p>
<h3 id="why-ridge-regression-only-shrinks-the-circle">Why Ridge
Regression Only Shrinks (The Circle) 🤏</h3>
<p>Now, look at the Ridge regression diagram.</p>
<ul>
<li><strong>The Shape:</strong> The Ridge constraint is a
<strong>circle</strong>.</li>
<li><strong>The Key Feature:</strong> A circle is perfectly smooth and
has <strong>no corners</strong>.</li>
<li><strong>The “Collision”:</strong> Imagine the same ellipses
expanding and hitting the blue circle. The contact point will be a
<em>tangent</em> point.
<ul>
<li>Because the circle is round, this tangent point can be
<em>anywhere</em> on its circumference.</li>
<li>It is <em>extremely unlikely</em> that the contact point will be
exactly on an axis (e.g., at <span class="math inline">\((\beta_1=0,
\beta_2=s)\)</span>). This would only happen if the OLS solution <span
class="math inline">\(\hat{\beta}\)</span> was <em>already</em>
perfectly aligned with that axis.</li>
</ul></li>
<li><strong>Conclusion:</strong> The Ridge solution will find a point
where <em>both</em> <span class="math inline">\(\beta_1\)</span> and
<span class="math inline">\(\beta_2\)</span> are non-zero. The
coefficients are “shrunk” (pulled in from <span
class="math inline">\(\hat{\beta}\)</span> towards the origin), but they
<strong>never become zero</strong>. This is why Ridge is called a
“shrinkage” method, but not a “variable selection” method.</li>
</ul>
<h3 id="summary-diamond-vs.-circle">Summary: Diamond vs. Circle</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">LASSO (<span
class="math inline">\(L_1\)</span> Norm)</th>
<th style="text-align: left;">Ridge (<span
class="math inline">\(L_2\)</span> Norm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Constraint Shape</strong></td>
<td style="text-align: left;"><strong>Diamond</strong> (or
hyper-rhombus)</td>
<td style="text-align: left;"><strong>Circle</strong> (or
hypersphere)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Key Feature</strong></td>
<td style="text-align: left;"><strong>Sharp corners</strong> on the
axes</td>
<td style="text-align: left;"><strong>Smooth curve</strong> with no
corners</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Geometric Solution</strong></td>
<td style="text-align: left;">Ellipses hit the
<strong>corners</strong></td>
<td style="text-align: left;">Ellipses hit a <strong>smooth
part</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Result</strong></td>
<td style="text-align: left;">Forces some coefficients to
<strong>exactly 0</strong></td>
<td style="text-align: left;">Shrinks all coefficients <em>towards</em>
0</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Name</strong></td>
<td style="text-align: left;"><strong>Variable Selection</strong></td>
<td style="text-align: left;"><strong>Shrinkage</strong></td>
</tr>
</tbody>
</table>
<p>The “space meaning” is that the <strong>sharp corners of the <span
class="math inline">\(L_1\)</span> diamond are what make variable
selection possible</strong>. The smooth circle of the <span
class="math inline">\(L_2\)</span> norm does not have these corners and
thus cannot force coefficients to zero.</p>
<h1 id="shrinkage-methods-lasso-vs.-ridge">8. Shrinkage Methods (Lasso
vs. Ridge)</h1>
<h2 id="core-concept-shrinkage-methods">Core Concept: Shrinkage
Methods</h2>
<p>Both <strong>Ridge (L2)</strong> and <strong>Lasso (L1)</strong> are
regularization techniques used to improve upon standard <strong>Ordinary
Least Squares (OLS)</strong> regression.</p>
<p>Their main goal is to manage the <strong>bias-variance
tradeoff</strong>. OLS often has low bias but very high variance,
especially when you have many predictors (<span
class="math inline">\(p\)</span>) or when predictors are correlated.
Ridge and Lasso improve prediction accuracy by <em>shrinking</em> the
regression coefficients towards zero. This adds a small amount of bias
but significantly <em>reduces</em> the variance, leading to a lower
overall Test Mean Squared Error (MSE).</p>
<h2 id="the-key-difference-math-how-they-shrink">The Key Difference:
Math &amp; How They Shrink</h2>
<p>The slides show that the two methods use different penalties, which
leads to very different mathematical forms and practical outcomes.</p>
<ul>
<li><strong>Ridge Regression (L2 Penalty):</strong> Minimizes <span
class="math inline">\(RSS + \lambda \sum_{j=1}^{p}
\beta_j^2\)</span></li>
<li><strong>Lasso Regression (L1 Penalty):</strong> Minimizes <span
class="math inline">\(RSS + \lambda \sum_{j=1}^{p}
|\beta_j|\)</span></li>
</ul>
<p>Slide 80 provides the exact formulas for their coefficient estimates
in a simple, orthogonal case (where predictors are independent):</p>
<h3 id="ridge-regression-proportional-shrinkage">Ridge Regression
(Proportional Shrinkage)</h3>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(\hat{\beta}_j^R = \hat{\beta}_j^{LSE} / (1 +
\lambda)\)</span></li>
<li><strong>What this means:</strong> Ridge <em>shrinks</em> every least
squares coefficient by a proportional amount. It will make coefficients
<em>smaller</em>, but it will <strong>never set them to exactly
zero</strong> (unless <span class="math inline">\(\lambda\)</span> is
<span class="math inline">\(\infty\)</span>).</li>
</ul>
<h3 id="lasso-regression-soft-thresholding">Lasso Regression
(Soft-Thresholding)</h3>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(\hat{\beta}_j^L =
\text{sign}(\hat{\beta}_j^{LSE})(|\hat{\beta}_j^{LSE}| -
\lambda/2)_+\)</span></li>
<li><strong>What this means:</strong> This is a “soft-thresholding”
operator.
<ul>
<li>If the original coefficient <span
class="math inline">\(\hat{\beta}_j^{LSE}\)</span> is small (its
absolute value is less than <span
class="math inline">\(\lambda/2\)</span>), Lasso <strong>sets it to
exactly zero</strong>.</li>
<li>If the coefficient is large, Lasso subtracts <span
class="math inline">\(\lambda/2\)</span> from its absolute value,
shrinking it towards zero.</li>
</ul></li>
<li><strong>Key Property:</strong> Because of this, Lasso performs
<strong>automatic feature selection</strong> by eliminating
predictors.</li>
</ul>
<h2 id="important-images-explained">Important Images Explained</h2>
<h3 id="most-important-figure-6.10-slide-82">Most Important: Figure 6.10
(Slide 82)</h3>
<p>This is the best visual for understanding the <em>mathematical
difference</em> from the formulas above.</p>
<ul>
<li><strong>Left (Ridge):</strong> The red line shows the Ridge estimate
vs. the OLS estimate. It’s a straight, diagonal line with a slope less
than 1. It shrinks everything <em>proportionally</em>.</li>
<li><strong>Right (Lasso):</strong> The red line shows the Lasso
estimate. It’s “flat” at zero for a range, showing it <strong>sets small
coefficients to zero</strong>. Then, it slopes up, but it’s shifted (it
shrinks the large coefficients by a fixed amount).</li>
</ul>
<h3 id="scenario-1-figure-6.8-slide-76">Scenario 1: Figure 6.8 (Slide
76)</h3>
<p>This plot shows what happens when <strong>all 45 predictors are truly
related to the response</strong>.</p>
<ul>
<li><strong>Result (Slide 77):</strong> <strong>Ridge performs slightly
better</strong> (has a lower minimum MSE, shown by the dotted purple
line).</li>
<li><strong>Why:</strong> Lasso’s assumption (that some coefficients are
zero) is <em>wrong</em> in this case. By forcing some relevant
predictors to zero, it adds too much bias. Ridge, by just
<em>shrinking</em> all of them, finds a better balance.</li>
</ul>
<h3 id="scenario-2-figure-6.9-slide-78">Scenario 2: Figure 6.9 (Slide
78)</h3>
<p>This plot shows the <em>opposite</em> scenario: <strong>only 2 out of
45 predictors are truly related</strong> (a “sparse” model).</p>
<ul>
<li><strong>Result:</strong> <strong>Lasso performs much better</strong>
(its solid purple line has a much lower minimum MSE).</li>
<li><strong>Why:</strong> Lasso’s assumption is <em>correct</em>. It
successfully sets the 43 “noise” predictors to zero, which dramatically
reduces variance, while correctly keeping the 2 important ones.</li>
</ul>
<h2 id="python-code-understanding-1">Python &amp; Code
Understanding</h2>
<p>The slides don’t contain Python code, but they describe the exact
concepts you would use, primarily in <code>scikit-learn</code>.</p>
<ul>
<li><p><strong>Implementing Ridge &amp; Lasso:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge, Lasso, RidgeCV, LassoCV</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># It&#x27;s crucial to scale data before regularization</span></span><br><span class="line"><span class="comment"># alpha is the same as the λ (lambda) in your slides</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Ridge ---</span></span><br><span class="line"><span class="comment"># The math for Ridge is a &quot;closed-form solution&quot; (Slide 80)</span></span><br><span class="line"><span class="comment"># ridge_model = make_pipeline(StandardScaler(), Ridge(alpha=1.0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Lasso ---</span></span><br><span class="line"><span class="comment"># Lasso requires a numerical solver (like coordinate descent)</span></span><br><span class="line"><span class="comment"># lasso_model = make_pipeline(StandardScaler(), Lasso(alpha=0.1))</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>The Soft-Thresholding Formula:</strong> The math from
Slide 80, <span class="math inline">\(\text{sign}(y)(|y| -
\lambda/2)_+\)</span>, is the core operation in the “coordinate descent”
algorithm used to solve Lasso. You could write it in Python/Numpy:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">soft_threshold</span>(<span class="params">x, lambda_val</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Implements the Lasso soft-thresholding formula.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">return</span> np.sign(x) * np.maximum(<span class="number">0</span>, np.<span class="built_in">abs</span>(x) - (lambda_val / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment"># ols_coefficient = 1.5</span></span><br><span class="line"><span class="comment"># threshold = 4.0</span></span><br><span class="line"><span class="comment"># lasso_coefficient = soft_threshold(ols_coefficient, threshold) </span></span><br><span class="line"><span class="comment"># print(lasso_coefficient) # Output: 0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ols_coefficient = 3.0</span></span><br><span class="line"><span class="comment"># threshold = 4.0</span></span><br><span class="line"><span class="comment"># lasso_coefficient = soft_threshold(ols_coefficient, threshold) </span></span><br><span class="line"><span class="comment"># print(lasso_coefficient) # Output: 1.0 (it was 3.0, shrunk by 4/2 = 2)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Choosing <span class="math inline">\(\lambda\)</span>
(alpha):</strong> Slide 79 says to “Use cross validation to determine
which one has better prediction.” In <code>scikit-learn</code>, this is
done for you with <code>RidgeCV</code> and <code>LassoCV</code>, which
automatically test a range of <code>alpha</code> values.</p></li>
</ul>
<h2 id="summary-lasso-vs.-ridge">Summary: Lasso vs. Ridge</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Ridge (L2)</th>
<th style="text-align: left;">Lasso (L1)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Penalty</strong></td>
<td style="text-align: left;"><span class="math inline">\(L_2\)</span>
norm: <span class="math inline">\(\lambda \sum \beta_j^2\)</span></td>
<td style="text-align: left;"><span class="math inline">\(L_1\)</span>
norm: <span class="math inline">\(\lambda \sum |\beta_j|\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Coefficient
Shrinkage</strong></td>
<td style="text-align: left;">Proportional; shrinks all coefficients,
but never to <em>exactly</em> zero.</td>
<td style="text-align: left;">Soft-thresholding; can force coefficients
to be <em>exactly</em> zero.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Feature Selection?</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;"><strong>Yes</strong>, this is its main
advantage.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Interpretability</strong></td>
<td style="text-align: left;">Less interpretable (keeps all <span
class="math inline">\(p\)</span> variables).</td>
<td style="text-align: left;">More interpretable (produces a “sparse”
model with fewer variables).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Best Used When…</strong></td>
<td style="text-align: left;">…most predictors are useful. (e.g., Slide
76: 45/45 relevant).</td>
<td style="text-align: left;">…many predictors are “noise” and only a
few are strong. (e.g., Slide 78: 2/45 relevant).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Computation</strong></td>
<td style="text-align: left;">Has a simple, closed-form solution.</td>
<td style="text-align: left;">Requires numerical optimization (e.g.,
coordinate descent).</td>
</tr>
</tbody>
</table>
<h1 id="shrinkage-methods-ridge-lasso">9. Shrinkage Methods (Ridge &amp;
LASSO)</h1>
<h2 id="summary-of-shrinkage-methods-ridge-lasso">Summary of Shrinkage
Methods (Ridge &amp; LASSO)</h2>
<p>These slides introduce <strong>shrinkage methods</strong>, also known
as <strong>regularization</strong>, a technique used in regression (like
linear regression) to improve model performance. The main idea is to add
a <em>penalty</em> to the model’s loss function to “shrink” the size of
the coefficients. This helps to reduce model variance and prevent
overfitting, especially when you have many features.</p>
<p>The two main methods discussed are <strong>Ridge Regression</strong>
(<span class="math inline">\(L_2\)</span> penalty) and
<strong>LASSO</strong> (<span class="math inline">\(L_1\)</span>
penalty).</p>
<h2 id="key-mathematical-formulas-1">Key Mathematical Formulas</h2>
<ol type="1">
<li><p><strong>Standard Linear Model:</strong> The problem starts with
the standard linear regression model (from slide 1):</p>
<p><span class="math display">\[
\]</span>$$\mathbf{y} = \mathbf{X}\beta + \epsilon</p>
<p><span class="math display">\[
\]</span>$$ * <span class="math inline">\(\mathbf{y}\)</span> is the
<span class="math inline">\(n \times 1\)</span> vector of observed
outcomes.</p>
<ul>
<li><span class="math inline">\(\mathbf{X}\)</span> is the <span
class="math inline">\(n \times p\)</span> matrix of <span
class="math inline">\(p\)</span> predictor features for <span
class="math inline">\(n\)</span> observations.</li>
<li><span class="math inline">\(\beta\)</span> is the <span
class="math inline">\(p \times 1\)</span> vector of coefficients (what
we want to find).</li>
<li><span class="math inline">\(\epsilon\)</span> is the <span
class="math inline">\(n \times 1\)</span> vector of random errors.</li>
<li>The goal of standard “Ordinary Least Squares” (OLS) regression is to
find the <span class="math inline">\(\beta\)</span> that minimizes the
loss: <span class="math inline">\(\|\mathbf{X}\beta -
\mathbf{y}\|^2_2\)</span>.</li>
</ul></li>
<li><p><strong>LASSO (L1 Regularization):</strong> LASSO (Least Absolute
Shrinkage and Selection Operator) adds a penalty based on the
<em>absolute value</em> of the coefficients (the <span
class="math inline">\(L_1\)</span>-norm). This is the key formula from
slide 1:</p>
<p><span class="math display">\[
\]</span>$$\hat{\beta}(\lambda) \leftarrow \arg \min_{\beta} \left(
|\mathbf{X}\beta - \mathbf{y}|^2_2 + \lambda|\beta|_1 \right)</p>
<p><span class="math display">\[
\]</span>$$ * <span class="math inline">\(\|\beta\|_1 = \sum_{j=1}^{p}
|\beta_j|\)</span></p>
<ul>
<li><span class="math inline">\(\lambda\)</span> (lambda) is the
<strong>tuning parameter</strong> that controls the strength of the
penalty. A larger <span class="math inline">\(\lambda\)</span> means
more shrinkage.</li>
<li><strong>Key Property (Variable Selection):</strong> The <span
class="math inline">\(L_1\)</span> penalty can force some coefficients
(<span class="math inline">\(\beta_j\)</span>) to become <strong>exactly
zero</strong>. This means LASSO simultaneously performs <em>feature
selection</em> by automatically removing irrelevant predictors.</li>
<li><strong>Support (Slide 1):</strong> The question “Can it recover the
support of <span class="math inline">\(\beta\)</span>?” is asking if
LASSO can correctly identify the set of true non-zero coefficients
(defined as <span class="math inline">\(S := \{j : \beta_j \neq
0\}\)</span>).</li>
</ul></li>
<li><p><strong>Ridge Regression (L2 Regularization):</strong> Ridge
regression (mentioned on slide 2, shown on slide 3) adds a penalty based
on the <em>squared value</em> of the coefficients (the <span
class="math inline">\(L_2\)</span>-norm).</p>
<p><span class="math display">\[
\]</span>$$\hat{\beta}(\lambda) \leftarrow \arg \min_{\beta} \left(
|\mathbf{X}\beta - \mathbf{y}|^2_2 + \lambda|\beta|^2_2 \right)</p>
<p><span class="math display">\[
\]</span>$$ * <span class="math inline">\(\|\beta\|^2_2 = \sum_{j=1}^{p}
\beta_j^2\)</span></p>
<ul>
<li><strong>Key Property (Shrinkage):</strong> The <span
class="math inline">\(L_2\)</span> penalty <em>shrinks</em> coefficients
<em>towards</em> zero but <strong>never</strong> sets them to
<em>exactly</em> zero (unless <span class="math inline">\(\lambda =
\infty\)</span>). It is effective at handling multicollinearity.</li>
</ul></li>
</ol>
<h2 id="important-images-concepts">Important Images &amp; Concepts</h2>
<p>The most important images are the plots from slides 3 and 4. They
illustrate the two most critical concepts: <strong>how to choose <span
class="math inline">\(\lambda\)</span></strong> and <strong>what the
penalty does to the coefficients</strong>.</p>
<h3 id="tuning-parameter-selection-slides-3-4-left-plots">Tuning
Parameter Selection (Slides 3 &amp; 4, Left Plots)</h3>
<ul>
<li><strong>Problem:</strong> How do you find the <em>best</em> value
for <span class="math inline">\(\lambda\)</span>?</li>
<li><strong>Solution:</strong> <strong>Cross-Validation (CV)</strong>.
The slides show 10-fold CV.</li>
<li><strong>What the Plots Show:</strong> The left plots on slides 3 and
4 show the <strong>Cross-Validation Error</strong> (like MSE) for
different values of the penalty.
<ul>
<li>The x-axis represents the penalty strength (either <span
class="math inline">\(\lambda\)</span> itself or a related measure like
the shrinkage ratio <span
class="math inline">\(\|\hat{\beta}_\lambda\|_1 /
\|\hat{\beta}\|_1\)</span>).</li>
<li>The y-axis is the prediction error.</li>
<li>The curve is typically <strong>U-shaped</strong>. The vertical
dashed line marks the <strong>minimum</strong> of this curve. This
minimum point corresponds to the <strong>optimal <span
class="math inline">\(\lambda\)</span></strong>, which provides the best
balance between bias and variance, leading to the best-performing model
on unseen data.</li>
</ul></li>
</ul>
<h3 id="coefficient-paths-slides-3-4-right-plots">Coefficient Paths
(Slides 3 &amp; 4, Right Plots)</h3>
<p>These “trace” plots are crucial for understanding the difference
between Ridge and LASSO. They show how the value of each coefficient
(y-axis) changes as the penalty strength (x-axis) changes.</p>
<ul>
<li><strong>Slide 3 (Ridge):</strong> As <span
class="math inline">\(\lambda\)</span> increases (moving right), all
coefficient values are smoothly shrunk <em>towards</em> zero, but none
of them actually hit zero.</li>
<li><strong>Slide 4 (LASSO):</strong> As the penalty increases (moving
from right to left, as the ratio <span class="math inline">\(s\)</span>
goes from 1.0 to 0.0), you can see coefficients “drop off” and become
<strong>exactly zero</strong> one by one. The model with the optimal
<span class="math inline">\(\lambda\)</span> (vertical line) has
selected only a few non-zero coefficients (the pink and teal lines),
while all the grey lines have been set to zero. This is <em>feature
selection</em> in action.</li>
</ul>
<h2 id="key-discussion-points-slide-2">Key Discussion Points (Slide
2)</h2>
<ul>
<li><strong>Non-linear models:</strong> You can apply these methods to
non-linear models by first creating non-linear features (e.g., <span
class="math inline">\(x_1^2\)</span>, <span
class="math inline">\(x_2^2\)</span>, <span class="math inline">\(x_1
\cdot x_2\)</span>) and then feeding them into a LASSO or Ridge model.
The regularization will then select which of these linear <em>or</em>
non-linear terms are important.</li>
<li><strong>Correlated Features (Multicollinearity):</strong> The
question “If <span class="math inline">\(x_j \approx x_k\)</span>, how
does LASSO behave?” is a key weakness of LASSO.
<ul>
<li><strong>LASSO:</strong> Tends to <em>arbitrarily</em> select one of
the correlated features and set the others to zero. This can make the
model unstable.</li>
<li><strong>Ridge:</strong> Tends to shrink the coefficients of
correlated features <em>together</em>, giving them similar (but smaller)
values.</li>
<li><strong>Elastic Net</strong> (not shown) is a hybrid of Ridge and
LASSO that is often used to get the best of both worlds: it can select
groups of correlated variables.</li>
</ul></li>
</ul>
<h2 id="python-code-understanding-using-scikit-learn">Python Code
Understanding (using <code>scikit-learn</code>)</h2>
<p>Here is how you would implement these concepts in Python.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import necessary libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, Ridge, LassoCV, RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Assume you have your data ---</span></span><br><span class="line"><span class="comment"># X: your feature matrix (e.g., shape 100, 20)</span></span><br><span class="line"><span class="comment"># y: your target vector (e.g., shape 100,)</span></span><br><span class="line"><span class="comment"># X, y = ... load your data ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. It&#x27;s crucial to scale your data before regularization</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Find the optimal lambda (alpha) using Cross-Validation</span></span><br><span class="line"><span class="comment"># scikit-learn uses &#x27;alpha&#x27; instead of &#x27;lambda&#x27; for the tuning parameter.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- For LASSO ---</span></span><br><span class="line"><span class="comment"># LassoCV automatically performs cross-validation (e.g., cv=10)</span></span><br><span class="line"><span class="comment"># to find the best alpha.</span></span><br><span class="line">lasso_cv_model = LassoCV(cv=<span class="number">10</span>, random_state=<span class="number">0</span>)</span><br><span class="line">lasso_cv_model.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the best alpha (lambda)</span></span><br><span class="line">best_alpha_lasso = lasso_cv_model.alpha_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Optimal alpha (lambda) for LASSO: <span class="subst">&#123;best_alpha_lasso&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the final coefficients</span></span><br><span class="line">lasso_coeffs = lasso_cv_model.coef_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LASSO coefficients: <span class="subst">&#123;lasso_coeffs&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># You will see that many of these are exactly 0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- For Ridge ---</span></span><br><span class="line"><span class="comment"># RidgeCV works similarly. It&#x27;s often good to test alphas on a log scale.</span></span><br><span class="line">ridge_alphas = np.logspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">100</span>) <span class="comment"># 100 values from 0.001 to 1000</span></span><br><span class="line">ridge_cv_model = RidgeCV(alphas=ridge_alphas, store_cv_values=<span class="literal">True</span>)</span><br><span class="line">ridge_cv_model.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the best alpha (lambda)</span></span><br><span class="line">best_alpha_ridge = ridge_cv_model.alpha_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Optimal alpha (lambda) for Ridge: <span class="subst">&#123;best_alpha_ridge&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the final coefficients</span></span><br><span class="line">ridge_coeffs = ridge_cv_model.coef_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ridge coefficients: <span class="subst">&#123;ridge_coeffs&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># You will see these are small, but not exactly zero.</span></span><br></pre></td></tr></table></figure>
<h2 id="bias-variance-tradeoff">Bias-variance tradeoff</h2>
<h2 id="key-mathematical-formulas-concepts">Key Mathematical Formulas
&amp; Concepts</h2>
<h3 id="lasso-sign-consistency">LASSO: Sign Consistency</h3>
<p>This is the “ideal” scenario for LASSO. Sign consistency means that,
with enough data, the LASSO model not only selects the <em>correct</em>
set of features (it recovers the “support” <span
class="math inline">\(S\)</span>) but also correctly identifies the
<em>sign</em> (positive or negative) of their coefficients.</p>
<ul>
<li><p><strong>The Goal (Slide 1):</strong></p>
<p><span class="math display">\[
\]</span>$$\text{sign}(\hat{\beta}(\lambda)) = \text{sign}(\beta)</p>
<p><span class="math display">\[
\]</span>$$This means the signs of our <em>estimated</em> coefficients
<span class="math inline">\(\hat{\beta}(\lambda)\)</span> match the
signs of the <em>true</em> underlying coefficients <span
class="math inline">\(\beta\)</span>.</p></li>
<li><p><strong>The “Irrepresentable Condition” (Slide 1):</strong> This
is the mathematical guarantee required for LASSO to achieve sign
consistency.</p>
<p><span class="math display">\[
\]</span>$$|\mathbf{X}_{S<sup>c}</sup>\top \mathbf{X}_S
(\mathbf{X}_S^\top \mathbf{X}<em>S)^{-1}
\text{sign}(\beta_S)|</em>\infty &lt; 1</p>
<p><span class="math display">\[
\]</span>$$ * <strong>Plain English:</strong> This formula is a complex
way of saying: <strong>The irrelevant features (<span
class="math inline">\(\mathbf{X}_{S^c}\)</span>) cannot be too strongly
correlated with the true, relevant features (<span
class="math inline">\(\mathbf{X}_S\)</span>).</strong></p>
<ul>
<li>If an irrelevant feature is very similar (highly correlated) to a
true feature, LASSO can get “confused” and might pick the wrong one, or
its estimate will be unstable. This condition fails.</li>
</ul></li>
</ul>
<h3 id="ridge-regression-the-bias-variance-tradeoff">Ridge Regression:
The Bias-Variance Tradeoff</h3>
<ul>
<li><p><strong>The Formula (Slide 3):</strong></p>
<p><span class="math display">\[
\]</span>$$\hat{\beta}<em>{\text{ridge}}(\lambda) \leftarrow \arg
\min</em>{\beta} \left( |\mathbf{y} - \mathbf{X}\beta|^2 +
\lambda|\beta|^2 \right)</p>
<p><span class="math display">\[
\]</span>$$<em>(Note: This is the <span
class="math inline">\(L_2\)</span> penalty, so <span
class="math inline">\(\|\beta\|^2 = \sum
\beta_j^2\)</span>)</em></p></li>
<li><p><strong>The Problem it Solves: Collinearity (Slide 2)</strong>
When features are strongly correlated (e.g., <span
class="math inline">\(x_i \approx x_j\)</span>), regular methods
fail:</p>
<ul>
<li><strong>LSE (OLS):</strong> Fails because the matrix <span
class="math inline">\(\mathbf{X}^\top \mathbf{X}\)</span> is
“non-invertible” (or singular), so the math for the solution <span
class="math inline">\(\hat{\beta} = (\mathbf{X}^\top
\mathbf{X})^{-1}\mathbf{X}^\top\mathbf{y}\)</span> breaks down.</li>
<li><strong>LASSO:</strong> Fails because the <strong>Irrepresentable
Condition</strong> is violated. LASSO will tend to <em>arbitrarily</em>
pick one of the correlated features and set the others to zero.</li>
</ul></li>
<li><p><strong>The Ridge Solution (Slide 3):</strong></p>
<ol type="1">
<li><strong>Always has a solution:</strong> Adding the <span
class="math inline">\(\lambda\)</span> penalty makes the matrix math
work, even if <span class="math inline">\(\mathbf{X}^\top
\mathbf{X}\)</span> is non-invertible.</li>
<li><strong>Groups variables:</strong> This is the key takeaway. Instead
of arbitrarily picking one feature, <strong>Ridge tends to shrink the
coefficients of collinear variables <em>together</em></strong>.</li>
<li><strong>Bias-Variance Tradeoff:</strong> Ridge <em>introduces
bias</em> into the estimates (they are “wrong” on purpose) to
<em>massively reduce variance</em> (they are more stable and less
sensitive to the specific training data). This trade-off usually leads
to a much lower overall error (Mean Squared Error).</li>
</ol></li>
</ul>
<h2 id="important-images-key-takeaways">Important Images &amp; Key
Takeaways</h2>
<ol type="1">
<li><p><strong>Slide 2 (Collinearity Failures):</strong> This is the
most important “problem” slide. It clearly explains <em>why</em> you
can’t always use standard LSE or LASSO. The fact that all three methods
(LSE, LASSO, Forward Selection) fail with strong collinearity motivates
the need for Ridge.</p></li>
<li><p><strong>Slide 3 (Ridge Properties):</strong> This is the most
important “solution” slide. The two most critical points are:</p>
<ul>
<li><code>Always unique solution for λ &gt; 0</code></li>
<li><code>Collinear variables tend to be grouped!</code> (This is the
“fix” for the problem on Slide 2).</li>
</ul></li>
</ol>
<h2 id="python-code-understanding-2">Python Code Understanding</h2>
<p>Let’s demonstrate the <strong>key difference</strong> (Slide 3) in
how LASSO and Ridge handle collinear features.</p>
<p>We will create two features, <code>x1</code> and <code>x2</code>,
that are nearly identical.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, Ridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Create a dataset with 2 strongly correlated features</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">n_samples = <span class="number">100</span></span><br><span class="line"><span class="comment"># x1: a standard feature</span></span><br><span class="line">x1 = np.random.randn(n_samples)</span><br><span class="line"><span class="comment"># x2: almost identical to x1</span></span><br><span class="line">x2 = x1 + <span class="number">0.01</span> * np.random.randn(n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Combine into our feature matrix X</span></span><br><span class="line">X = np.c_[x1, x2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># y: The target variable (let&#x27;s say y = 2*x1 + 2*x2)</span></span><br><span class="line">y = <span class="number">2</span> * x1 + <span class="number">2</span> * x2 + np.random.randn(n_samples)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Fit LASSO (alpha is the same as lambda)</span></span><br><span class="line"><span class="comment"># We use a moderate alpha</span></span><br><span class="line">lasso_model = Lasso(alpha=<span class="number">1.0</span>)</span><br><span class="line">lasso_model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Fit Ridge (alpha is the same as lambda)</span></span><br><span class="line">ridge_model = Ridge(alpha=<span class="number">1.0</span>)</span><br><span class="line">ridge_model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Compare the coefficients</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- Results for Correlated Features ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;True Coefficients: [2.0, 2.0]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LASSO Coefficients: <span class="subst">&#123;np.<span class="built_in">round</span>(lasso_model.coef_, <span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ridge Coefficients: <span class="subst">&#123;np.<span class="built_in">round</span>(ridge_model.coef_, <span class="number">2</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="example-output">Example Output:</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- Results for Correlated Features ---</span><br><span class="line">True Coefficients: [2.0, 2.0]</span><br><span class="line">LASSO Coefficients: [3.89 0.  ]</span><br><span class="line">Ridge Coefficients: [1.95 1.94]</span><br></pre></td></tr></table></figure>
<h3 id="code-explanation">Code Explanation:</h3>
<ul>
<li><strong>LASSO:</strong> As predicted by the slides, LASSO failed to
find the true model. It <em>arbitrarily</em> picked <code>x1</code>,
gave it a large coefficient, and <strong>set <code>x2</code> to
zero</strong>. This is unstable and not what we wanted.</li>
<li><strong>Ridge:</strong> As predicted by Slide 3, Ridge handled the
collinearity perfectly. It identified that both <code>x1</code> and
<code>x2</code> were important and <strong>“grouped” them</strong> by
assigning them nearly identical, stable coefficients (1.95 and 1.94),
which are very close to the true values of 2.0.</li>
</ul>
<h1 id="elastic-net">10. Elastic Net</h1>
<h2 id="overall-summary">Overall Summary</h2>
<p>These slides introduce <strong>Elastic Net</strong>, a modern
regression method that solves the major weaknesses of its two
predecessors, <strong>Ridge</strong> and <strong>LASSO</strong>
regression.</p>
<ul>
<li><strong>Ridge</strong> is good for <strong>collinearity</strong>
(correlated features) but can’t do <strong>variable selection</strong>
(it can’t set any feature’s coefficient to <em>exactly</em> zero).</li>
<li><strong>LASSO</strong> is good for <strong>variable
selection</strong> (it creates <em>sparse</em> models by setting
coefficients to zero) but behaves <strong>unstably</strong> when
features are correlated (it tends to randomly pick one and discard the
others).</li>
</ul>
<p><strong>Elastic Net</strong> combines the L1 penalty of LASSO and the
L2 penalty of Ridge. The result is a single, flexible model that:</p>
<ol type="1">
<li>Performs <strong>variable selection</strong> (like LASSO).</li>
<li>Handles <strong>correlated features</strong> stably by grouping them
together (like Ridge).</li>
<li>Can select more features than samples (<span class="math inline">\(p
&gt; n\)</span>), which LASSO cannot do.</li>
</ol>
<h3 id="slide-1-the-definition-and-formula-file-...020245.png">Slide 1:
The Definition and Formula (File: <code>...020245.png</code>)</h3>
<p>This slide explains <em>why</em> Elastic Net was created and defines
it <em>mathematically</em>.</p>
<ul>
<li><strong>The Problem:</strong> It states the exact trade-off:
<ul>
<li>“Ridge regression can handle collinearity, but cannot perform
variable selection;”</li>
<li>“LASSO can perform variable selection, but performs poorly when
collinearity;”</li>
</ul></li>
<li><strong>The Solution (The Formula):</strong> The core of the method
is this optimization formula: <span
class="math display">\[\hat{\beta}_{eNet}(\lambda, \alpha) \leftarrow
\arg \min_{\beta} \left( \underbrace{\|\mathbf{y} -
\mathbf{X}\beta\|^2}_{\text{Loss}} + \lambda \left(
\underbrace{\alpha\|\beta\|_1}_{\text{L1 Penalty}} +
\underbrace{\frac{1-\alpha}{2}\|\beta\|_2^2}_{\text{L2 Penalty}} \right)
\right)\]</span></li>
<li><strong>Breaking Down the Formula:</strong>
<ul>
<li><strong><span class="math inline">\(\|\mathbf{y} -
\mathbf{X}\beta\|^2\)</span></strong>: This is the standard “Residual
Sum of Squares” (RSS). We want to find coefficients (<span
class="math inline">\(\beta\)</span>) that make the model’s predictions
(<span class="math inline">\(X\beta\)</span>) as close as possible to
the true values (<span class="math inline">\(y\)</span>).</li>
<li><strong><span class="math inline">\(\lambda\)</span>
(Lambda)</strong>: This is the <strong>master knob</strong> for
<em>total regularization strength</em>. A larger <span
class="math inline">\(\lambda\)</span> means a bigger penalty, which
“shrinks” all coefficients more.</li>
<li><strong><span class="math inline">\(\alpha\)</span>
(Alpha)</strong>: This is the <strong>mixing parameter</strong> that
balances L1 and L2. This is the key innovation.
<ul>
<li><strong><span
class="math inline">\(\alpha\|\beta\|_1\)</span></strong>: This is the
<strong>L1 (LASSO)</strong> part. It forces weak coefficients to become
exactly zero, thus selecting variables.</li>
<li><strong><span
class="math inline">\(\frac{1-\alpha}{2}\|\beta\|_2^2\)</span></strong>:
This is the <strong>L2 (Ridge)</strong> part. It shrinks all
coefficients and, crucially, encourages correlated features to have
similar coefficients (the grouping effect).</li>
</ul></li>
</ul></li>
<li><strong>The Special Cases:</strong>
<ul>
<li>If <strong><span class="math inline">\(\alpha = 0\)</span></strong>,
the L1 term vanishes, and the model becomes pure <strong>Ridge
Regression</strong>.</li>
<li>If <strong><span class="math inline">\(\alpha = 1\)</span></strong>,
the L2 term vanishes, and the model becomes pure <strong>LASSO
Regression</strong>.</li>
<li>If <strong><span class="math inline">\(0 &lt; \alpha &lt;
1\)</span></strong>, you get <strong>Elastic Net</strong>, which
“encourages grouping of correlated variables” <em>and</em> “can perform
variable selection.”</li>
</ul></li>
</ul>
<h3
id="slide-2-the-intuition-and-the-grouping-effect-file-...020249.jpg">Slide
2: The Intuition and The Grouping Effect (File:
<code>...020249.jpg</code>)</h3>
<p>This slide gives you the <em>visual intuition</em> and the
<em>practical proof</em> of why Elastic Net works. It has two parts.</p>
<h4 id="part-1-the-three-graphs-geometric-intuition">Part 1: The Three
Graphs (Geometric Intuition)</h4>
<p>These graphs show the <em>constraint region</em> (the shaded shape)
for each penalty. The model tries to find the best coefficients (<span
class="math inline">\(\theta_{opt}\)</span>), and the final solution
(the green dot) is the first point where the cost function (the blue
ellipses) “touches” the constraint region.</p>
<ul>
<li><strong>L1 Norm (LASSO):</strong> The region is a
<strong>diamond</strong>. Because of its <strong>sharp corners</strong>,
the ellipses are very likely to hit a corner first. At a corner, one of
the coefficients (e.g., <span class="math inline">\(\theta_1\)</span>)
is zero. This is a visual explanation of how LASSO creates
<strong>sparsity</strong> (variable selection).</li>
<li><strong>L2 Norm (Ridge):</strong> The region is a
<strong>circle</strong>. It has <strong>no corners</strong>. The
ellipses will hit a “smooth” point on the circle, shrinking both
coefficients (<span class="math inline">\(\theta_1\)</span> and <span
class="math inline">\(\theta_2\)</span>) but not setting either to zero.
This is <strong>weight sharing</strong>.</li>
<li><strong>L1 + L2 (Elastic Net):</strong> The region is a
<strong>“rounded square”</strong>. It’s the perfect compromise.
<ul>
<li>It has “corners” (like LASSO) so it can still set coefficients to
zero.</li>
<li>It has “curved edges” (like Ridge) so it’s more stable and handles
correlated variables by finding a solution on an edge rather than a
single sharp corner.</li>
</ul></li>
</ul>
<h4 id="part-2-the-formula-the-grouping-effect">Part 2: The Formula (The
Grouping Effect)</h4>
<p>The text at the bottom explains Elastic Net’s “grouping effect.”</p>
<ul>
<li><strong>The Implication:</strong> “If <span
class="math inline">\(x_j \approx x_k\)</span>, then <span
class="math inline">\(\hat{\beta}_j \approx
\hat{\beta}_k\)</span>.”</li>
<li><strong>Meaning:</strong> If two features (<span
class="math inline">\(x_j\)</span> and <span
class="math inline">\(x_k\)</span>) are highly correlated (their values
are very similar), Elastic Net will force their <em>coefficients</em>
(<span class="math inline">\(\hat{\beta}_j\)</span> and <span
class="math inline">\(\hat{\beta}_k\)</span>) to also be very
similar.</li>
<li><strong>Why this is good:</strong> This is the <em>opposite</em> of
LASSO. LASSO would be unstable and might arbitrarily set <span
class="math inline">\(\hat{\beta}_j\)</span> to a large value and <span
class="math inline">\(\hat{\beta}_k\)</span> to zero. Elastic Net
“groups” them: it will either keep <em>both</em> in the model with
similar importance, or it will shrink <em>both</em> of them out of the
model together. This is a much more stable and realistic result.</li>
<li><strong>The Warning:</strong> “LASSO may be unstable in this case!”
This directly highlights the problem that Elastic Net solves.</li>
</ul>
<h3 id="slide-3-the-feature-comparison-table-file-...020255.png">Slide
3: The Feature Comparison Table (File: <code>...020255.png</code>)</h3>
<p>This table is your “cheat sheet” for choosing the right model. It
compares Ridge, LASSO, and Elastic Net on all their key properties.</p>
<ul>
<li><strong>Penalty:</strong> Shows the L2, L1, and combined
penalties.</li>
<li><strong>Sparsity:</strong> Can the model set coefficients to 0?
<ul>
<li>Ridge: <strong>No ❌</strong></li>
<li>LASSO: <strong>Yes ✅</strong></li>
<li>Elastic Net: <strong>Yes ✅</strong></li>
</ul></li>
<li><strong>Variable Selection:</strong> This is a <em>crucial</em> row.
<ul>
<li>LASSO: <strong>Yes ✅</strong>, BUT it has a major limitation: if
you have more features than samples (<span class="math inline">\(p &gt;
n\)</span>), LASSO can select <em>at most</em> <span
class="math inline">\(n\)</span> features.</li>
<li>Elastic Net: <strong>Yes ✅</strong>, and it <strong>can select more
than <span class="math inline">\(n\)</span> variables</strong>. This
makes it the clear choice for “wide” data problems (e.g., in genomics,
where <span class="math inline">\(p=20,000\)</span> features and <span
class="math inline">\(n=100\)</span> samples).</li>
</ul></li>
<li><strong>Grouping Effect:</strong> How does it handle correlated
features?
<ul>
<li>Ridge: <strong>Strong ✅</strong></li>
<li>LASSO: <strong>Weak ❌</strong> (it “picks one”)</li>
<li>Elastic Net: <strong>Strong ✅</strong></li>
</ul></li>
<li><strong>Solution Uniqueness:</strong> Is the answer stable?
<ul>
<li>Ridge: <strong>Always ✅</strong></li>
<li>LASSO: <strong>No ❌</strong> (not if <span
class="math inline">\(X\)</span> is “rank-deficient,” e.g., <span
class="math inline">\(p &gt; n\)</span> or correlated features)</li>
<li>Elastic Net: <strong>Always ✅</strong> (as long as <span
class="math inline">\(\alpha &lt; 1\)</span>, the Ridge component
guarantees a unique, stable solution).</li>
</ul></li>
<li><strong>Use Case:</strong> When should you use each?
<ul>
<li><strong>Ridge:</strong> For prediction, especially with
<strong>multicollinearity</strong>.</li>
<li><strong>LASSO:</strong> For <strong>interpretability</strong> and
creating <strong>sparse models</strong> (when you think only a few
features matter).</li>
<li><strong>Elastic Net:</strong> The best all-arounder. Use it for
<strong>correlated predictors</strong>, when <strong><span
class="math inline">\(p \gg n\)</span></strong>, or when you need both
<strong>sparsity + stability</strong>.</li>
</ul></li>
</ul>
<h3 id="code-understanding-python-scikit-learn">Code Understanding
(Python <code>scikit-learn</code>)</h3>
<p>When you use this in Python, be aware of a common confusion in the
parameter names:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Concept (from your slides)</th>
<th style="text-align: left;"><code>scikit-learn</code> Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong><span
class="math inline">\(\lambda\)</span></strong> (Lambda)</td>
<td style="text-align: left;"><code>alpha</code></td>
<td style="text-align: left;">The <strong>overall strength</strong> of
regularization.</td>
</tr>
<tr>
<td style="text-align: left;"><strong><span
class="math inline">\(\alpha\)</span></strong> (Alpha)</td>
<td style="text-align: left;"><code>l1_ratio</code></td>
<td style="text-align: left;">The <strong>mixing parameter</strong>
between L1 and L2.</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong> An <code>l1_ratio</code> of <code>0</code>
is Ridge. An <code>l1_ratio</code> of <code>1</code> is LASSO. An
<code>l1_ratio</code> of <code>0.5</code> is a 50/50 mix.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet, ElasticNetCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Initialize a specific model</span></span><br><span class="line"><span class="comment"># This uses 0.5 for lambda (slide&#x27;s alpha) and 0.1 for lambda (slide&#x27;s lambda)</span></span><br><span class="line">model = ElasticNet(alpha=<span class="number">0.1</span>, l1_ratio=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. A much better way: Find the best parameters automatically</span></span><br><span class="line"><span class="comment"># This will test l1_ratios of 0.1, 0.5, and 0.9</span></span><br><span class="line"><span class="comment"># and automatically find the best &#x27;alpha&#x27; (strength) for each.</span></span><br><span class="line">cv_model = ElasticNetCV(</span><br><span class="line">    l1_ratio=[<span class="number">.1</span>, <span class="number">.5</span>, <span class="number">.9</span>],</span><br><span class="line">    cv=<span class="number">5</span>  <span class="comment"># 5-fold cross-validation</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Fit the model to your data (X_train, y_train)</span></span><br><span class="line"><span class="comment"># cv_model.fit(X_train, y_train)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. See the best parameters it found</span></span><br><span class="line"><span class="comment"># print(f&quot;Best l1_ratio (slide&#x27;s alpha): &#123;cv_model.l1_ratio_&#125;&quot;)</span></span><br><span class="line"><span class="comment"># print(f&quot;Best alpha (slide&#x27;s lambda): &#123;cv_model.alpha_&#125;&quot;)</span></span><br></pre></td></tr></table></figure>
<h1 id="high-dimensional-data-analysis">11. High-Dimensional Data
Analysis</h1>
<h2 id="the-core-problem-large-p-small-n">The Core Problem: Large <span
class="math inline">\(p\)</span>, Small <span
class="math inline">\(n\)</span></h2>
<p>The slides introduce the challenge of high-dimensional data, which is
defined by having <strong>many more features (predictors) <span
class="math inline">\(p\)</span> than observations (samples) <span
class="math inline">\(n\)</span></strong>. This is often written as
<strong><span class="math inline">\(p \gg n\)</span></strong>.</p>
<ul>
<li><strong>Example:</strong> Predicting blood pressure (the response
<span class="math inline">\(y\)</span>) using millions of genetic
markers (SNPs) as features <span class="math inline">\(X\)</span>, but
only having data from a few hundred patients.</li>
<li><strong>Troubles:</strong>
<ul>
<li><strong>Overfitting:</strong> Models become “too flexible” and learn
the noise in the training data, rather than the true underlying
pattern.</li>
<li><strong>Non-Unique Solution:</strong> When <span
class="math inline">\(p &gt; n\)</span>, the standard least squares
linear regression model doesn’t even have a unique solution.</li>
<li><strong>Misleading Metrics:</strong> This leads to a common symptom:
a very small <strong>training error</strong> (or high <span
class="math inline">\(R^2\)</span>) but a very large <strong>test
error</strong>.</li>
</ul></li>
</ul>
<h2 id="most-important-image-the-overfitting-trap-figure-6.23">Most
Important Image: The Overfitting Trap (Figure 6.23)</h2>
<p>Figure 6.23 (from the first uploaded image) is the most critical
visual for understanding the <em>problem</em>. It shows what happens
when you add features (variables) that are <em>completely unrelated</em>
to the outcome.</p>
<ul>
<li><strong>Left Plot (R²):</strong> The <span
class="math inline">\(R^2\)</span> on the training data increases
towards 1. This <em>looks</em> like a perfect fit.</li>
<li><strong>Center Plot (Training MSE):</strong> The Mean Squared Error
on the <em>training</em> data decreases to 0. This also <em>looks</em>
perfect.</li>
<li><strong>Right Plot (Test MSE):</strong> The Mean Squared Error on
the <em>test</em> data (new, unseen data) explodes. This reveals the
model is garbage and has just memorized the training set.</li>
</ul>
<p>⚠️ <strong>This is the key takeaway:</strong> In high dimensions,
<span class="math inline">\(R^2\)</span> and training MSE are
<strong>useless</strong> and <strong>misleading</strong> metrics for
model quality.</p>
<h2 id="the-solution-regularization-model-selection">The Solution:
Regularization &amp; Model Selection</h2>
<p>To combat overfitting, we must use <strong>less flexible
models</strong>. The main strategy is <strong>regularization</strong>
(also called shrinkage), which involves adding a penalty term to the
cost function to “shrink” the model coefficients (<span
class="math inline">\(\beta\)</span>).</p>
<h3 id="mathematical-formulas-python-code">Mathematical Formulas &amp;
Python Code 🐍</h3>
<p>The standard <strong>Least Squares</strong> cost function you try to
minimize is: <span class="math display">\[\text{RSS} = \sum_{i=1}^n
\left(y_i - \beta_0 - \sum_{j=1}^p x_{ij}\beta_j\right)^2 \quad
\text{or} \quad \|y - X\beta\|^2_2\]</span> This fails when <span
class="math inline">\(p &gt; n\)</span>. The solutions modify this:</p>
<h4 id="a.-ridge-regression-l_2-penalty">A. Ridge Regression (<span
class="math inline">\(L_2\)</span> Penalty)</h4>
<ul>
<li><strong>Concept:</strong> Shrinks all coefficients towards zero, but
never <em>to</em> zero. It’s good when many features are related to the
outcome.</li>
<li><strong>Math Formula:</strong> <span
class="math display">\[\text{Minimize: } \left( \|y - X\beta\|^2_2 +
\lambda \sum_{j=1}^p \beta_j^2 \right)\]</span>
<ul>
<li>The <span class="math inline">\(\lambda \sum_{j=1}^p
\beta_j^2\)</span> is the <strong><span
class="math inline">\(L_2\)</span> penalty</strong>.</li>
<li><span class="math inline">\(\lambda\)</span> (lambda) is a
<em>tuning parameter</em> that controls the penalty strength. A larger
<span class="math inline">\(\lambda\)</span> means more shrinkage.</li>
</ul></li>
<li><strong>Python (Scikit-learn):</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># alpha is the lambda (λ) tuning parameter</span></span><br><span class="line"><span class="comment"># We find the best alpha using cross-validation</span></span><br><span class="line">ridge_model = Ridge(alpha=<span class="number">1.0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line">ridge_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate using test error (e.g., MSE on test set)</span></span><br><span class="line"><span class="comment"># NOT with training R-squared</span></span><br><span class="line">test_score = ridge_model.score(X_test, y_test) </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b.-the-lasso-l_1-penalty">B. The Lasso (<span
class="math inline">\(L_1\)</span> Penalty)</h4>
<ul>
<li><strong>Concept:</strong> This is a very important method. The <span
class="math inline">\(L_1\)</span> penalty can force coefficients to be
<strong>exactly zero</strong>. This means Lasso performs
<strong>automatic feature selection</strong>, creating a <em>sparse</em>
model.</li>
<li><strong>Math Formula:</strong> <span
class="math display">\[\text{Minimize: } \left( \|y - X\beta\|^2_2 +
\lambda \sum_{j=1}^p |\beta_j| \right)\]</span>
<ul>
<li>The <span class="math inline">\(\lambda \sum_{j=1}^p
|\beta_j|\)</span> is the <strong><span
class="math inline">\(L_1\)</span> penalty</strong>.</li>
<li>Again, <span class="math inline">\(\lambda\)</span> is the tuning
parameter.</li>
</ul></li>
<li><strong>Python (Scikit-learn):</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line"><span class="comment"># alpha is the lambda (λ) tuning parameter</span></span><br><span class="line">lasso_model = Lasso(alpha=<span class="number">0.1</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line">lasso_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The model automatically selects features</span></span><br><span class="line"><span class="comment"># Coefficients that are zero were &#x27;dropped&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(lasso_model.coef_) </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c.-other-methods">C. Other Methods</h4>
<p>The slides also mention:</p>
<ul>
<li><strong>Forward Stepwise Selection:</strong> A different approach
where you start with no features and add them one by one, picking the
one that improves the model most (based on a criterion like
cross-validation error).</li>
<li><strong>Principal Components Regression (PCR):</strong> A
dimensionality reduction technique.</li>
</ul>
<h2 id="the-curse-of-dimensionality-figure-6.24">The Curse of
Dimensionality (Figure 6.24)</h2>
<p>This example (Figures 6.24 and its description) shows a more subtle
problem.</p>
<ul>
<li><strong>Setup:</strong> A model with <span
class="math inline">\(n=100\)</span> observations and 20 <em>true</em>
features.</li>
<li><strong>Plots:</strong> They test Lasso by adding more and more
<em>irrelevant</em> features:
<ul>
<li><strong><span class="math inline">\(p=20\)</span> (Left):</strong>
Lasso performs well. The lowest test MSE is found with minimal
regularization.</li>
<li><strong><span class="math inline">\(p=50\)</span> (Center):</strong>
Lasso still works well, but it needs more regularization (a smaller
“Degrees of Freedom”) to filter out the 30 junk features.</li>
<li><strong><span class="math inline">\(p=2000\)</span>
(Right):</strong> This is the <strong>curse of dimensionality</strong>.
Even with a good method like Lasso, the 1,980 irrelevant features add so
much noise that the model <strong>performs poorly regardless</strong> of
the tuning parameter. The true signal is “lost in the noise.”</li>
</ul></li>
</ul>
<h2 id="summary-cautions-for-p-n">Summary: Cautions for <span
class="math inline">\(p &gt; n\)</span></h2>
<p>The final slide gives the most important rules to follow:</p>
<ol type="1">
<li><strong>Beware Extreme Multicollinearity:</strong> When <span
class="math inline">\(p &gt; n\)</span>, your features are
mathematically guaranteed to be linearly related, which breaks standard
regression.</li>
<li><strong>Don’t Overstate Results:</strong> A model you find (e.g.,
with Lasso) is just <em>one</em> of many potentially good models.</li>
<li><strong>🚫 DO NOT USE</strong> training <span
class="math inline">\(R^2\)</span>, <span
class="math inline">\(p\)</span>-values, or training MSE to justify your
model. As Figure 6.23 showed, they are misleading.</li>
<li><strong>✅ DO USE</strong> <strong>test error</strong> and
<strong>cross-validation error</strong> to choose your model and assess
its performance.</li>
</ol>
<h2 id="the-core-problem-p-gg-n-the-troubles-slide">The Core Problem:
<span class="math inline">\(p \gg n\)</span> (The “Troubles” Slide)</h2>
<p>This slide (filename: <code>...020259.png</code>) sets up the entire
problem. The issue isn’t just “overfitting”; it’s a fundamental
mathematical breakdown of standard methods.</p>
<ul>
<li><strong>“Large <span class="math inline">\(p\)</span> makes our
linear regression model too flexible”</strong>: This is an
understatement. It leads to a problem called an <strong>underdetermined
system</strong>.</li>
<li><strong>“If <span class="math inline">\(p &gt; n\)</span>, the LSE
is not even uniquely determined”</strong>: This is the most important
technical point.
<ul>
<li><strong>Mathematical Reason:</strong> The standard solution for
Ordinary Least Squares (OLS) is <span class="math inline">\(\hat{\beta}
= (X^T X)^{-1} X^T y\)</span>.</li>
<li><span class="math inline">\(X\)</span> is the data matrix with <span
class="math inline">\(n\)</span> rows (observations) and <span
class="math inline">\(p\)</span> columns (features).</li>
<li>The matrix <span class="math inline">\(X^T X\)</span> has dimensions
<span class="math inline">\(p \times p\)</span>.</li>
<li>When <span class="math inline">\(p &gt; n\)</span>, the <span
class="math inline">\(X^T X\)</span> matrix is
<strong>singular</strong>, which means its determinant is zero and it
<strong>cannot be inverted</strong>. The <span
class="math inline">\((X^T X)^{-1}\)</span> term does not exist.</li>
<li><strong>“Extreme multicollinearity”</strong> (from slide
<code>...020744.png</code>) is the direct cause. When <span
class="math inline">\(p &gt; n\)</span>, the columns of <span
class="math inline">\(X\)</span> (the features) are <em>guaranteed</em>
to be linearly dependent. There are infinite combinations of the
features that can explain the data.</li>
</ul></li>
</ul>
<h2 id="the-simplest-example-n2-figure-6.22">The Simplest Example: <span
class="math inline">\(n=2\)</span> (Figure 6.22)</h2>
<p>This slide (filename: <code>...020728.png</code>) is the
<em>perfect</em> illustration of the “not uniquely determined”
problem.</p>
<ul>
<li><strong>Left Plot (Low-D):</strong> Many points (<span
class="math inline">\(n\)</span>), only two parameters (<span
class="math inline">\(p=2\)</span>: intercept <span
class="math inline">\(\beta_0\)</span> and slope <span
class="math inline">\(\beta_1\)</span>). The line is a “best fit” that
balances the errors. The training error (RSS) is non-zero.</li>
<li><strong>Right Plot (High-D):</strong> We have <span
class="math inline">\(n=2\)</span> observations and <span
class="math inline">\(p=2\)</span> parameters.
<ul>
<li>You have two equations (one for each point) and two unknowns (<span
class="math inline">\(\beta_0\)</span> and <span
class="math inline">\(\beta_1\)</span>).</li>
<li>The model has <em>exactly</em> enough flexibility to pass
<em>perfectly</em> through both points.</li>
<li>The result is <strong>zero training error</strong>.</li>
<li>This “perfect” fit is an illusion. If you got a <em>new</em> data
point, this line would almost certainly be a terrible predictor. This is
the essence of overfitting.</li>
</ul></li>
</ul>
<h2 id="the-consequence-misleading-metrics-figure-6.23">The Consequence:
Misleading Metrics (Figure 6.23)</h2>
<p>This slide (filename: <code>...020730.png</code>) scales up the
problem from <span class="math inline">\(n=2\)</span> to <span
class="math inline">\(n=20\)</span> and shows <em>why</em> you must be
cautious.</p>
<ul>
<li><strong>The Setup:</strong> <span
class="math inline">\(n=20\)</span> observations. We start with 1
feature and add more and more <em>irrelevant, junk</em> features.</li>
<li><strong>Left Plot (<span
class="math inline">\(R^2\)</span>):</strong> The <span
class="math inline">\(R^2\)</span> on the training data steadily
increases towards 1 as we add features. This is because, by pure chance,
each new junk feature can explain a tiny bit more of the noise in the
training set.</li>
<li><strong>Center Plot (Training MSE):</strong> The training error
drops to 0. This is the same as the <span
class="math inline">\(n=2\)</span> plot. Once the number of features
(<span class="math inline">\(p\)</span>) gets close to the number of
observations (<span class="math inline">\(n=20\)</span>), the model can
perfectly fit the 20 data points, even if the features are random
noise.</li>
<li><strong>Right Plot (Test MSE):</strong> This is the “truth.” The
<em>actual</em> error on new, unseen data gets worse and worse. By
adding noise features, we are just “memorizing” the training set, and
our model’s ability to generalize is destroyed.</li>
<li><strong>Key Lesson:</strong> (from slide <code>...020744.png</code>)
This is why you must <strong>“Avoid using… <span
class="math inline">\(p\)</span>-values, <span
class="math inline">\(R^2\)</span>, or other traditional measures of
model on training as evidence of good fit.”</strong> They are guaranteed
to lie to you when <span class="math inline">\(p &gt; n\)</span>.</li>
</ul>
<h2 id="the-solutions-the-deal-with-slide">The Solutions (The “Deal
with…” Slide)</h2>
<p>This slide (filename: <code>...020734.png</code>) lists the
strategies to fix this. The core idea is <strong>regularization</strong>
(or shrinkage). We add a “penalty” to the cost function to stop the
<span class="math inline">\(\beta\)</span> coefficients from getting too
large or too numerous.</p>
<h4 id="a.-ridge-regression-l_2-penalty-1">A. Ridge Regression (<span
class="math inline">\(L_2\)</span> Penalty)</h4>
<ul>
<li><strong>Concept:</strong> Keeps all <span
class="math inline">\(p\)</span> features, but shrinks their
coefficients. It’s excellent for handling multicollinearity.</li>
<li><strong>Math:</strong> <span class="math inline">\(\text{Minimize: }
\sum_{i=1}^n \left(y_i - \beta_0 - \sum_{j=1}^p x_{ij}\beta_j\right)^2 +
\lambda \sum_{j=1}^p \beta_j^2\)</span>
<ul>
<li>The first part is the standard RSS.</li>
<li>The <span class="math inline">\(\lambda \sum \beta_j^2\)</span> is
the <strong><span class="math inline">\(L_2\)</span> penalty</strong>.
It punishes large coefficient values.</li>
</ul></li>
<li><strong><span class="math inline">\(\lambda\)</span>
(Lambda):</strong> This is the <strong>tuning parameter</strong>.
<ul>
<li>If <span class="math inline">\(\lambda=0\)</span>, it’s just OLS
(which fails).</li>
<li>If <span class="math inline">\(\lambda \to \infty\)</span>, all
<span class="math inline">\(\beta\)</span>’s are shrunk to 0.</li>
<li>The right <span class="math inline">\(\lambda\)</span> is chosen via
<strong>cross-validation</strong>.</li>
</ul></li>
</ul>
<h4 id="b.-the-lasso-l_1-penalty-1">B. The Lasso (<span
class="math inline">\(L_1\)</span> Penalty)</h4>
<ul>
<li><strong>Concept:</strong> This is often preferred because it
performs <strong>automatic feature selection</strong>. It shrinks many
coefficients to be <strong>exactly zero</strong>.</li>
<li><strong>Math:</strong> <span class="math inline">\(\text{Minimize: }
\sum_{i=1}^n \left(y_i - \beta_0 - \sum_{j=1}^p x_{ij}\beta_j\right)^2 +
\lambda \sum_{j=1}^p |\beta_j|\)</span>
<ul>
<li>The <span class="math inline">\(\lambda \sum |\beta_j|\)</span> is
the <strong><span class="math inline">\(L_1\)</span> penalty</strong>.
This absolute value penalty is what allows coefficients to become
exactly 0.</li>
</ul></li>
<li><strong>Benefit:</strong> The final model is <em>sparse</em> (e.g.,
it might say “out of 2,000 features, only these 15 matter”).</li>
</ul>
<h4 id="c.-tuning-parameter-choice-the-real-work">C. Tuning Parameter
Choice (The <em>Real</em> Work)</h4>
<p>How do you pick the best <span
class="math inline">\(\lambda\)</span>? You must use the data you have.
The slides mention this and “cross validation error” (from
<code>...020744.png</code>).</p>
<ul>
<li><strong>Python Code (Scikit-learn):</strong> You don’t just guess
<code>alpha</code> (which is <span
class="math inline">\(\lambda\)</span> in scikit-learn). You use a tool
like <code>LassoCV</code> or <code>GridSearchCV</code> to find the best
one. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LassoCV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a high-dimensional dataset</span></span><br><span class="line">X, y = make_regression(n_samples=<span class="number">100</span>, n_features=<span class="number">500</span>, n_informative=<span class="number">10</span>, noise=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LassoCV automatically performs cross-validation to find the best alpha (lambda)</span></span><br><span class="line"><span class="comment"># cv=10 means 10-fold cross-validation</span></span><br><span class="line">lasso_cv_model = LassoCV(cv=<span class="number">10</span>, random_state=<span class="number">0</span>, max_iter=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the model</span></span><br><span class="line">lasso_cv_model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the best lambda (alpha) it found:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Best alpha (lambda): <span class="subst">&#123;lasso_cv_model.alpha_&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can now see the coefficients</span></span><br><span class="line"><span class="comment"># Most of the 500 coefficients will be 0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Number of non-zero features: <span class="subst">&#123;np.<span class="built_in">sum</span>(lasso_cv_model.coef_ != <span class="number">0</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="a-final-warning-the-curse-of-dimensionality-figure-6.24">A Final
Warning: The Curse of Dimensionality (Figure 6.24)</h2>
<p>This final set of slides (filenames: <code>...020738.png</code> and
<code>...020741.jpg</code>) provides a crucial, subtle warning:
<strong>Regularization is not magic.</strong></p>
<ul>
<li><strong>The Setup:</strong> <span
class="math inline">\(n=100\)</span> observations. There are <strong>20
real features</strong> that truly affect the response.</li>
<li><strong>The Experiment:</strong> They run Lasso three times, adding
more and more <em>noise</em> features:
<ul>
<li><strong>Left Plot (<span
class="math inline">\(p=20\)</span>):</strong> All 20 features are real.
The lowest test MSE is found with minimal regularization (high “Degrees
of Freedom,” meaning many non-zero coefficients). This makes sense; you
want to keep all 20 real features.</li>
<li><strong>Center Plot (<span
class="math inline">\(p=50\)</span>):</strong> Now we have 20 real
features + 30 noise features. Lasso still works! The best model is found
with more regularization (fewer “Degrees of Freedom”). Lasso
successfully “zeroed out” many of the 30 noise features.</li>
<li><strong>Right Plot (<span
class="math inline">\(p=2000\)</span>):</strong> This is the
<strong>curse of dimensionality</strong>. We have 20 real features +
1980 noise features. The <em>noise</em> has completely overwhelmed the
<em>signal</em>. <strong>Lasso fails.</strong> The test MSE is high
<em>no matter what</em> tuning parameter you choose. The model cannot
distinguish the 20 real features from the 1980 junk ones.</li>
</ul></li>
</ul>
<p><strong>Final Takeaway:</strong> Even with advanced methods like
Lasso, if your <span class="math inline">\(p \gg n\)</span> problem is
<em>too</em> extreme (i.S. the signal-to-noise ratio is too low), it may
be impossible to build a good predictive model.</p>
<h2 id="the-goal-collaborative-filtering">The Goal: “Collaborative
Filtering”</h2>
<p>The first slide (<code>...021218.png</code>) uses the term
<strong>Collaborative Filtering</strong>. This is the key concept. The
model “collaborates” by using the ratings of <em>all</em> users to fill
in the blanks for a <em>single</em> user.</p>
<ul>
<li><strong>How it works:</strong> The model assumes your “taste”
(vector <span class="math inline">\(\mathbf{u}_i\)</span>) can be
described as a combination of <span class="math inline">\(r\)</span>
“latent features” (e.g., <span class="math inline">\(r=3\)</span>: %
action, % comedy, % drama). It <em>also</em> assumes each movie (vector
<span class="math inline">\(\mathbf{v}_j\)</span>) has a profile on
these same features.</li>
<li>Your predicted rating for a movie is the dot product of your taste
vector and the movie’s feature vector.</li>
<li>The model finds the best “taste” vectors <span
class="math inline">\(\mathbf{U}\)</span> and “movie” vectors <span
class="math inline">\(\mathbf{V}\)</span> that explain all the known
ratings <em>simultaneously</em>. It’s collaborative because Lee’s
ratings help define the features of “Bullet Train” (<span
class="math inline">\(\mathbf{v}_2\)</span>), which in turn helps
predict Yang’s rating for that same movie.</li>
</ul>
<h2 id="the-hard-problem-and-its-2-flavors">The Hard Problem (and its 2
Flavors)</h2>
<p>The second slide (<code>...021222.png</code>) presents the intuitive,
but computationally <em>very</em> hard, way to frame the problem.</p>
<h4 id="detail-1-noise-vs.-no-noise">Detail 1: Noise vs. No Noise</h4>
<p>The slide shows <span class="math inline">\(\mathbf{Y} = \mathbf{M} +
\mathbf{E}\)</span>. This is critical. * <span
class="math inline">\(\mathbf{M}\)</span> is the “true,” “clean,”
underlying low-rank matrix of everyone’s “true” preferences. * <span
class="math inline">\(\mathbf{E}\)</span> is a matrix of random noise.
(e.g., your true rating is 4.3, but you entered a 4; or you were in a
bad mood and rated a 3). * <span
class="math inline">\(\mathbf{Y}\)</span> is the <em>noisy data</em> we
actually observe.</p>
<p>Because of this noise, we don’t expect to find a matrix <span
class="math inline">\(\mathbf{N}\)</span> that <em>perfectly</em>
matches our data. Instead, we try to find a low-rank <span
class="math inline">\(\mathbf{N}\)</span> that is <em>as close as
possible</em>. This leads to the formula: <span
class="math display">\[\underset{\text{rank}(\mathbf{N}) \le
r}{\text{minimize}} \quad \left\| \mathcal{P}_{\mathcal{O}}(\mathbf{Y} -
\mathbf{N}) \right\|_{\text{F}}^2\]</span> This says: “Find a matrix
<span class="math inline">\(\mathbf{N}\)</span> (of rank <span
class="math inline">\(r\)</span> or less) that minimizes the sum of
squared errors <em>only on the ratings we observed</em> (<span
class="math inline">\(\mathcal{O}\)</span>).”</p>
<h4
id="detail-2-why-is-textrankmathbfn-le-r-a-non-convex-constraint">Detail
2: Why is <span class="math inline">\(\text{rank}(\mathbf{N}) \le
r\)</span> a “Non-convex constraint”?</h4>
<p>This is the “difficult to optimize” part. A convex problem is
(simplistically) one with a single valley, making it easy to find the
single lowest point. A non-convex problem has many local valleys, and an
algorithm can get stuck in a “pretty good” valley instead of the “best”
one.</p>
<p>The rank constraint is non-convex. For example, the average of two
rank-1 matrices is <em>not</em> necessarily a rank-1 matrix (it could be
rank-2). This lack of a “smooth valley” property makes the problem
NP-hard.</p>
<h4 id="detail-3-the-number-of-parameters-rd_1-d_2">Detail 3: The Number
of Parameters: <span class="math inline">\(r(d_1 + d_2)\)</span></h4>
<p>The slide asks, “how many entries are needed?” The answer is based on
the number of unknown parameters. * A rank-<span
class="math inline">\(r\)</span> matrix <span
class="math inline">\(\mathbf{M}\)</span> can be factored into <span
class="math inline">\(\mathbf{U}\)</span> (which is <span
class="math inline">\(d_1 \times r\)</span>) and <span
class="math inline">\(\mathbf{V}^T\)</span> (which is <span
class="math inline">\(r \times d_2\)</span>). * The number of entries in
<span class="math inline">\(\mathbf{U}\)</span> is <span
class="math inline">\(d_1 \times r\)</span>. * The number of entries in
<span class="math inline">\(\mathbf{V}\)</span> is <span
class="math inline">\(d_2 \times r\)</span>. * Total “unknowns” to solve
for: <span class="math inline">\(d_1 r + d_2 r = r(d_1 + d_2)\)</span>.
* This means we must have <em>at least</em> <span
class="math inline">\(r(d_1 + d_2)\)</span> observed ratings to have any
hope of uniquely solving for <span
class="math inline">\(\mathbf{U}\)</span> and <span
class="math inline">\(\mathbf{V}\)</span>. If our number of observations
<span class="math inline">\(|\mathcal{O}|\)</span> is less than this,
the problem is hopelessly underdetermined.</p>
<h2 id="the-magic-solution-convex-relaxation">The “Magic” Solution:
Convex Relaxation</h2>
<p>The final slide (<code>...021225.png</code>) presents the
groundbreaking solution from Candès and Recht. This solution cleverly
<em>changes the problem</em> to one that is convex and solvable.</p>
<h4
id="detail-1-the-l1-norm-analogy-this-is-the-most-important-concept">Detail
1: The L1-Norm Analogy (This is the most important concept)</h4>
<p>This is the key to understanding <em>why</em> this works.</p>
<ul>
<li><strong>In Vectors (Lasso):</strong>
<ul>
<li><strong>Hard Problem:</strong> Find the <em>sparsest</em> vector
<span class="math inline">\(\beta\)</span> (fewest non-zeros). This is
<span class="math inline">\(L_0\)</span> norm, <span
class="math inline">\(\text{minimize } \|\beta\|_0\)</span>. This is
non-convex.</li>
<li><strong>Easy Problem:</strong> Minimize the <span
class="math inline">\(L_1\)</span> norm, <span
class="math inline">\(\text{minimize } \|\beta\|_1 = \sum
|\beta_j|\)</span>. This is convex, and it’s a “relaxation” that
<em>also</em> produces sparse solutions.</li>
</ul></li>
<li><strong>In Matrices (Matrix Completion):</strong>
<ul>
<li><strong>Hard Problem:</strong> Find the <em>lowest-rank</em> matrix
<span class="math inline">\(\mathbf{X}\)</span>. Rank is the number of
non-zero singular values. This is <span
class="math inline">\(\text{minimize } \text{rank}(\mathbf{X})\)</span>.
This is non-convex.</li>
<li><strong>Easy Problem:</strong> Minimize the <strong>Nuclear
Norm</strong>, <span class="math inline">\(\text{minimize }
\|\mathbf{X}\|_* = \sum \sigma_i(\mathbf{X})\)</span> (where <span
class="math inline">\(\sigma_i\)</span> are the singular values). This
is convex, and it’s the “matrix equivalent” of the <span
class="math inline">\(L_1\)</span> norm. It’s a relaxation that
<em>also</em> produces low-rank solutions.</li>
</ul></li>
</ul>
<h4 id="detail-2-noiseless-vs.-noisy-again">Detail 2: Noiseless
vs. Noisy (Again)</h4>
<p>Notice the <em>constraint</em> in this new problem: <span
class="math display">\[\text{Minimize } \quad \|\mathbf{X}\|_*\]</span>
<span class="math display">\[\text{Subject to } \quad X_{ij} = M_{ij},
\quad (i, j) \in \mathcal{O}\]</span></p>
<p>This formulation is for the <strong>noiseless</strong> case. It
assumes the <span class="math inline">\(M_{ij}\)</span> we observed are
<em>perfectly accurate</em>. It demands that our solution <span
class="math inline">\(\mathbf{X}\)</span> <em>exactly matches</em> the
known ratings. This is different from the optimization problem on the
previous slide, which just tried to get <em>close</em> to the noisy data
<span class="math inline">\(\mathbf{Y}\)</span>.</p>
<p>(In practice, you solve a noisy-aware version that combines both
ideas, but the slide shows the original, “exact completion”
problem.)</p>
<h4 id="detail-3-the-guarantee-what-the-math-at-the-bottom-means">Detail
3: The Guarantee (What the math at the bottom means)</h4>
<p><span class="math display">\[\text{If } \mathcal{O} \text{ is
randomly sampled and } |\mathcal{O}| \gg r(d_1+d_2)\log(d_1+d_2),
\text{... then the solution is unique and } \mathbf{M}
\text{...}\]</span></p>
<p>This is the punchline. The Candès paper <em>proved</em> that if you
have <em>enough</em> (but still very few) <em>randomly</em> sampled
ratings, solving this easy convex problem (minimizing the nuclear norm)
will <em>magically give you the exact, true, low-rank matrix <span
class="math inline">\(\mathbf{M}\)</span></em>.</p>
<ul>
<li><strong><span class="math inline">\(|\mathcal{O}| \gg
r(d_1+d_2)\)</span></strong>: This part makes sense. We need <em>at
least</em> as many observations as our <span
class="math inline">\(r(d_1+d_2)\)</span> degrees of freedom.</li>
<li><strong><span class="math inline">\(\log(d_1+d_2)\)</span></strong>:
This “log” factor is the “price” we pay for not knowing <em>where</em>
the information is. It’s an astonishingly small price.</li>
<li><strong>Example:</strong> For a 1,000,000 user x 10,000 movie matrix
(like Netflix) with <span class="math inline">\(r=10\)</span>, you don’t
need <span class="math inline">\(\approx 10^{10}\)</span> ratings. You
need a number closer to <span class="math inline">\(10 \times (10^6 +
10^4) \times \log(\dots)\)</span>, which is <em>dramatically</em>
smaller. This is why this method is practical.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/10/06/5054C5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/06/5054C5/" class="post-title-link" itemprop="url">MSDM 5054 - Statistical Machine Learning-L5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-06 21:00:00" itemprop="dateCreated datePublished" datetime="2025-10-06T21:00:00+08:00">2025-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-19 22:11:02" itemprop="dateModified" datetime="2025-10-19T22:11:02+08:00">2025-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计机器学习Lecture-5</p>
<p><a target="_blank" rel="noopener" href="https://www.math.hkust.edu.hk/~madxia/">Lecturer: Prof.XIA
DONG</a></p>
<h1 id="resampling">1. Resampling</h1>
<p><strong>Resampling</strong> as a statistical tool to assess the
accuracy of models whose main goal is to estimate the <em>test
error</em> (a model’s performance on new, unseen data) because the
<em>training error</em> is overly optimistic due to overfitting.</p>
<p><strong>重采样</strong>是一种统计工具，用于评估模型的准确性，其主要目标是估计<em>测试误差</em>（模型在新的、未见过的数据上的表现），因为由于过拟合导致<em>训练误差</em>过于乐观。</p>
<h2 id="key-concepts">Key Concepts</h2>
<ul>
<li><strong>Resampling:</strong> The process of repeatedly drawing
samples from a dataset. The two main types mentioned are
<strong>Cross-validation</strong> (to estimate model test error) and
<strong>Bootstrap</strong> (to quantify the uncertainty of estimates).
从数据集中反复抽取样本的过程。主要提到的两种类型是<strong>交叉验证</strong>（用于估计模型测试误差）和<strong>自举</strong>（用于量化估计的不确定性）。</li>
<li><strong>Data Splitting (Ideal Scenario):</strong> In a “data-rich”
situation, you split your data into three parts:
**在“数据丰富”的情况下，您可以将数据拆分为三部分：
<ol type="1">
<li><strong>Training Data:</strong> Used to fit and train the parameters
of various models.用于拟合和训练各种模型的参数。</li>
<li><strong>Validation Data:</strong> Used to assess the trained models,
tune hyperparameters (e.g., choose the polynomial degree), and select
the <em>best</em> model. This helps prevent
overfitting.用于评估已训练的模型、调整超参数（例如，选择多项式的次数）并选择<em>最佳</em>模型。这有助于防止过度拟合。</li>
<li><strong>Test Data:</strong> Used <em>only once</em> on the final,
selected model to get an unbiased estimate of its real-world
performance.
在最终选定的模型上仅使用一次，以获得其实际性能的无偏估计。</li>
</ol></li>
<li><strong>Validation vs. Test Data:</strong> The slides emphasize this
difference (Slide 7). The <strong>validation set</strong> is part of the
model-building and selection process. The <strong>test set</strong> is
kept separate and is only used for the final report card after all
decisions are
made.<strong>验证集</strong>是模型构建和选择过程的一部分。<strong>测试集</strong>是独立的，仅在所有决策完成后用于最终报告。</li>
</ul>
<h2 id="the-validation-set-approach">The Validation Set Approach</h2>
<p>This is the simplest cross-validation
method.这是最简单的交叉验证方法。</p>
<ol type="1">
<li><strong>Split:</strong> The total dataset is randomly divided into
two parts: a <strong>training set</strong> and a <strong>validation
set</strong> (often a 50/50 or 70/30
split).将整个数据集随机分成两部分：<strong>训练集</strong>和<strong>验证集</strong>（通常为
50/50 或 70/30 的比例）。</li>
<li><strong>Train:</strong> Various models are fit <em>only</em> on the
<strong>training
set</strong>.各种模型<em>仅</em>在<strong>训练集</strong>上进行拟合。</li>
<li><strong>Validate:</strong> The performance of each trained model is
evaluated using the <strong>validation set</strong>.
使用<strong>验证集</strong>评估每个训练模型的性能。</li>
<li><strong>Select:</strong> The model with the best performance (e.g.,
the lowest error) on the validation set is chosen as the final model.
选择在验证集上性能最佳（例如，误差最小）的模型作为最终模型。</li>
</ol>
<h3 id="important-image-schematic-slide-10">Important Image: Schematic
(Slide 10)</h3>
<p>This diagram clearly shows a set of <span
class="math inline">\(n\)</span> observations being randomly split into
a training set (blue, with observations 7, 22, 13) and a validation set
(beige, with observation 91). The model learns from the blue set and is
tested on the beige set. 此图清晰地展示了一组 <span
class="math inline">\(n\)</span>
个观测值被随机分成训练集（蓝色，观测值编号为
7、22、13）和验证集（米色，观测值编号为
91）。模型从蓝色数据集进行学习，并在米色数据集上进行测试。</p>
<h2 id="example-auto-data-formulas-code">Example: Auto Data (Formulas
&amp; Code)</h2>
<p>The slides use the <code>Auto</code> dataset to decide the best
polynomial degree to predict <code>mpg</code> from
<code>horsepower</code>.</p>
<h3 id="mathematical-models">Mathematical Models</h3>
<p>The models being compared are polynomials of different degrees. For
example:</p>
<ul>
<li><p><strong>Linear:</strong> <span class="math inline">\(mpg =
\beta_0 + \beta_1(horsepower)\)</span></p></li>
<li><p><strong>Quadratic:</strong> <span class="math inline">\(mpg =
\beta_0 + \beta_1(horsepower) + \beta_2(horsepower)^2\)</span></p></li>
<li><p><strong>Cubic:</strong> <span class="math inline">\(mpg = \beta_0
+ \beta_1(horsepower) + \beta_2(horsepower)^2 +
\beta_3(horsepower)^3\)</span></p></li>
<li><p><strong>线性</strong>：<span class="math inline">\(mpg = \beta_0
+ \beta_1(马力)\)</span></p></li>
<li><p><strong>二次</strong>：<span class="math inline">\(mpg = \beta_0
+ \beta_1(马力) + \beta_2(马力)^2\)</span></p></li>
<li><p><strong>三次</strong>：<span class="math inline">\(mpg = \beta_0
+ \beta_1(马力) + \beta_2(马力)^2 + \beta_3(马力)^3\)</span></p></li>
</ul>
<p>The performance metric used is the <strong>Mean Squared Error
(MSE)</strong> on the validation set:
使用的性能指标是验证集上的<strong>均方误差 (MSE)</strong>： <span
class="math display">\[MSE_{val} = \frac{1}{n_{val}} \sum_{i \in val}
(y_i - \hat{f}(x_i))^2\]</span> where <span
class="math inline">\(n_{val}\)</span> is the number of observations in
the validation set, <span class="math inline">\(y_i\)</span> is the true
<code>mpg</code> value, and <span
class="math inline">\(\hat{f}(x_i)\)</span> is the model’s prediction
for the <span class="math inline">\(i\)</span>-th observation in the
validation set. 其中 <span class="math inline">\(n_{val}\)</span>
是验证集中的观测值数量， <span class="math inline">\(y_i\)</span>
是真实的 <code>mpg</code> 值，<span
class="math inline">\(\hat{f}(x_i)\)</span> 是模型对验证集中第 <span
class="math inline">\(i\)</span> 个观测值的预测。 ### Important Image:
Polynomial Fits (Slide 8) 多项式拟合（幻灯片 8）</p>
<p>This plot is crucial. It shows the <code>Auto</code> data with linear
(red), quadratic (green), and cubic (blue) regression lines. * The
<strong>linear fit</strong> is clearly poor. * The <strong>quadratic and
cubic fits</strong> follow the data’s curve much better. * The inset box
shows the MSE calculated on the <em>full dataset</em> (this is training
MSE): * Linear MSE: ~26.42 * Quadratic MSE: ~21.60 * Cubic MSE: ~21.51
This suggests a non-linear fit is necessary, but it doesn’t tell us
which one will generalize better.</p>
<p>这张图至关重要。它用线性（红色）、二次（绿色）和三次（蓝色）回归线展示了
<code>Auto</code> 数据。 * <strong>线性拟合</strong> 明显较差。 *
<strong>二次和三次拟合</strong> 更能贴合数据曲线。 * 插图显示了基于
<em>完整数据集</em> 计算的均方误差（这是训练均方误差）： *
线性均方误差：~26.42 * 二次均方误差：~21.60 * 三次均方误差：~21.51
这表明非线性拟合是必要的，但它并没有告诉我们哪种拟合方式的泛化效果更好。
### Code Analysis</p>
<p>The slides show two different approaches in code:</p>
<p><strong>1. Python Code (Slide 9): Model Selection
Criteria</strong></p>
<ul>
<li><strong>What it does:</strong> This Python code (using
<code>pandas</code> and <code>statsmodels</code>) does <em>not</em>
implement the validation set approach. Instead, it fits polynomial
models (degrees 1 through 5) to the <em>entire</em> dataset.</li>
<li><strong>How it works:</strong> It calculates statistical criteria
like <strong>BIC</strong>, <strong>Mallow’s <span
class="math inline">\(C_p\)</span></strong>, and <strong>Adjusted <span
class="math inline">\(R^2\)</span></strong>. These are mathematical
adjustments to the training error that <em>estimate</em> the test error
without needing a validation set.
<strong>它计算统计标准，例如</strong>BIC<strong>、</strong>Mallow 的
<span class="math inline">\(C_p\)</span>** 和<strong>调整后的 <span
class="math inline">\(R^2\)</span></strong>。这些是对训练误差的数学调整，无需验证集即可<em>估算</em>测试误差。</li>
<li><strong>Key line (logic):</strong> <code>sm.OLS(y, X).fit()</code>
is used to fit the model, and then metrics like <code>model.bic</code>
and <code>model.rsquared_adj</code> are extracted.</li>
<li><strong>Result:</strong> The table shows that the model with
<code>[horsepower, horsepower2]</code> (quadratic) has the lowest BIC
and <span class="math inline">\(C_p\)</span> values, suggesting it’s the
best model according to these criteria.</li>
<li><strong>结果：</strong>表格显示，带有
<code>[马力, 马力2]</code>（二次函数）的模型具有最低的 BIC 和 <span
class="math inline">\(C_p\)</span>
值，这表明根据这些标准，它是最佳模型。</li>
</ul>
<p><strong>2. R Code (Slides 14 &amp; 15): The Validation Set
Approach</strong></p>
<ul>
<li><strong>What it does:</strong> This R code <em>directly
implements</em> the validation set approach described on Slide 13.</li>
<li><strong>How it works:</strong>
<ol type="1">
<li><code>set.seed(...)</code>: Sets a random seed to make the split
reproducible.</li>
<li><code>train=sample(392, 196)</code>: Randomly selects 196 indices
(out of 392) to be the <strong>training set</strong>.</li>
<li><code>lm.fit=lm(mpg~poly(horsepower, 2), ..., subset=train)</code>:
Fits a quadratic model <em>only</em> using the <code>train</code>
data.</li>
<li><code>mean((mpg-predict(lm.fit,Auto))[-train]^2)</code>: This is the
key calculation.
<ul>
<li><code>predict(lm.fit, Auto)</code>: Predicts <code>mpg</code> for
<em>all</em> data.</li>
<li><code>[-train]</code>: Selects only the predictions for the
<strong>validation set</strong> (the data <em>not</em> in
<code>train</code>).</li>
<li><code>mean(...)</code>: Calculates the <strong>MSE on the validation
set</strong>.</li>
</ul></li>
</ol></li>
<li><strong>Result:</strong> The code is run three times with different
seeds (1, 2022, 1997).
<ul>
<li><strong>Seed 1:</strong> Quadratic MSE (18.71) is lowest.</li>
<li><strong>Seed 2022:</strong> Quadratic MSE (19.70) is lowest.</li>
<li><strong>Seed 1997:</strong> Quadratic MSE (19.08) is lowest.</li>
</ul></li>
<li><strong>Main Takeaway:</strong> In all random splits, the
<strong>quadratic model gives the lowest validation set MSE</strong>.
This provides evidence that the quadratic model is the best choice for
generalizing to new data. The fact that the MSE values change with each
seed also highlights a key <em>disadvantage</em> of this simple method:
the results can be variable depending on the random split.
<strong>主要结论</strong>：在所有随机拆分中，**二次模型的验证集 MSE
最低。这证明了二次模型是推广到新数据的最佳选择。MSE
值随每个种子变化的事实也凸显了这种简单方法的一个关键<em>缺点</em>：结果可能会因随机拆分而变化。</li>
</ul>
<h1 id="the-validation-set-approach-验证集方法">2. The Validation Set
Approach 验证集方法</h1>
<p>This method is a simple way to estimate a model’s performance on new,
unseen data (the “test error”).
这种方法是一种简单的方法，用于评估模型在新的、未见过的数据（“测试误差”）上的性能。
The core idea is to <strong>randomly split</strong> your available data
into two parts:
其核心思想是将可用数据<strong>随机拆分</strong>为两部分： 1.
<strong>Training Set:</strong> Used to fit (or “train”) your model.
用于拟合（或“训练”）模型。 2. <strong>Validation Set (or Test
Set):</strong> Used to evaluate the trained model’s performance. You
calculate the error (like Mean Squared Error) on this set.
用于评估训练后的模型性能。计算此集合的误差（例如均方误差）。</p>
<h3 id="python-code-explained-slide-1">Python Code Explained (Slide
1)</h3>
<p>The first slide shows a Python example using the <code>Auto</code>
dataset to predict <code>mpg</code> from <code>horsepower</code>.</p>
<ol type="1">
<li><strong>Setup &amp; Data Loading:</strong>
<ul>
<li><code>import</code> statements load libraries like
<code>pandas</code> (for data),
<code>sklearn.model_selection.train_test_split</code> (the key function
for this method), and
<code>sklearn.linear_model.LinearRegression</code>.</li>
<li><code>Auto = pd.read_csv(...)</code> loads the data.</li>
<li><code>X = Auto['horsepower'].values</code> and
<code>y = Auto['mpg'].values</code> select the variables of
interest.</li>
</ul></li>
<li><strong>The Split:</strong>
<ul>
<li><code>X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.5, random_state=007)</code></li>
<li>This is the <strong>most important line</strong> for this method. It
splits the data <code>X</code> and <code>y</code> into training and
testing (validation) sets.</li>
<li><code>train_size=0.5</code> means 50% of the data is for training
and 50% is for validation.</li>
<li><code>random_state=007</code> ensures the split is “random” but
“reproducible” (using the same seed <code>007</code> will always produce
the same split).</li>
</ul></li>
<li><strong>Model Fitting &amp; Evaluation:</strong>
<ul>
<li>The code fits three different polynomial models, but it <strong>only
uses the training data</strong> (<code>X_train</code>,
<code>y_train</code>) to do so.</li>
<li><strong>Linear (Degree 1):</strong> A simple
<code>LinearRegression</code>.</li>
<li><strong>Quadratic (Degree 2):</strong> Uses
<code>PolynomialFeatures(2)</code> to create <span
class="math inline">\(x\)</span> and <span
class="math inline">\(x^2\)</span> terms, then fits a linear model to
them.</li>
<li><strong>Cubic (Degree 3):</strong> Uses
<code>PolynomialFeatures(3)</code> to create <span
class="math inline">\(x\)</span>, <span
class="math inline">\(x^2\)</span>, and <span
class="math inline">\(x^3\)</span> terms.</li>
<li>It then calculates the <strong>Mean Squared Error (MSE)</strong> for
all three models using the <strong>test data</strong>
(<code>X_test</code>, <code>y_test</code>).</li>
</ul></li>
<li><strong>Results (from the text on the slide):</strong>
<ul>
<li><strong>Linear MSE:</strong> <span class="math inline">\(\approx
23.3\)</span></li>
<li><strong>Quadratic MSE:</strong> <span class="math inline">\(\approx
19.4\)</span></li>
<li><strong>Cubic MSE:</strong> <span class="math inline">\(\approx
19.4\)</span></li>
<li><strong>Conclusion:</strong> The quadratic model gives a
significantly lower error than the linear model. The cubic model does
not offer any real improvement over the quadratic one.</li>
</ul>
<strong>结果（来自幻灯片上的文字）：</strong>
<ul>
<li><strong>线性均方误差</strong>：约 23.3</li>
<li><strong>二次均方误差</strong>：约 19.4</li>
<li><strong>三次均方误差</strong>：约 19.4</li>
<li><strong>结论：</strong>二次模型的误差显著低于线性模型。三次模型与二次模型相比并没有任何实质性的改进。</li>
</ul></li>
</ol>
<h3 id="key-images-the-problem-with-a-single-split">Key Images: The
Problem with a Single Split</h3>
<p>The most important images are on <strong>slide 9</strong> (labeled
“Figure” and “Page 20”).</p>
<ul>
<li><strong>Plot on the Left (Single Split):</strong> This graph shows
the validation MSE for polynomial degrees 1 through 10, based on the
<em>single random split</em> from the R code (slide 2). Just like the
Python example, it shows that the MSE drops sharply from degree 1 to 2,
and then stays relatively low. Based on this <em>one</em> chart, you
might pick degree 2 (quadratic) as the best model.</li>
</ul>
<p>**此图显示了多项式次数为 1 至 10 的验证均方误差，基于 R 代码（幻灯片
2）中的<em>单次随机分割</em>。与 Python 示例一样，它显示 MSE 从 1 阶到 2
阶急剧下降，然后保持在相对较低的水平。基于这张<em>一</em>图，您可能会选择
2 阶（二次）作为最佳模型。</p>
<ul>
<li><strong>Plot on the Right (Ten Splits):</strong> This is the
<strong>most critical plot</strong>. It shows the results of
<em>repeating the entire process 10 times</em>, each with a new random
split (from R code on slide 3).
<ul>
<li>You can see 10 different error curves.</li>
<li>While they all agree that degree 1 (linear) is bad, they <strong>do
not agree on the best model</strong>. Some curves suggest degree 2 is
best, others suggest 3, 4, or even 6.</li>
</ul>
<strong>这是</strong>最关键的图表**。它显示了<em>重复整个过程 10
次</em>的结果，每次都使用新的随机分割（来自幻灯片 3 上的 R 代码）。
<ul>
<li>您可以看到 10 条不同的误差曲线。</li>
<li>虽然他们都认为 1
阶（线性）模型不好，但他们<strong>对最佳模型的看法并不一致</strong>。有些曲线表明
2 阶最佳，而另一些则表明 3 阶、4 阶甚至 6 阶最佳。</li>
</ul></li>
</ul>
<h3 id="summary-of-drawbacks-slides-7-8-9-23-25">Summary of Drawbacks
(Slides 7, 8, 9, 23, 25)</h3>
<p>The slides repeatedly emphasize the two main drawbacks of this simple
validation set approach:</p>
<ol type="1">
<li><p><strong>High Variability 高变异性:</strong> The estimated test
MSE can be <strong>highly variable</strong>, depending on which
observations happen to land in the training set versus the validation
set. The plot with 10 curves (slide 9, right) proves this perfectly.
估计的测试 MSE
可能<strong>高度变异</strong>，具体取决于哪些观测值恰好落在训练集和验证集中。包含
10 条曲线的图表（幻灯片 9，右侧）完美地证明了这一点。</p></li>
<li><p><strong>Overestimation of Test Error 高估测试误差:</strong></p>
<ul>
<li>The model is <strong>only trained on a subset</strong> (e.g., 50%)
of the available data. The validation data is “wasted” and not used for
model building.</li>
<li>Statistical methods tend to perform worse when trained on fewer
observations.</li>
<li>Therefore, the model trained on just the training set is likely
<em>worse</em> than a model trained on the <em>entire</em> dataset.</li>
<li>This “worse” model will have a <em>higher</em> error rate on the
validation set. This means the validation set MSE <strong>tends to
overestimate</strong> the true test error you would get from a model
trained on all your data.</li>
<li>该模型<strong>仅基于可用数据的子集</strong>（例如
50%）进行训练。验证数据被“浪费”了，并未用于模型构建。</li>
<li>统计方法在较少的观测值上进行训练时往往表现较差。</li>
<li>因此，仅基于训练集训练的模型可能比基于<em>整个</em>数据集训练的模型<em>更差</em>。</li>
<li>这个“更差”的模型在验证集上的错误率会更高。这意味着验证集的 MSE
<strong>倾向于高估</strong>基于所有数据训练的模型的真实测试误差。</li>
</ul></li>
</ol>
<h2 id="cross-validation-the-solution-交叉验证解决方案">3.
Cross-Validation: The Solution 交叉验证：解决方案</h2>
<p>The slides introduce <strong>Cross-Validation (CV)</strong> as the
method to overcome these drawbacks. The core idea is to use <em>all</em>
data points for both training and validation, just at different times.
<strong>交叉验证
(CV)</strong>，以此来克服这些缺点。其核心思想是将<em>所有</em>数据点用于训练和验证，只是使用的时间不同。</p>
<h3
id="leave-one-out-cross-validation-loocv-留一法交叉验证-loocv">Leave-One-Out
Cross-Validation (LOOCV) 留一法交叉验证 (LOOCV)</h3>
<p>This is the first type of CV introduced (slide 10, page 26). For a
dataset with <span class="math inline">\(n\)</span> data points:</p>
<ol type="1">
<li><strong>Hold out</strong> the 1st data point (this is your
validation set).
<strong>保留</strong>第一个数据点（这是你的验证集）。</li>
<li><strong>Train</strong> the model on the <em>other <span
class="math inline">\(n-1\)</span> data points</em>. 使用<em>其他 <span
class="math inline">\(n-1\)</span>
个数据点</em><strong>训练</strong>模型。</li>
<li><strong>Calculate</strong> the error (e.g., <span
class="math inline">\(\text{MSE}_1\)</span>) using only that 1st
held-out point. 仅使用第一个保留点<strong>计算</strong>误差（例如，<span
class="math inline">\(\text{MSE}_1\)</span>）。</li>
<li><strong>Repeat</strong> this <span class="math inline">\(n\)</span>
times, holding out the 2nd point, then the 3rd, and so on, until every
point has been used as the validation set exactly once.
<strong>重复</strong>此操作 <span class="math inline">\(n\)</span>
次，保留第二个点，然后是第三个点，依此类推，直到每个点都作为验证集使用一次。</li>
<li>Your final test error estimate is the <strong>average of all <span
class="math inline">\(n\)</span> errors</strong>.
最终的测试误差估计是<strong>所有 <span class="math inline">\(n\)</span>
个误差的平均值</strong>。</li>
</ol>
<h3 id="key-formula-from-slide-10">Key Formula (from Slide 10)</h3>
<p>The formula for the <span class="math inline">\(n\)</span>-fold LOOCV
error estimate is: <span class="math inline">\(n\)</span> 倍 LOOCV
误差估计公式为： <span class="math display">\[\text{CV}_{(n)} =
\frac{1}{n} \sum_{i=1}^{n} \text{MSE}_i\]</span></p>
<p>Where: * <span class="math inline">\(n\)</span> is the total number
of data points. 是数据点的总数。 * <span
class="math inline">\(\text{MSE}_i\)</span> is the Mean Squared Error
calculated on the <span class="math inline">\(i\)</span>-th data point
when it was held out. 是保留第 <span class="math inline">\(i\)</span>
个数据点时计算的均方误差。</p>
<h1 id="what-is-loocv-leave-one-out-cross-validation">3.What is LOOCV
(Leave-One-Out Cross Validation)</h1>
<p>Leave-One-Out Cross Validation (LOOCV) is a method for estimating the
test error of a model. For a dataset with <span
class="math inline">\(n\)</span> observations, you: 留一交叉验证 (LOOCV)
是一种估算模型测试误差的方法。对于包含 <span
class="math inline">\(n\)</span> 个观测值的数据集，您需要：</p>
<ol type="1">
<li><strong>Fit the model <span class="math inline">\(n\)</span> times.
对模型进行 <span class="math inline">\(n\)</span> 次拟合</strong></li>
<li>For each fit <span class="math inline">\(i\)</span> (from <span
class="math inline">\(1\)</span> to <span
class="math inline">\(n\)</span>), you train the model on all data
points <em>except</em> for observation <span
class="math inline">\(i\)</span>. 对于每个拟合 <span
class="math inline">\(i\)</span> 个样本（从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span>），您需要在除观测值 <span
class="math inline">\(i\)</span> 之外的所有数据点上训练模型。</li>
<li>You then use this trained model to make a prediction for the single
observation <span class="math inline">\(i\)</span> that was left out.
然后，您需要使用这个训练好的模型对被遗漏的单个观测值 <span
class="math inline">\(i\)</span> 进行预测。</li>
<li>The final LOOCV error is the average of the <span
class="math inline">\(n\)</span> prediction errors (typically the Mean
Squared Error, or MSE). 最终的 LOOCV 误差是 <span
class="math inline">\(n\)</span>
个预测误差的平均值（通常为均方误差，简称 MSE）。</li>
</ol>
<p>This process is shown visually in the slide titled “LOOCV” (slide
27), which is a key image for understanding the concept. <strong>Pros
&amp; Cons (from slide 28):</strong> * <strong>Pro:</strong> It has low
bias because the training set (<span class="math inline">\(n-1\)</span>
samples) is almost identical to the full dataset.由于训练集（<span
class="math inline">\(n-1\)</span>
个样本）与完整数据集几乎完全相同，因此偏差较低。 * <strong>Pro:</strong>
It produces a stable, non-random error estimate (unlike <span
class="math inline">\(k\)</span>-fold CV, which depends on the random
fold assignments). 它能产生稳定的非随机误差估计（不同于 k
倍交叉验证，后者依赖于随机折叠分配）。 * <strong>Con:</strong> It can be
extremely <strong>computationally expensive</strong>, as the model must
be refit <span class="math inline">\(n\)</span> times.
由于模型必须重新拟合 <span class="math inline">\(n\)</span>
次，计算成本极其高昂。 * <strong>Con:</strong> The <span
class="math inline">\(n\)</span> error estimates can be highly
correlated, which can sometimes lead to high variance in the final <span
class="math inline">\(CV\)</span> estimate. 这 <span
class="math inline">\(n\)</span> 个误差估计可能高度相关，有时会导致最终
<span class="math inline">\(CV\)</span> 估计值出现较大方差。</p>
<h2 id="key-mathematical-formulas">Key Mathematical Formulas</h2>
<p>The main challenge of LOOCV (being computationally expensive) has a
very efficient solution for linear models. LOOCV
的主要挑战（计算成本高昂）对于线性模型来说，有一个非常有效的解决方案。</p>
<h3 id="the-standard-slow-formula">1. The Standard (Slow) Formula</h3>
<p>As defined on slide 33, the LOOCV estimate of the MSE is:</p>
<p><span class="math display">\[CV_{(n)} = \frac{1}{n} \sum_{i=1}^{n}
(y_i - \hat{y}_i^{(i)})^2\]</span></p>
<ul>
<li><span class="math inline">\(y_i\)</span> is the true value of the
<span class="math inline">\(i\)</span>-th observation. 是第 <span
class="math inline">\(i\)</span> 个观测值的真实值。</li>
<li><span class="math inline">\(\hat{y}_i^{(i)}\)</span> is the
predicted value for <span class="math inline">\(y_i\)</span> from a
model trained on all data <em>except</em> observation <span
class="math inline">\(i\)</span>. 是使用除观测值 <span
class="math inline">\(i\)</span> 之外的所有数据训练的模型对 <span
class="math inline">\(y_i\)</span> 的预测值。</li>
</ul>
<p>Calculating <span class="math inline">\(\hat{y}_i^{(i)}\)</span>
requires refitting the model <span class="math inline">\(n\)</span>
times. 计算 <span class="math inline">\(\hat{y}_i^{(i)}\)</span>
需要重新拟合模型 <span class="math inline">\(n\)</span> 次。</p>
<h3 id="the-shortcut-fast-formula">2. The Shortcut (Fast) Formula</h3>
<p>Slide 34 provides a much simpler formula that <strong>only requires
fitting the model once</strong> on the <em>entire</em> dataset:
<em>只需对</em>整个*数据集进行一次模型拟合**：</p>
<p><span class="math display">\[CV_{(n)} = \frac{1}{n} \sum_{i=1}^{n}
\left( \frac{y_i - \hat{y}_i}{1 - h_i} \right)^2\]</span></p>
<ul>
<li><span class="math inline">\(\hat{y}_i\)</span> is the prediction for
<span class="math inline">\(y_i\)</span> from the model trained on
<strong>all <span class="math inline">\(n\)</span> data points</strong>.
是使用<strong>所有 <span class="math inline">\(n\)</span>
个数据点</strong>训练的模型对 <span class="math inline">\(y_i\)</span>
的预测值。</li>
<li><span class="math inline">\(h_i\)</span> is the
<strong>leverage</strong> of the <span
class="math inline">\(i\)</span>-th observation. 是第 <span
class="math inline">\(i\)</span>
个观测值的<strong>杠杆率</strong>。</li>
</ul>
<h3 id="what-is-leverage-h_i">3. What is Leverage (<span
class="math inline">\(h_i\)</span>)?</h3>
<p>Slide 35 defines leverage:</p>
<ul>
<li><p><strong>Hat Matrix (<span
class="math inline">\(\mathbf{H}\)</span>):</strong> In a linear model,
the fitted values <span class="math inline">\(\hat{\mathbf{y}}\)</span>
are related to the true values <span
class="math inline">\(\mathbf{y}\)</span> by the hat matrix: <span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{H}\mathbf{y}\)</span>.</p></li>
<li><p><strong>Formula:</strong> The hat matrix is defined as <span
class="math inline">\(\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span>.</p></li>
<li><p><strong>Leverage (<span
class="math inline">\(h_i\)</span>):</strong> The leverage for the <span
class="math inline">\(i\)</span>-th observation is simply the <span
class="math inline">\(i\)</span>-th diagonal element of the hat matrix,
<span class="math inline">\(h_{ii}\)</span> (often just written as <span
class="math inline">\(h_i\)</span>).</p>
<ul>
<li><span class="math inline">\(h_i = \mathbf{x}_i^T
(\mathbf{X}^T\mathbf{X})^{-1} \mathbf{x}_i\)</span></li>
</ul></li>
<li><p><strong>Meaning:</strong> Leverage measures how “influential” an
observation’s <span class="math inline">\(x_i\)</span> value is in
determining its own predicted value <span
class="math inline">\(\hat{y}_i\)</span>. A high leverage score means
that point has a lot of influence on the model’s fit.</p></li>
<li><p><strong>帽子矩阵 (<span
class="math inline">\(\mathbf{H}\)</span>)：</strong>在线性模型中，拟合值
<span class="math inline">\(\hat{\mathbf{y}}\)</span> 与真实值 <span
class="math inline">\(\mathbf{y}\)</span> 之间存在帽子矩阵关系：<span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{H}\mathbf{y}\)</span>。</p></li>
<li><p><strong>公式：</strong>帽子矩阵定义为 <span
class="math inline">\(\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span>。</p></li>
<li><p><strong>杠杆率 (<span
class="math inline">\(h_i\)</span>)：</strong>第 <span
class="math inline">\(i\)</span> 个观测值的杠杆率就是帽子矩阵的第 <span
class="math inline">\(i\)</span> 个对角线元素 <span
class="math inline">\(h_{ii}\)</span>（通常写为 <span
class="math inline">\(h_i\)</span>）。</p></li>
<li><p><span class="math inline">\(h_i = \mathbf{x}_i^T
(\mathbf{X}^T\mathbf{X})^{-1} \mathbf{x}_i\)</span></p></li>
<li><p><strong>含义：</strong>杠杆率衡量观测值的 <span
class="math inline">\(x_i\)</span> 值对其自身预测值 <span
class="math inline">\(\hat{y}_i\)</span>
的“影响力”。杠杆率得分高意味着该点对模型拟合有很大影响。</p></li>
</ul>
<p>This shortcut formula is extremely important because it makes LOOCV
as fast to compute as a single model
fit.这个快捷公式非常重要，因为它使得 LOOCV
的计算速度与单个模型拟合一样快。</p>
<h2 id="python-code-explained-slide-29">Python Code Explained (Slide
29)</h2>
<p>This slide shows how to use LOOCV to select the best polynomial
degree for predicting <code>mpg</code> from <code>horsepower</code>.</p>
<ol type="1">
<li><strong>Imports:</strong> It imports standard libraries
(<code>pandas</code>, <code>matplotlib</code>) and key modules from
<code>sklearn</code>:
<ul>
<li><code>LinearRegression</code>: The model to be fit.</li>
<li><code>PolynomialFeatures</code>: A tool to create polynomial terms
(e.g., <span class="math inline">\(x, x^2, x^3\)</span>).</li>
<li><code>LeaveOneOut</code>: The LOOCV cross-validation strategy
object.</li>
<li><code>cross_val_score</code>: A function that automatically runs a
cross-validation test.</li>
</ul></li>
<li><strong>Setup:</strong>
<ul>
<li>It loads the <code>Auto.csv</code> data.</li>
<li>It defines <span class="math inline">\(X\)</span>
(<code>horsepower</code>) and <span class="math inline">\(y\)</span>
(<code>mpg</code>).</li>
<li>It creates a <code>LeaveOneOut</code> object:
<code>loo = LeaveOneOut()</code>.</li>
</ul></li>
<li><strong>Looping through Degrees:</strong>
<ul>
<li>The code loops <code>degree</code> from 1 to 10.</li>
<li><strong><code>make_pipeline</code>:</strong> For each degree, it
creates a <code>model</code> using <code>make_pipeline</code>. This
pipeline is a crucial concept:
<ul>
<li>It first runs <code>PolynomialFeatures(degree)</code> to transform
<span class="math inline">\(X\)</span> into <span
class="math inline">\([X, X^2, ..., X^{\text{degree}}]\)</span>.</li>
<li>It then feeds those features into <code>LinearRegression()</code> to
fit the model.</li>
</ul></li>
<li><strong><code>cross_val_score</code>:</strong> This is the most
important line.
<ul>
<li><code>scores = cross_val_score(model, X, y, cv=loo, scoring='neg_mean_squared_error')</code></li>
<li>This function automatically does the <em>entire</em> LOOCV process.
It takes the <code>model</code> (the pipeline), the data <span
class="math inline">\(X\)</span> and <span
class="math inline">\(y\)</span>, and the CV strategy
(<code>cv=loo</code>).</li>
<li><code>sklearn</code>’s <code>cross_val_score</code> uses the “fast”
leverage method internally for linear models, so it doesn’t actually fit
the model <span class="math inline">\(n\)</span> times.</li>
<li>It uses <code>scoring='neg_mean_squared_error'</code> because the
<code>scoring</code> function assumes “higher is better.” By calculating
the <em>negative</em> MSE, the best model will have the highest score
(i.e., closest to 0).</li>
</ul></li>
<li><strong>Storing Results:</strong> It calculates the mean of the
scores (which is the <span class="math inline">\(CV_{(n)}\)</span>) and
stores it.</li>
</ul></li>
<li><strong>Visualization:</strong>
<ul>
<li>The code then plots the final <code>cv_errors</code> (after flipping
the sign back to positive) against the <code>degree</code>.</li>
<li>The resulting plot (also on slide 32) shows the test MSE, allowing
you to visually pick the best degree (where the error is
minimized).</li>
<li>生成的图（也在幻灯片 32 上）显示了测试 MSE，让您可以直观地选择最佳
degree（误差最小化的 degree）。</li>
</ul></li>
</ol>
<hr />
<h2 id="important-images">Important Images</h2>
<ul>
<li><p><strong>Slide 27 (<code>.../103628.png</code>):</strong> This is
the <strong>best conceptual image</strong>. It visually demonstrates how
LOOCV splits the data <span class="math inline">\(n\)</span> times, with
each observation getting one turn as the validation set.
<strong>这是</strong>最佳概念图**。它直观地展示了 LOOCV 如何将数据拆分
<span class="math inline">\(n\)</span>
次，每个观察值都会被旋转一次作为验证集。</p></li>
<li><p><strong>Slide 34 (<code>.../103711.png</code>):</strong> This
slide presents the <strong>most important formula</strong>: the “Easy
formula” or shortcut, <span class="math inline">\(CV_{(n)} = \frac{1}{n}
\sum (\frac{y_i - \hat{y}_i}{1 - h_i})^2\)</span>. This is the key
takeaway for <em>computing</em> LOOCV efficiently in linear models.
<strong>这张幻灯片展示了</strong>最重要的公式**：“简单公式”或简称，<span
class="math inline">\(CV_{(n)} = \frac{1}{n} \sum (\frac{y_i -
\hat{y}_i}{1 - h_i})^2\)</span>。这是在线性模型中高效<em>计算</em> LOOCV
的关键要点。</p></li>
<li><p><strong>Slide 32 (<code>.../103701.jpg</code>):</strong> This is
the <strong>key results image</strong>. It contrasts the LOOCV error
curve (left) with the 10-fold CV error curves (right). It clearly shows
that LOOCV produces a single, stable error curve, while 10-fold CV
results vary slightly each time it’s run due to the random data splits.
<strong>这是</strong>关键结果图**。它将 LOOCV 误差曲线（左）与 10 倍 CV
误差曲线（右）进行了对比。它清楚地表明，LOOCV
产生了单一、稳定的误差曲线，而由于数据分割的随机性，10 倍 CV
的结果每次运行时都会略有不同。</p></li>
</ul>
<h1 id="cross-validation-overview">4. Cross-Validation Overview</h1>
<p>These slides explain <strong>Cross-Validation (CV)</strong>, a method
used to estimate the test error of a model, helping to select the best
level of flexibility (e.g., the best polynomial degree). It’s an
improvement over a single validation set because it uses all the data
for both training and validation at different times.
这是一种用于估算模型测试误差的方法，有助于选择最佳的灵活性（例如，最佳多项式次数）。它比单个验证集有所改进，因为它在不同时间使用所有数据进行训练和验证。</p>
<p>The two main types discussed are <strong>K-fold CV</strong> and
<strong>Leave-One-Out CV (LOOCV)</strong>. 主要讨论的两种类型是<strong>K
折交叉验证</strong>和<strong>留一法交叉验证 (LOOCV)</strong>。</p>
<h2 id="k-fold-cross-validation-k-折交叉验证">K-Fold Cross-Validation K
折交叉验证</h2>
<p>This is the most common method.</p>
<h3 id="the-process">The Process</h3>
<p>As shown in the slides, the K-fold CV process is: 1.
<strong>Divide</strong> the dataset randomly into <span
class="math inline">\(K\)</span> non-overlapping groups (or “folds”),
usually of equal size. Common choices are <span
class="math inline">\(K=5\)</span> or <span
class="math inline">\(K=10\)</span>. 将数据集随机<strong>划分</strong>为
<span class="math inline">\(K\)</span>
个不重叠的组（或“折”），通常大小相等。常见的选择是 <span
class="math inline">\(K=5\)</span> 或 <span
class="math inline">\(K=10\)</span>。 2. <strong>Iterate <span
class="math inline">\(K\)</span> times</strong>: In each iteration <span
class="math inline">\(i\)</span>, use the <span
class="math inline">\(i\)</span>-th fold as the <strong>validation
set</strong> and all other <span class="math inline">\(K-1\)</span>
folds combined as the <strong>training set</strong>. <strong>迭代 <span
class="math inline">\(K\)</span> 次</strong>：在每次迭代 <span
class="math inline">\(i\)</span> 中，使用第 <span
class="math inline">\(i\)</span>
个样本集作为<strong>验证集</strong>，并将所有其他 <span
class="math inline">\(K-1\)</span>
个样本集合并作为<strong>训练集</strong>。 3. <strong>Calculate</strong>
the Mean Squared Error (<span class="math inline">\(MSE_i\)</span>) on
the validation fold. <strong>计算</strong>验证集的均方误差 (<span
class="math inline">\(MSE_i\)</span>)。 4. <strong>Average</strong> all
<span class="math inline">\(K\)</span> error estimates to get the final
CV score. <strong>平均</strong>所有 <span
class="math inline">\(K\)</span> 个误差估计值，得到最终的 CV 分数。 ###
Key Formula The final K-fold CV error estimate is the average of the
errors from each fold: 最终的 K 折 CV
误差估计值是每个样本集误差的平均值： <span
class="math display">\[CV_{(K)} = \frac{1}{K} \sum_{i=1}^{K}
MSE_i\]</span></p>
<h3 id="important-image-the-concept">Important Image: The Concept</h3>
<p>The diagram in slide <code>104145.png</code> is the most important
for understanding the <em>concept</em> of K-fold CV. It shows a dataset
split into 5 folds (<span class="math inline">\(K=5\)</span>). The
process is repeated 5 times, with a different fold (in beige) held out
as the validation set in each run, while the rest (in blue) is used for
training. 它展示了一个被分成 5 个样本集 (<span
class="math inline">\(K=5\)</span>) 的数据集。该过程重复 5
次，每次运行都会保留一个不同的折叠（米色）作为验证集，其余折叠（蓝色）用于训练。</p>
<h2 id="leave-one-out-cross-validation-loocv">Leave-One-Out
Cross-Validation (LOOCV)</h2>
<p>LOOCV is just a special case of K-fold CV where <strong><span
class="math inline">\(K = n\)</span></strong> (the total number of
observations). LOOCV 只是 K 折交叉验证的一个特例，其中 <strong><span
class="math inline">\(K = n\)</span></strong>（观测值总数）。 * You
create <span class="math inline">\(n\)</span> “folds,” each containing
just one data point. 创建 <span class="math inline">\(n\)</span>
个“折叠”，每个折叠仅包含一个数据点。 * You train the model <span
class="math inline">\(n\)</span> times, each time leaving out a
<em>single</em> different observation and then calculating the error for
that one point. 对模型进行 <span class="math inline">\(n\)</span>
次训练，每次都省略一个不同的观测值，然后计算该点的误差。</p>
<h3 id="key-formulas">Key Formulas</h3>
<ol type="1">
<li><p><strong>Standard Definition:</strong> The LOOCV error is the
average of the <span class="math inline">\(n\)</span> squared errors:
<span class="math display">\[CV = \frac{1}{N} \sum_{i=1}^{N}
e_{[i]}^2\]</span> where <span class="math inline">\(e_{[i]} = y_i -
\hat{y}_{[i]}\)</span> is the prediction error for the <span
class="math inline">\(i\)</span>-th observation, calculated from a model
that was trained on <em>all data except</em> the <span
class="math inline">\(i\)</span>-th observation. This looks
computationally expensive. LOOCV 误差是 <span
class="math inline">\(n\)</span> 个平方误差的平均值： <span
class="math display">\[CV = \frac{1}{N} \sum_{i=1}^{N}
e_{[i]}^2\]</span> 其中 <span class="math inline">\(e_{[i]} = y_i -
\hat{y}_{[i]}\)</span> 是第 <span class="math inline">\(i\)</span>
个观测值的预测误差，该误差由一个使用除第 <span
class="math inline">\(i\)</span>
个观测值以外的所有数据训练的模型计算得出。这看起来计算成本很高。</p></li>
<li><p><strong>Fast Computation (for Linear Regression):</strong> A key
point from the slides is that for linear regression, you don’t need to
re-fit the model <span class="math inline">\(N\)</span> times. You can
fit the model <em>once</em> on all <span
class="math inline">\(N\)</span> data points and use the following
shortcut: <span class="math display">\[CV = \frac{1}{N} \sum_{i=1}^{N}
\left( \frac{e_i}{1 - h_i} \right)^2\]</span></p>
<ul>
<li><span class="math inline">\(e_i = y_i - \hat{y}_i\)</span> is the
standard residual (from the model fit on <em>all</em> data).</li>
<li><span class="math inline">\(h_i\)</span> is the <em>leverage
statistic</em> for the <span class="math inline">\(i\)</span>-th
observation (the <span class="math inline">\(i\)</span>-th diagonal
entry of the “hat matrix” <span class="math inline">\(H\)</span>). This
makes LOOCV as fast to compute as a single model fit.
对于线性回归，您无需重新拟合模型 <span class="math inline">\(N\)</span>
次。您可以对所有 <span class="math inline">\(N\)</span>
个数据点<em>一次性</em>地拟合模型，并使用以下快捷方式： <span
class="math display">\[CV = \frac{1}{N} \sum_{i=1}^{N} \left(
\frac{e_i}{1 - h_i} \right)^2\]</span></li>
<li><span class="math inline">\(e_i = y_i - \hat{y}_i\)</span>
是标准残差（来自对<em>所有</em>数据的模型拟合）。</li>
<li><span class="math inline">\(h_i\)</span> 是第 <span
class="math inline">\(i\)</span> 个观测值（“帽子矩阵”<span
class="math inline">\(H\)</span> 的第 <span
class="math inline">\(i\)</span> 个对角线元素）的<em>杠杆统计量</em>。
这使得 LOOCV 的计算速度与单次模型拟合一样快。</li>
</ul></li>
</ol>
<h2 id="python-code-results">Python Code &amp; Results</h2>
<p>The Python code in slide <code>104156.jpg</code> shows how to use
10-fold CV to find the best polynomial degree for a model.</p>
<h3 id="code-understanding-slide-104156.jpg">Code Understanding (Slide
<code>104156.jpg</code>)</h3>
<p>Here’s a breakdown of the key <code>sklearn</code> parts:</p>
<ol type="1">
<li><strong><code>from sklearn.pipeline import make_pipeline</code></strong>:
This is used to chain steps. The pipeline
<code>make_pipeline(PolynomialFeatures(degree), LinearRegression())</code>
first creates polynomial features (like <span
class="math inline">\(x\)</span>, <span
class="math inline">\(x^2\)</span>, <span
class="math inline">\(x^3\)</span>) and then fits a linear model to
them.</li>
<li><strong><code>from sklearn.model_selection import KFold</code></strong>:
This object is used to define the <span
class="math inline">\(K\)</span>-fold split strategy.
<code>kf = KFold(n_splits=10, shuffle=True, random_state=1)</code>
creates a 10-fold splitter that shuffles the data first.</li>
<li><strong><code>from sklearn.model_selection import cross_val_score</code></strong>:
This is the most important function.
<ul>
<li><code>scores = cross_val_score(model, X, y, cv=kf, scoring='neg_mean_squared_error')</code></li>
<li>This one function does all the work: it takes the <code>model</code>
(the pipeline), the data <code>X</code> and <code>y</code>, and the CV
splitter <code>kf</code>. It automatically trains and evaluates the
model 10 times and returns an array of 10 scores (one for each
fold).</li>
<li><code>scoring='neg_mean_squared_error'</code> is used because
<code>cross_val_score</code> expects a <em>higher</em> score to be
<em>better</em>. Since we want to <em>minimize</em> MSE, we use
<em>negative</em> MSE.</li>
</ul></li>
<li><strong><code>avg_mse = -scores.mean()</code></strong>: The code
averages the 10 scores and flips the sign back to positive to get the
final CV (MSE) estimate for that polynomial degree.</li>
</ol>
<h3 id="important-image-the-results">Important Image: The Results</h3>
<p>The plots in slides <code>104156.jpg</code> (Python) and
<code>104224.png</code> (R) show the key result.</p>
<ul>
<li><strong>X-axis:</strong> Degree of Polynomial (model
complexity).多项式的次数（模型复杂度）。</li>
<li><strong>Y-axis:</strong> Estimated Test Error (CV Error /
MSE).估计测试误差（CV 误差 / MSE）。</li>
<li><strong>Interpretation:</strong> The plot shows a clear “U” shape.
The error is high for degree 1 (a simple line), drops to its minimum at
<strong>degree 2</strong> (a quadratic <span class="math inline">\(ax^2
+ bx + c\)</span>), and then starts to rise again for higher degrees.
This rise indicates <strong>overfitting</strong>—the more complex models
are fitting the training data’s noise, leading to worse performance on
unseen validation data. 该图呈现出清晰的“U”形。1
次（一条简单的直线）时误差较大，在<strong>2 次</strong>（二次 <span
class="math inline">\(ax^2 + bx +
c\)</span>）时降至最小，然后随着次数的增加，误差再次上升。这种上升表明<strong>过拟合</strong>——更复杂的模型会拟合训练数据的噪声，导致在未见过的验证数据上的性能下降。</li>
<li><strong>Conclusion:</strong> The 10-fold CV analysis suggests that a
<strong>quadratic model (degree 2)</strong> is the best choice, as it
provides the lowest estimated test error. 10 倍 CV
分析表明<strong>二次模型（2
次）</strong>是最佳选择，因为它提供了最低的估计测试误差。</li>
</ul>
<p>Let’s dive into the details of that proof.</p>
<h2 id="detailed-summary-the-fast-computation-of-loocv-proof">Detailed
Summary: The “Fast Computation of LOOCV” Proof</h2>
<p>The most mathematically dense and important part of your slides is
the proof (spanning slides <code>104126.jpg</code>,
<code>104132.png</code>, and <code>104136.png</code>) that LOOCV, which
seems computationally very expensive, can be calculated quickly for
linear regression. LOOCV
虽然计算成本看似非常高，但对于线性回归来说，它可以快速计算。 ### The
Goal</p>
<p>The goal is to prove that the LOOCV statistic, which is defined as:
<span class="math display">\[CV = \frac{1}{N} \sum_{i=1}^{N} e_{[i]}^2
\quad \text{where } e_{[i]} = y_i - \hat{y}_{[i]}\]</span> (Here, <span
class="math inline">\(\hat{y}_{[i]}\)</span> is the prediction for <span
class="math inline">\(y_i\)</span> from a model trained on all data
<em>except</em> point <span
class="math inline">\(i\)</span>).（其中，<span
class="math inline">\(\hat{y}_{[i]}\)</span> 表示基于除点 <span
class="math inline">\(i\)</span> 之外的所有数据训练的模型对 <span
class="math inline">\(y_i\)</span> 的预测）。</p>
<p>…can be computed <em>without</em> re-fitting the model <span
class="math inline">\(N\)</span> times, using this “fast” formula:
无需重新拟合模型 <span class="math inline">\(N\)</span>
次即可计算，使用以下“快速”公式： <span class="math display">\[CV =
\frac{1}{N} \sum_{i=1}^{N} \left( \frac{e_i}{1 - h_i} \right)^2\]</span>
(Here, <span class="math inline">\(e_i\)</span> is the <em>standard</em>
residual and <span class="math inline">\(h_i\)</span> is the
<em>leverage</em>, both from a single model fit on <em>all</em>
data).</p>
<p>The entire proof boils down to showing one identity: <strong><span
class="math inline">\(e_{[i]} = e_i / (1 - h_i)\)</span></strong>.</p>
<h3 id="key-definitions-the-matrix-algebra-setup-矩阵代数设置">Key
Definitions (The Matrix Algebra Setup) （矩阵代数设置）</h3>
<ul>
<li><strong>Model 模型:</strong> <span class="math inline">\(\mathbf{Y}
= \mathbf{X}\beta + \mathbf{e}\)</span></li>
<li><strong>Full Data Estimate 完整数据估计 (<span
class="math inline">\(\hat{\beta}\)</span>):</strong> <span
class="math inline">\(\hat{\beta} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{Y}\)</span></li>
<li><strong>Hat Matrix 帽子矩阵 (<span
class="math inline">\(\mathbf{H}\)</span>):</strong> <span
class="math inline">\(\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span></li>
<li><strong>Full Data Residual 完整数据残差 (<span
class="math inline">\(e_i\)</span>):</strong> <span
class="math inline">\(e_i = y_i - \hat{y}_i = y_i -
\mathbf{x}_i^T\hat{\beta}\)</span></li>
<li><strong>Leverage (<span class="math inline">\(h_i\)</span>) 杠杆
(<span class="math inline">\(h_i\)</span>):</strong> The <span
class="math inline">\(i\)</span>-th diagonal element of <span
class="math inline">\(\mathbf{H}\)</span>. <span
class="math inline">\(h_i =
\mathbf{x}_i^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i\)</span></li>
<li><strong>Leave-One-Out Estimate (<span
class="math inline">\(\hat{\beta}_{[i]}\)</span>):</strong> <span
class="math inline">\(\hat{\beta}_{[i]} =
(\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})^{-1}\mathbf{X}_{[i]}^T\mathbf{Y}_{[i]}\)</span>
<ul>
<li><span class="math inline">\(\mathbf{X}_{[i]}\)</span> and <span
class="math inline">\(\mathbf{Y}_{[i]}\)</span> are the data with the
<span class="math inline">\(i\)</span>-th row removed.</li>
</ul></li>
<li><strong>LOOCV Residual LOOCV 残差 (<span
class="math inline">\(e_{[i]}\)</span>):</strong> <span
class="math inline">\(e_{[i]} = y_i -
\mathbf{x}_i^T\hat{\beta}_{[i]}\)</span></li>
</ul>
<h3 id="the-proof-step-by-step">The Proof Step-by-Step</h3>
<p>Here is the logic from your slides, broken down:</p>
<h4 id="step-1-relating-the-matrices-slide-104132.png">Step 1: Relating
the Matrices (Slide <code>104132.png</code>)</h4>
<p>The proof’s “trick” is to relate the “full data” matrix <span
class="math inline">\((\mathbf{X}^T\mathbf{X})\)</span> to the
“leave-one-out” matrix <span
class="math inline">\((\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})\)</span>.
证明的“技巧”是将“全数据”矩阵 <span
class="math inline">\((\mathbf{X}^T\mathbf{X})\)</span> 与“留一法”矩阵
<span
class="math inline">\((\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})\)</span>
关联起来。</p>
<ul>
<li><p>The full sum-of-squares matrix is just the leave-one-out matrix
<em>plus</em> the one observation’s contribution:
完整的平方和矩阵就是留一法矩阵<em>加上</em>一个观测值的贡献：</p>
<p><span class="math display">\[\mathbf{X}^T\mathbf{X} =
\mathbf{X}_{[i]}^T\mathbf{X}_{[i]} +
\mathbf{x}_i\mathbf{x}_i^T\]</span></p></li>
<li><p>This means: <span
class="math inline">\(\mathbf{X}_{[i]}^T\mathbf{X}_{[i]} =
\mathbf{X}^T\mathbf{X} - \mathbf{x}_i\mathbf{x}_i^T\)</span></p></li>
</ul>
<h4 id="step-2-the-key-matrix-trick-slide-104132.png">Step 2: The Key
Matrix Trick (Slide <code>104132.png</code>)</h4>
<p>We need the inverse <span
class="math inline">\((\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})^{-1}\)</span>
to calculate <span class="math inline">\(\hat{\beta}_{[i]}\)</span>.
Finding this inverse directly is hard. Instead, we use the
<strong>Sherman-Morrison-Woodbury formula</strong>, which tells us how
to find the inverse of a matrix that’s been “updated” (in this case, by
subtracting <span
class="math inline">\(\mathbf{x}_i\mathbf{x}_i^T\)</span>).</p>
<p>我们需要逆<span
class="math inline">\((\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})^{-1}\)</span>
来计算 <span
class="math inline">\(\hat{\beta}_{[i]}\)</span>。直接求这个逆矩阵很困难。因此，我们使用
<strong>Sherman-Morrison-Woodbury
公式</strong>，它告诉我们如何求一个“更新”后的矩阵的逆矩阵（在本例中，是通过减去
<span class="math inline">\(\mathbf{x}_i\mathbf{x}_i^T\)</span>
来实现的）。</p>
<p>The slide applies this formula to get: <span
class="math display">\[(\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})^{-1} =
(\mathbf{X}^T\mathbf{X})^{-1} +
\frac{(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i\mathbf{x}_i^T(\mathbf{X}^T\mathbf{X})^{-1}}{1
- h_i}\]</span> * This is the most complex step, but it’s a standard
matrix identity. It’s crucial because it expresses the “leave-one-out”
inverse in terms of the “full data” inverse <span
class="math inline">\((\mathbf{X}^T\mathbf{X})^{-1}\)</span>, which we
already have.</p>
<h4 id="step-3-finding-hatbeta_i-slide-104136.png">Step 3: Finding <span
class="math inline">\(\hat{\beta}_{[i]}\)</span> (Slide
<code>104136.png</code>)</h4>
<p>Now we can write a new formula for <span
class="math inline">\(\hat{\beta}_{[i]}\)</span> by substituting the
result from Step 2. We also note that <span
class="math inline">\(\mathbf{X}_{[i]}^T\mathbf{Y}_{[i]} =
\mathbf{X}^T\mathbf{Y} - \mathbf{x}_i y_i\)</span>.</p>
<p><span class="math display">\[\hat{\beta}_{[i]} =
(\mathbf{X}_{[i]}^T\mathbf{X}_{[i]})^{-1}
(\mathbf{X}_{[i]}^T\mathbf{Y}_{[i]})\]</span> <span
class="math display">\[\hat{\beta}_{[i]} = \left[
(\mathbf{X}^T\mathbf{X})^{-1} +
\frac{(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i\mathbf{x}_i^T(\mathbf{X}^T\mathbf{X})^{-1}}{1
- h_i} \right] (\mathbf{X}^T\mathbf{Y} - \mathbf{x}_i y_i)\]</span></p>
<p>The slide then shows the algebra to simplify this big expression.
When you expand and simplify everything, you get a much cleaner
result:</p>
<p><span class="math display">\[\hat{\beta}_{[i]} = \hat{\beta} -
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i \frac{e_i}{1 - h_i}\]</span> *
This is a beautiful result! It says the LOOCV coefficient vector is just
the <em>full</em> coefficient vector minus a small adjustment term
related to the <span class="math inline">\(i\)</span>-th observation’s
residual (<span class="math inline">\(e_i\)</span>) and leverage (<span
class="math inline">\(h_i\)</span>). * 这是一个非常棒的结果！它表明
LOOCV 系数向量就是<em>完整</em>的系数向量减去一个与第 <span
class="math inline">\(i\)</span> 个观测值的残差 (<span
class="math inline">\(e_i\)</span>) 和杠杆率 (<span
class="math inline">\(h_i\)</span>) 相关的小调整项。</p>
<h4 id="step-4-finding-e_i-slide-104136.png">Step 4: Finding <span
class="math inline">\(e_{[i]}\)</span> (Slide
<code>104136.png</code>)</h4>
<p>This is the final step. We use the definition of <span
class="math inline">\(e_{[i]}\)</span> and the result from Step 3.
这是最后一步。我们使用 <span class="math inline">\(e_{[i]}\)</span>
的定义和步骤 3 的结果。</p>
<ul>
<li><strong>Start with the definition:</strong> <span
class="math inline">\(e_{[i]} = y_i -
\mathbf{x}_i^T\hat{\beta}_{[i]}\)</span></li>
<li><strong>Substitute <span
class="math inline">\(\hat{\beta}_{[i]}\)</span>:</strong> <span
class="math inline">\(e_{[i]} = y_i - \mathbf{x}_i^T \left[ \hat{\beta}
- (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i \frac{e_i}{1 - h_i}
\right]\)</span></li>
<li><strong>Distribute <span
class="math inline">\(\mathbf{x}_i^T\)</span>:</strong> <span
class="math inline">\(e_{[i]} = (y_i - \mathbf{x}_i^T\hat{\beta}) +
\left( \mathbf{x}_i^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i \right)
\frac{e_i}{1 - h_i}\)</span></li>
<li><strong>Recognize the terms!</strong>
<ul>
<li>The first term is just the standard residual: <span
class="math inline">\((y_i - \mathbf{x}_i^T\hat{\beta}) =
e_i\)</span></li>
<li>The second term in parentheses is the definition of leverage: <span
class="math inline">\((\mathbf{x}_i^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}_i)
= h_i\)</span></li>
</ul></li>
<li><strong>Substitute back:</strong> <span
class="math inline">\(e_{[i]} = e_i + h_i \left( \frac{e_i}{1 - h_i}
\right)\)</span></li>
<li><strong>Get a common denominator:</strong> <span
class="math inline">\(e_{[i]} = \frac{e_i(1 - h_i) + h_i e_i}{1 -
h_i}\)</span></li>
<li><strong>Simplify the numerator:</strong> <span
class="math inline">\(e_{[i]} = \frac{e_i - e_ih_i + e_ih_i}{1 -
h_i}\)</span></li>
</ul>
<p>This gives the final, simple relationship: <span
class="math display">\[e_{[i]} = \frac{e_i}{1 - h_i}\]</span></p>
<h3 id="conclusion">Conclusion</h3>
<p>By proving this identity, the slides show that to get all <span
class="math inline">\(N\)</span> of the “leave-one-out” errors, you only
need to: 1. Fit <strong>one</strong> linear regression model on
<strong>all</strong> the data. 2. Calculate the standard residuals <span
class="math inline">\(e_i\)</span> and the leverage values <span
class="math inline">\(h_i\)</span> for all <span
class="math inline">\(N\)</span> points. 3. Apply the formula <span
class="math inline">\(e_i / (1 - h_i)\)</span> for each point.</p>
<p>This turns a procedure that looked like it would take <span
class="math inline">\(N\)</span> times the work into a procedure that
takes only <strong>1</strong> model fit. This is why LOOCV is a
practical and efficient method for linear regression.</p>
<p>通过证明这个恒等式，幻灯片显示，要获得所有 <span
class="math inline">\(N\)</span> 个“留一法”误差，您只需： 1.
对<strong>所有</strong>数据拟合<strong>一个</strong>线性回归模型。 2.
计算所有 <span class="math inline">\(N\)</span> 个点的标准残差 <span
class="math inline">\(e_i\)</span> 和杠杆值 <span
class="math inline">\(h_i\)</span>。 3. 对每个点应用公式 <span
class="math inline">\(e_i / (1 - h_i)\)</span>。</p>
<p>这将一个看似需要 <span class="math inline">\(N\)</span>
倍工作量的过程变成了只需 <strong>1</strong>
次模型拟合的过程。这就是为什么 LOOCV
是一种实用且高效的线性回归方法。</p>
<h1 id="main-goal-of-cross-validation-交叉验证的主要目标">5. Main Goal
of Cross-Validation 交叉验证的主要目标</h1>
<p>The central purpose of cross-validation is to <strong>estimate the
true test error</strong> of a machine learning model. This is crucial
for:</p>
<ol type="1">
<li><strong>Model Assessment:</strong> Evaluating how well a model will
perform on new, unseen data. 评估模型在新的、未见过的数据上的表现。</li>
<li><strong>Model Selection:</strong> Choosing the best level of model
flexibility (e.g., the degree of a polynomial or the value of <span
class="math inline">\(K\)</span> in KNN) to avoid
<strong>overfitting</strong>.
选择最佳的模型灵活性水平（例如，多项式的次数或 KNN 中的 <span
class="math inline">\(K\)</span>
值），以避免<strong>过拟合</strong>。</li>
</ol>
<p>As the slides show, <strong>training error</strong> (the error on the
data the model was trained on) consistently decreases as model
complexity increases. However, the <strong>test error</strong> follows a
U-shape: it first decreases (as the model learns the true signal) and
then increases (as the model starts fitting the noise, or
“overfitting”). CV helps find the minimum point of this U-shaped test
error curve.
<strong>训练误差</strong>（模型训练数据的误差）随着模型复杂度的增加而持续下降。然而，<strong>测试误差</strong>呈现
U
形：它先下降（当模型学习真实信号时），然后上升（当模型开始拟合噪声，即“过拟合”时）。交叉验证有助于找到这条
U 形测试误差曲线的最小值。</p>
<h2 id="important-images-1">Important Images 🖼️</h2>
<p>The most important image is on <strong>Slide 61</strong>.</p>
<p>These two plots perfectly illustrate the concept:</p>
<ul>
<li><strong>Blue Line (Training Error):</strong> Always goes down.</li>
<li><strong>Brown Line (True Test Error):</strong> Forms a “U” shape.
This is what we <em>want</em> to find the minimum of, but it’s unknown
in practice.</li>
<li><strong>Black Line (10-fold CV Error):</strong> This is our
<em>estimate</em> of the test error. Notice how closely it tracks the
brown line. The minimum of the CV curve (marked with an ‘x’) is very
close to the minimum of the true test error.</li>
</ul>
<p>This shows <em>why</em> CV works: it provides a reliable estimate to
guide our choice of model (e.g., polynomial degree 3-4 for logistic
regression, or <span class="math inline">\(K \approx 10\)</span> for
KNN).</p>
<ul>
<li><strong>蓝线（训练误差）：</strong>始终向下。</li>
<li><strong>棕线（真实测试误差）：</strong>呈“U”形。这正是我们<em>想要</em>找到的最小值，但在实际应用中无法确定。</li>
<li><strong>黑线（10 倍 CV
误差）：</strong>这是我们对测试误差的<em>估计</em>。注意它与棕线的吻合程度。CV
曲线的最小值（标有“x”）非常接近真实测试误差的最小值。</li>
</ul>
<p>这说明了 CV
的<em>原因</em>：它提供了可靠的估计值来指导我们选择模型（例如，逻辑回归的多项式次数为
3-4，KNN 的 <span class="math inline">\(K \approx 10\)</span>）。</p>
<h2 id="key-formulas-for-classification">Key Formulas for
Classification</h2>
<p>For regression, we often use Mean Squared Error (MSE). For
classification, the slides introduce the <strong>classification error
rate</strong>.</p>
<p>For Leave-One-Out Cross-Validation (LOOCV), the error for a single
observation <span class="math inline">\(i\)</span> is: <span
class="math display">\[Err_i = I(y_i \neq \hat{y}_i^{(i)})\]</span> *
<span class="math inline">\(y_i\)</span> is the true label for
observation <span class="math inline">\(i\)</span>. * <span
class="math inline">\(\hat{y}_i^{(i)}\)</span> is the model’s prediction
for observation <span class="math inline">\(i\)</span> when the model
was trained on all <em>other</em> observations <em>except</em> <span
class="math inline">\(i\)</span>. * <span
class="math inline">\(I(\dots)\)</span> is an <strong>indicator
function</strong>: it’s <span class="math inline">\(1\)</span> if the
condition is true (prediction is wrong) and <span
class="math inline">\(0\)</span> if false (prediction is correct).</p>
<p>The total <strong>CV error</strong> is simply the average of these
individual errors, which is the overall fraction of incorrect
classifications: <span class="math display">\[CV_{(n)} = \frac{1}{n}
\sum_{i=1}^{n} Err_i\]</span> The slides also show examples using
<strong>Log Loss</strong> (Slide 64), which is another common and
sensitive metric for classification. The logistic regression model
itself is defined by: <span class="math display">\[P(Y=1 | X) =
\frac{1}{1 + \exp(-\beta_0 - \beta_1 X_1 - \beta_2 X_2 -
\dots)}\]</span></p>
<p>对于回归，我们通常使用均方误差
(MSE)。对于分类，幻灯片介绍了<strong>分类错误率</strong>。</p>
<p>对于留一交叉验证 (LOOCV)，单个观测值 <span
class="math inline">\(i\)</span> 的误差为： <span
class="math display">\[Err_i = I(y_i \neq \hat{y}_i^{(i)})\]</span> *
<span class="math inline">\(y_i\)</span> 是观测值 <span
class="math inline">\(i\)</span> 的真实标签。 * <span
class="math inline">\(\hat{y}_i^{(i)}\)</span> 是模型在除 <span
class="math inline">\(i\)</span>
之外的所有其他观测值上进行训练后，对观测值 <span
class="math inline">\(i\)</span> 的预测。 * <span
class="math inline">\(I(\dots)\)</span>
是一个<strong>指示函数</strong>：如果条件为真（预测错误），则为 <span
class="math inline">\(1\)</span>；如果条件为假（预测正确），则为 <span
class="math inline">\(0\)</span>。</p>
<p>总<strong>CV误差</strong>只是这些单个误差的平均值，也就是错误分类的总体比例：
<span class="math display">\[CV_{(n)} = \frac{1}{n} \sum_{i=1}^{n}
Err_i\]</span>
幻灯片还展示了使用<strong>对数损失</strong>（幻灯片64）的示例，这是另一个常见且敏感的分类指标。逻辑回归模型本身的定义如下：
<span class="math display">\[P(Y=1 | X) = \frac{1}{1 + \exp(-\beta_0 -
\beta_1 X_1 - \beta_2 X_2 - \dots)}\]</span></p>
<h2 id="python-code-explained">Python Code Explained 🐍</h2>
<p>The slides provide two key Python examples. Both manually implement
K-fold cross-validation to show how it works.</p>
<h3 id="knn-regression-slide-52-knn-回归">1. KNN Regression (Slide 52)
KNN 回归</h3>
<ul>
<li><strong>Goal:</strong> Find the best <code>n_neighbors</code> (K)
for a <code>KNeighborsRegressor</code>. 为
<code>KNeighborsRegressor</code> 找到最佳的 <code>n_neighbors</code>
(K)。</li>
<li><strong>Logic:</strong>
<ol type="1">
<li>It creates a <code>KFold</code> object to split the data into 10
folds (<code>n_splits=10</code>). 创建一个 <code>KFold</code>
对象，将数据拆分成 10 个折叠（<code>n_splits=10</code>）。</li>
<li>It has an <strong>outer loop</strong> that iterates through
different values of <span class="math inline">\(K\)</span> (from 1 to
10). 它有一个 <strong>外循环</strong>，迭代不同的 <span
class="math inline">\(K\)</span> 值（从 1 到 10）。</li>
<li>It has an <strong>inner loop</strong> that iterates through the 10
folds (<code>for train_index, test_index in kfold.split(X)</code>).
它有一个 <strong>内循环</strong>，迭代这 10
个折叠（<code>for train_index, test_index in kfold.split(X)</code>）。</li>
<li><strong>Inside the inner loop:</strong>
<ul>
<li>It trains a <code>KNeighborsRegressor</code> on the 9 training folds
(<code>X_train</code>, <code>y_train</code>).</li>
<li>It makes predictions on the 1 held-out test fold
(<code>X_test</code>).</li>
<li>It calculates the mean squared error for that fold and stores
it.</li>
<li>在 9 个训练折叠（<code>X_train</code>, <code>y_train</code>）上训练
<code>KNeighborsRegressor</code>。</li>
<li>它对第一个保留的测试集 (<code>X_test</code>) 进行预测。</li>
<li>它计算该集的均方误差并存储。</li>
</ul></li>
<li><strong>After the inner loop:</strong> It averages the 10 error
scores (one from each fold) to get the final CV error for that specific
<span class="math inline">\(K\)</span>. 对 10
个误差分数（每个集一个）求平均值，得到该特定 <span
class="math inline">\(K\)</span> 的最终 CV 误差。</li>
<li>The final plot shows this CV error vs. <span
class="math inline">\(K\)</span>, allowing us to pick the <span
class="math inline">\(K\)</span> with the lowest error. 最终图表显示了
CV 误差与 <span class="math inline">\(K\)</span>
的关系，使我们能够选择误差最小的 <span
class="math inline">\(K\)</span>。</li>
</ol></li>
</ul>
<h3
id="logistic-regression-with-polynomials-slide-64-使用多项式的逻辑回归">2.
Logistic Regression with Polynomials (Slide 64)
使用多项式的逻辑回归</h3>
<ul>
<li><strong>Goal:</strong> Find the best <code>degree</code> for
<code>PolynomialFeatures</code> used with
<code>LogisticRegression</code>.</li>
<li><strong>Logic:</strong> This is very similar to the KNN example but
uses a different model and error metric.
<ol type="1">
<li>It sets up a 10-fold split (<code>kf = KFold(...)</code>).</li>
<li>An <strong>outer loop</strong> iterates through the
<code>degree</code> <span class="math inline">\(d\)</span> (from 1 to
10).</li>
<li>An <strong>inner loop</strong> iterates through the 10 folds.</li>
<li><strong>Inside the inner loop:</strong>
<ul>
<li>It creates <code>PolynomialFeatures</code> of degree <span
class="math inline">\(d\)</span>.</li>
<li>It transforms the 9 training folds (<code>X_train</code>) into
polynomial features (<code>X_train_poly</code>).</li>
<li>It trains a <code>LogisticRegression</code> model on
<code>X_train_poly</code>.</li>
<li>It transforms the 1 held-out test fold (<code>X_test</code>) using
the <em>same</em> polynomial transformer.</li>
<li>It calculates the <code>log_loss</code> on the test fold.</li>
</ul></li>
<li><strong>After the inner loop:</strong> It averages the 10
<code>log_loss</code> scores to get the final CV error for that
<code>degree</code>.</li>
<li>The plot shows CV error vs. degree, and the minimum is clearly at
<code>degree=3</code>.</li>
</ol></li>
</ul>
<h2 id="the-bias-variance-trade-off-in-cv-cv-中的偏差-方差权衡">The
Bias-Variance Trade-off in CV CV 中的偏差-方差权衡</h2>
<p>This is a key theoretical point from <strong>Slide 54</strong> that
answers the questions on Slide 65. It compares LOOCV (<span
class="math inline">\(K=n\)</span>) with K-fold CV (<span
class="math inline">\(K=5\)</span> or <span
class="math inline">\(10\)</span>). 这是<strong>幻灯片
54</strong>中的一个关键理论点，它回答了幻灯片 65 中的问题。它比较了
LOOCV（K=n）和 K 倍 CV（K=5 或 10）。</p>
<ul>
<li><strong>LOOCV (K=n):</strong>
<ul>
<li><strong>Bias:</strong> Very <strong>low</strong>. The model is
trained on <span class="math inline">\(n-1\)</span> samples, which is
almost the full dataset. The resulting error estimate is nearly unbiased
for the true test error. 该模型基于 <span
class="math inline">\(n-1\)</span>
个样本进行训练，这几乎是整个数据集。得到的误差估计对于真实测试误差几乎没有偏差。</li>
<li><strong>Variance:</strong> Very <strong>high</strong>. You are
training <span class="math inline">\(n\)</span> models that are
<em>almost identical</em> to each other (they only differ by one data
point). Averaging these highly correlated error estimates doesn’t reduce
the variance much, making the CV estimate unstable.
非常<strong>高</strong>。您正在训练 <span
class="math inline">\(n\)</span>
个彼此<em>几乎相同</em>的模型（它们仅相差一个数据点）。对这些高度相关的误差估计求平均值并不能显著降低方差，从而导致
CV 估计不稳定。</li>
</ul></li>
<li><strong>K-Fold CV (K=5 or 10):</strong>
<ul>
<li><strong>Bias:</strong> Slightly <strong>higher</strong> than LOOCV.
The models are trained on, for example, 90% of the data. Since they are
trained on less data, they <em>might</em> perform slightly worse. This
means K-fold CV <strong>tends to slightly overestimate the true test
error</strong> (Slide 66).</li>
<li><strong>Variance:</strong> Much <strong>lower</strong> than LOOCV.
The 10 models are trained on more different “chunks” of data (they
overlap less), so their error estimates are less correlated. Averaging
less-correlated estimates significantly reduces the overall
variance.</li>
</ul></li>
</ul>
<p><strong>Conclusion:</strong> We generally prefer <strong>10-fold
CV</strong> over LOOCV. It gives a much more stable (low-variance)
estimate of the test error, even if it’s slightly more biased
(overestimating the error, which is a safe/conservative estimate).
我们通常更喜欢<strong>10 倍交叉验证</strong>而不是
LOOCV。它能给出更稳定（低方差）的测试误差估计值，即使它的偏差略大（高估了误差，这是一个安全/保守的估计值）。</p>
<h2 id="the-core-problem-scenarios-slides-47-51">The Core Problem &amp;
Scenarios (Slides 47-51)</h2>
<p>These slides use three scenarios to show <em>why</em> we need
cross-validation (CV). The goal is to pick the right level of
<strong>model flexibility</strong> (e.g., the degree of a polynomial or
the complexity of a spline) to minimize the <strong>Test MSE</strong>
(Mean Squared Error), which we can’t see in real life.
这些幻灯片使用了三种场景来说明为什么我们需要交叉验证
(CV)。目标是选择合适的<strong>模型灵活性</strong>（例如，多项式的次数或样条函数的复杂度），以最小化<strong>测试均方误差</strong>（Mean
Squared Error），而这在现实生活中是无法观察到的。</p>
<ul>
<li><p><strong>The Curves (Slide 47):</strong> This slide is
central.</p>
<ul>
<li><p><strong>True Test MSE (Blue) 真实测试均方误差（蓝色）:</strong>
This is the <em>real</em> error on new data. It has a
<strong>U-shape</strong>. Error is high for simple models (high bias),
drops as the model fits the data, and rises again for overly complex
models (high variance, or overfitting).
<strong>这是新数据的<em>真实</em>误差。它呈</strong>U
形**。对于简单模型（高偏差），误差较高；随着模型拟合数据的深入，误差会下降；对于过于复杂的模型（高方差或过拟合），误差会再次上升。</p></li>
<li><p><strong>LOOCV (Black Dashed) &amp; 10-Fold CV (Orange)
LOOCV（黑色虚线）和 10 倍 CV（橙色）:</strong> These are our
<em>estimates</em> of the true test MSE. Notice how closely they track
the blue curve. The ‘x’ marks the minimum of the CV curve, which is our
<em>best guess</em> for the model with the minimum test MSE.
这些是我们对真实测试 MSE
的<em>估计</em>。请注意它们与蓝色曲线的吻合程度。“x”标记 CV
曲线的最小值，这是我们对具有最小测试 MSE
的模型的<em>最佳猜测</em>。</p></li>
</ul></li>
<li><p><strong>Scenario 1 (Slide 48):</strong> The true relationship is
non-linear. The right-hand plot shows that the test MSE (red curve) is
high for the simple linear model (blue square), but lower for the more
flexible smoothing splines (teal squares). CV helps us find the “sweet
spot.”
真实的关系是非线性的。右侧图表显示，对于简单的线性模型（蓝色方块），测试
MSE（红色曲线）较高，而对于更灵活的平滑样条函数（蓝绿色方块），测试 MSE
较低。CV 帮助我们找到“最佳点”。</p></li>
<li><p><strong>Scenario 2 (Slide 49):</strong> The true relationship is
<strong>linear</strong>. Here, the test MSE (red curve) is
<em>lowest</em> for the simplest model (the linear one, blue square). CV
correctly identifies this, and its error estimate (blue square) is
lowest for that model.
真实的关系是<strong>线性</strong>的。在这里，对于最简单的模型（线性模型，蓝色方块），测试
MSE（红色曲线）<em>最低</em>。CV
正确地识别了这一点，并且其误差估计（蓝色方块）是该模型中最低的。</p></li>
<li><p><strong>Scenario 3 (Slide 50):</strong> The true relationship is
<strong>highly non-linear</strong>. The linear model (orange) is a very
poor fit. The test MSE (red curve) is minimized by the most flexible
model (teal square). CV again finds this.
真实的关系是<strong>高度非线性</strong>的。线性模型（橙色）拟合度很差。测试
MSE（红色曲线）被最灵活的模型（蓝绿色方块）最小化。CV
再次发现了这一点。</p></li>
<li><p><strong>Key Takeaway (Slide 51):</strong> We use CV to find the
<strong>tuning parameter</strong> (like polynomial degree) that
minimizes the test error. We care less about the <em>actual value</em>
of the CV error and more about <em>where its minimum is</em>. 我们使用
CV
来找到最小化测试误差的<strong>调整参数</strong>（例如多项式次数）。我们不太关心
CV 误差的<em>实际值</em>，而更关心<em>它的最小值</em>。</p></li>
</ul>
<h2 id="cv-for-classification-slides-55-61">CV for Classification
(Slides 55-61)</h2>
<p>This section shifts from regression (predicting a number, using MSE)
to classification (predicting a category, like “blue” or “orange”).
本节从回归（使用 MSE
预测数字）转向分类（预测类别，例如“蓝色”或“橙色”）。</p>
<ul>
<li><strong>New Error Metric (Slide 55):</strong> We can’t use MSE. A
natural choice is the <strong>classification error rate</strong>.
我们不能使用 MSE。一个自然的选择是<strong>分类错误率</strong>。
<ul>
<li><span class="math inline">\(Err_i = I(y_i \neq
\hat{y}_i^{(i)})\)</span></li>
<li>This is an <strong>indicator function</strong>: it is
<strong>1</strong> if the prediction for the <span
class="math inline">\(i\)</span>-th data point (when trained
<em>without</em> it) is wrong, and <strong>0</strong> if it’s correct.
如果对第 <span class="math inline">\(i\)</span>
个数据点的预测（在没有它的情况下训练时）错误，则为
<strong>1</strong>；如果正确，则为 <strong>0</strong>。</li>
<li>The final CV error is just the average of these 0s and 1s, giving
the total fraction of misclassified points: <span
class="math inline">\(CV_{(n)} = \frac{1}{n} \sum_{i=1}^{n}
Err_i\)</span> 最终的 CV 误差就是这些 0 和 1
的平均值，即错误分类点的总比例：<span class="math inline">\(CV_{(n)} =
\frac{1}{n} \sum_{i=1}^{n} Err_i\)</span></li>
</ul></li>
<li><strong>The Example (Slides 56-61):</strong>
<ul>
<li><strong>Slides 56-58:</strong> We are shown a “true” (but unknown)
non-linear boundary (purple dashed line) separating two classes. We then
try to <em>estimate</em> this boundary using logistic regression with
different polynomial degrees (degree 1, 2, 3, 4).
我们看到了一条“真实”（但未知）的非线性边界（紫色虚线），它将两个类别分开。然后，我们尝试使用不同次数（1、2、3、4
次）的逻辑回归来<em>估计</em>这条边界。</li>
<li><strong>Slides 59-60:</strong> This is a crucial point. In this
<em>simulated</em> example, we <em>do</em> know the true test error
rates. The true errors are [0.201, 0.197, <strong>0.160</strong>,
0.162]. The lowest error is for the 3rd-degree polynomial. But in a
real-world problem, <strong>we can never know these true
errors</strong>.
这一点至关重要。在这个<em>模拟</em>示例中，我们<em>确实</em>知道真实的测试错误率。真实误差为
[0.201, 0.197, <strong>0.160</strong>,
0.162]。最小误差出现在三次多项式中。但在实际问题中，<strong>我们永远无法知道这些真实误差</strong>。</li>
<li><strong>Slide 61 (The Solution):</strong> This is the most important
image. It shows how CV <em>solves</em> the problem from slide 60.展示了
CV 如何<em>解决</em>幻灯片 60 中的问题。
<ul>
<li><p><strong>Brown Curve (Test Error):</strong> This is the
<em>true</em> test error (from slide 59). We can’t see this in practice.
Its minimum is at degree 3. 这是<em>真实</em>的测试误差（来自幻灯片
59）。我们在实践中看不到它。它的最小值在 3 次方处。</p></li>
<li><p><strong>Black Curve (10-fold CV Error):</strong> This is what we
<em>can</em> calculate. It’s our estimate of the test error.
<strong>Crucially, its minimum is also at degree 3.</strong></p></li>
<li><p><strong>黑色曲线（10 倍 CV
误差）：</strong>这是我们<em>可以</em>计算出来的。这是我们对测试误差的估计。<strong>至关重要的是，它的最小值也在
3 次方处。</strong></p></li>
<li><p>This proves that CV successfully found the best model (degree 3)
without ever seeing the <em>true</em> test error. The same logic is
shown for the KNN classifier on the right.</p></li>
<li><p>这证明 CV 成功地找到了最佳模型（3
次方），而从未看到<em>真实</em>的测试误差。右侧的 KNN
分类器也显示了相同的逻辑。</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="python-code-explained-slides-52-63-64">Python Code Explained
(Slides 52, 63, 64)</h2>
<p>The slides show how to <em>manually</em> implement K-fold CV. This is
great for understanding, even though libraries like
<code>GridSearchCV</code> can do this automatically.</p>
<ul>
<li><strong>KNN Regression (Slide 52):</strong>
<ol type="1">
<li><code>kfold = KFold(n_splits=10, ...)</code>: Creates an object that
knows how to split the data into 10 folds.</li>
<li><code>for n_k in neighbors:</code>: This is the <strong>outer
loop</strong> to test different <span class="math inline">\(K\)</span>
values (e.g., <span class="math inline">\(K\)</span>=1, 2, 3…).</li>
<li><code>for train_index, test_index in kfold.split(X):</code>: This is
the <strong>inner loop</strong>. For a <em>single</em> <span
class="math inline">\(K\)</span>, it loops 10 times.</li>
<li>Inside the inner loop:
<ul>
<li>It splits the data into a 9-fold training set (<code>X_train</code>)
and a 1-fold test set (<code>X_test</code>).</li>
<li>It trains a <code>KNeighborsRegressor</code> on
<code>X_train</code>.</li>
<li>It makes predictions on <code>X_test</code> and calculates the error
(<code>mean_squared_error</code>).</li>
</ul></li>
<li><code>cv_errors.append(np.mean(mse_errors_k))</code>: After the
inner loop finishes 10 runs, it averages the 10 error scores for that
<span class="math inline">\(K\)</span> and stores it.</li>
<li>The final plot shows <code>cv_errors</code>
vs. <code>neighbors</code>, letting you pick the <span
class="math inline">\(K\)</span> with the lowest average error.</li>
</ol></li>
<li><strong>Logistic Regression Classification (Slides 63-64):</strong>
<ul>
<li>This code is almost identical, but with three key differences:
<ol type="1">
<li>The model is <code>LogisticRegression</code>.</li>
<li>It uses <code>PolynomialFeatures</code> to create new features
(<span class="math inline">\(X^2, X^3,\)</span> etc.) <em>inside</em>
the loop.</li>
<li>The error metric is <code>log_loss</code> (a common, more sensitive
metric than the simple 0/1 error rate).</li>
</ol></li>
<li>The plot on slide 64 shows the 10-fold CV error (using Log Loss)
vs. the Degree of the Polynomial. The minimum is clearly at
<strong>Degree = 3</strong>, matching the finding from slide 61.</li>
</ul></li>
</ul>
<h2 id="answering-the-key-questions-slides-54-65">Answering the Key
Questions (Slides 54 &amp; 65)</h2>
<p>Slide 65 asks two critical questions, which are answered directly by
the concepts on <strong>Slide 54 (Bias and variance
trade-off)</strong>.</p>
<h3 id="q1-how-does-k-affect-the-bias-and-variance-of-the-cv-error">Q1:
How does K affect the bias and variance of the CV error?</h3>
<p>This refers to <span class="math inline">\(K\)</span> in K-fold CV
(not to be confused with <span class="math inline">\(K\)</span> in KNN).
K 如何影响 CV 误差的偏差和方差？</p>
<ul>
<li><strong>Bias:</strong>
<ul>
<li><p><strong>LOOCV (K = n):</strong> This has <strong>very low
bias</strong>. The model is trained on <span
class="math inline">\(n-1\)</span> samples, which is <em>almost</em> the
full dataset. So, the error estimate <span
class="math inline">\(CV_{(n)}\)</span> is an almost-unbiased estimate
of the true test error. ** 它的<strong>偏差非常低</strong>。该模型基于
<span class="math inline">\(n-1\)</span>
个样本进行训练，这几乎是整个数据集。因此，误差估计 <span
class="math inline">\(CV_{(n)}\)</span>
是对真实测试误差的几乎无偏估计。</p></li>
<li><p><strong>K-Fold (K &lt; n, e.g., K=10):</strong> This has
<strong>slightly higher bias</strong>. The models are trained on, for
example, 90% of the data. Because they are trained on less data, they
<em>might</em> perform slightly worse than a model trained on 100% of
the data. This “pessimism” is the source of the bias.
<strong>偏差略高</strong>。例如，这些模型是基于 90%
的数据进行训练的。由于它们基于较少的数据进行训练，因此它们的性能<em>可能</em>会比基于
100% 数据进行训练的模型略差。这种“悲观”正是偏差的根源。</p></li>
</ul></li>
<li><strong>Variance:</strong>
<ul>
<li><p><strong>LOOCV (K = n):</strong> This has <strong>very high
variance</strong>. You are training <span
class="math inline">\(n\)</span> models that are <em>almost
identical</em> (they only differ by one data point). Averaging <span
class="math inline">\(n\)</span> highly-correlated error estimates
doesn’t reduce the variance much. This makes the final <span
class="math inline">\(CV_{(n)}\)</span> estimate unstable.
<strong>这种模型的方差</strong>非常高**。您正在训练 <span
class="math inline">\(n\)</span>
个<em>几乎相同</em>的模型（它们只有一个数据点不同）。对 <span
class="math inline">\(n\)</span>
个高度相关的误差估计取平均值并不能显著降低方差。这使得最终的 <span
class="math inline">\(CV_{(n)}\)</span> 估计值不稳定。</p></li>
<li><p><strong>K-Fold (K &lt; n, e.g., K=10):</strong> This has
<strong>much lower variance</strong>. The 10 models are trained on more
different “chunks” of data (they overlap less). Their error estimates
are less correlated, and averaging 10 less-correlated numbers gives a
much more stable (low-variance) final estimate.
<strong>这种模型的方差</strong>非常低**。这 10
个模型基于更多不同的数据“块”进行训练（它们重叠较少）。它们的误差估计值相关性较低，对
10
个相关性较低的数取平均值可以得到更稳定（低方差）的最终估计值。</p></li>
</ul></li>
</ul>
<p><strong>Conclusion (The Trade-off):</strong> We prefer <strong>K-fold
CV (K=5 or 10)</strong> over LOOCV. It gives a much more stable
(low-variance) estimate, and we are willing to accept a tiny increase in
bias to get it. 我们更喜欢<strong>K 倍交叉验证（K=5 或
10）</strong>，而不是单倍交叉验证。它能给出更稳定（低方差）的估计值，并且我们愿意接受偏差的轻微增加来获得它。</p>
<h3
id="q2-does-cross-validation-over-estimate-or-under-estimate-the-true-test-error">Q2:
Does Cross Validation over-estimate or under-estimate the true test
error?</h3>
<p>交叉验证会高估还是低估真实测试误差？</p>
<p>Based on the bias discussion above:</p>
<p>Cross-validation (especially K-fold) generally <strong>over-estimates
the true test error</strong>. 交叉验证（尤其是 K
倍交叉验证）通常会<strong>高估真实测试误差</strong>。</p>
<p><strong>Reasoning:</strong> 1. The “true test error” is the error of
a model trained on the <em>entire dataset</em> (<span
class="math inline">\(n\)</span> samples). 2. K-fold CV trains its
models on <em>subsets</em> of the data (e.g., <span
class="math inline">\(n \times (K-1)/K\)</span> samples). 3. Since these
models are trained on <em>less</em> data, they are (on average) slightly
worse than the final model trained on all the data. 4. Because the CV
models are slightly worse, their error rates will be slightly
<em>higher</em>. 5. Therefore, the final CV error score is a slightly
“pessimistic” or high estimate. This is considered a good thing, as it’s
a <em>conservative</em> estimate of how our model will perform.
<strong>理由：</strong> 1.
“真实测试误差”是指在<em>整个数据集</em>（<span
class="math inline">\(n\)</span> 个样本）上训练的模型的误差。 2. K
折交叉验证 (K-fold CV) 在数据<em>子集</em>上训练其模型（例如，<span
class="math inline">\(n \times (K-1)/K\)</span> 个样本）。 3.
由于这些模型基于<em>较少</em>的数据进行训练，因此它们（平均而言）比基于所有数据训练的最终模型略差。
4. 由于 CV 模型略差，其错误率会略高<em>。 5. 因此，最终的 CV
错误率是一个略微“悲观”或偏高的估计。这被认为是一件好事，因为它是对模型性能的</em>保守*估计。</p>
<h1 id="summary-of-bootstrap">6. Summary of Bootstrap</h1>
<p>Bootstrap is a <strong>resampling technique</strong> used to estimate
the <strong>uncertainty</strong> (like standard error or confidence
intervals) of a statistic. Its key idea is to <strong>treat your
original data sample as a proxy for the true population</strong>. It
then simulates the process of drawing new samples by instead
<strong>sampling <em>with replacement</em></strong> from your original
sample. Bootstrap
是一种<strong>重采样技术</strong>，用于估计统计数据的<strong>不确定性</strong>（例如标准误差或置信区间）。其核心思想是<strong>将原始数据样本视为真实总体的替代样本</strong>。然后，它通过从原始样本中进行<strong>有放回的</strong>抽样来模拟抽取新样本的过程。</p>
<h3 id="the-problem">The Problem</h3>
<p>You have a single data sample (e.g., <span
class="math inline">\(n=100\)</span> people) and you calculate a
statistic, like the sample mean (<span
class="math inline">\(\bar{x}\)</span>) or a regression coefficient
(<span class="math inline">\(\hat{\beta}\)</span>). You want to know how
<em>accurate</em> this statistic is. How much would it vary if you could
repeat your experiment many times? This variation is measured by the
<strong>standard error (SE)</strong>. 您有一个数据样本（例如，<span
class="math inline">\(n=100\)</span>
人），并计算一个统计数据，例如样本均值 (<span
class="math inline">\(\bar{x}\)</span>) 或回归系数 (<span
class="math inline">\(\hat{\beta}\)</span>)。您想知道这个统计数据的<em>准确度</em>。如果可以多次重复实验，它会有多少变化？这种变化可以用<strong>标准误差
(SE)</strong> 来衡量。</p>
<h3 id="the-bootstrap-solution">The Bootstrap Solution</h3>
<p>Since you can’t re-run the whole experiment, you <em>simulate</em> it
using the one sample you have.
由于您无法重新运行整个实验，因此您可以使用现有的一个样本进行“模拟”。</p>
<p><strong>The Process:</strong> 1. <strong>Original Sample (<span
class="math inline">\(Z\)</span>) 原始样本 (<span
class="math inline">\(Z\)</span>):</strong> You have your one dataset
with <span class="math inline">\(n\)</span> observations. 2.
<strong>Bootstrap Sample (<span class="math inline">\(Z^{*1}\)</span>)
Bootstrap 样本 (<span class="math inline">\(Z^{*1}\)</span>):</strong>
Create a <em>new</em> dataset of size <span
class="math inline">\(n\)</span> by randomly pulling observations from
your original sample <em>with replacement</em>. (This means some
original observations will be picked multiple times, and some not at
all). 3. <strong>Calculate Statistic (<span
class="math inline">\(\hat{\theta}^{*1}\)</span>) 计算统计量 (<span
class="math inline">\(\hat{\theta}^{*1}\)</span>):</strong> Calculate
your statistic of interest (e.g., the mean, <span
class="math inline">\(\hat{\alpha}\)</span>, regression coefficients) on
this new bootstrap sample. 4. <strong>Repeat 重复:</strong> Repeat steps
2 and 3 a large number of times (<span class="math inline">\(B\)</span>,
e.g., <span class="math inline">\(B=1000\)</span>). This gives you <span
class="math inline">\(B\)</span> bootstrap statistics: <span
class="math inline">\(\hat{\theta}^{*1}, \hat{\theta}^{*2}, ...,
\hat{\theta}^{*B}\)</span>. 5. <strong>Analyze the Bootstrap
Distribution 分析自举分布:</strong> This collection of <span
class="math inline">\(B\)</span> statistics is your “bootstrap
distribution.” * <strong>Standard Error 标准误差:</strong> The
<strong>standard deviation</strong> of this bootstrap distribution is
your estimate of the <strong>standard error</strong> of your original
statistic. * <strong>Confidence Interval 置信区间:</strong> A 95%
confidence interval can be found by taking the <strong>2.5th and 97.5th
percentiles</strong> of this bootstrap distribution.</p>
<p><strong>Why use it?</strong> It’s powerful because it doesn’t rely on
strong theoretical assumptions (like data being normally distributed).
It can be applied to almost <em>any</em> statistic, even very complex
ones (like the prediction from a KNN model), for which a simple
mathematical formula for standard error doesn’t exist.
它非常强大，因为它不依赖于严格的理论假设（例如数据服从正态分布）。它几乎可以应用于<em>任何</em>统计数据，即使是非常复杂的统计数据（例如
KNN 模型的预测），因为这些统计数据没有简单的标准误差数学公式。</p>
<h2 id="mathematical-understanding">Mathematical Understanding</h2>
<p>The core idea is to use the <strong>empirical distribution</strong>
(your sample) as an estimate for the true <strong>population
distribution</strong>.
其核心思想是使用<strong>经验分布</strong>（你的样本）来估计真实的<strong>总体分布</strong>。</p>
<h3 id="example-estimating-alpha">Example: Estimating <span
class="math inline">\(\alpha\)</span></h3>
<p>Your slides provide an example of finding the <span
class="math inline">\(\alpha\)</span> that minimizes the variance of a
portfolio, <span class="math inline">\(var(\alpha X +
(1-\alpha)Y)\)</span>. 用于计算使投资组合方差最小化的 <span
class="math inline">\(\alpha\)</span>，即 <span
class="math inline">\(var(\alpha X + (1-\alpha)Y)\)</span>。</p>
<ol type="1">
<li><p><strong>True Population Parameter (<span
class="math inline">\(\alpha\)</span>) 真实总体参数 (<span
class="math inline">\(\alpha\)</span>):</strong> The <em>true</em> <span
class="math inline">\(\alpha\)</span> is a function of the
<em>population</em> variances and covariance: <em>真实</em> <span
class="math inline">\(\alpha\)</span>
是<em>总体</em>方差和协方差的函数： <span class="math display">\[\alpha
= \frac{\sigma_Y^2 - \sigma_{XY}}{\sigma_X^2 + \sigma_Y^2 -
2\sigma_{XY}}\]</span> We can never know this value exactly unless we
know the entire population.
除非我们了解整个总体，否则我们永远无法准确知道这个值。</p></li>
<li><p><strong>Sample Statistic (<span
class="math inline">\(\hat{\alpha}\)</span>) 样本统计量 (<span
class="math inline">\(\hat{\alpha}\)</span>):</strong> We
<em>estimate</em> <span class="math inline">\(\alpha\)</span> using our
sample, creating the statistic <span
class="math inline">\(\hat{\alpha}\)</span> by plugging in our
<em>sample</em> variances and covariance: 我们使用样本<em>估计</em>
<span
class="math inline">\(\alpha\)</span>，通过代入<em>样本</em>方差和协方差来创建统计量
<span class="math inline">\(\hat{\alpha}\)</span>： <span
class="math display">\[\hat{\alpha} = \frac{\hat{\sigma}_Y^2 -
\hat{\sigma}_{XY}}{\hat{\sigma}_X^2 + \hat{\sigma}_Y^2 -
2\hat{\sigma}_{XY}}\]</span> This <span
class="math inline">\(\hat{\alpha}\)</span> is just <em>one number</em>
from our single sample. How confident are we in it? We need its standard
error, <span class="math inline">\(SE(\hat{\alpha})\)</span>. 这个 <span
class="math inline">\(\hat{\alpha}\)</span>
只是我们单个样本中的一个数字。我们对它的置信度有多高？我们需要它的标准误差，<span
class="math inline">\(SE(\hat{\alpha})\)</span>。</p></li>
<li><p><strong>Bootstrap Statistic (<span
class="math inline">\(\hat{\alpha}^*\)</span>) 自举统计量 (<span
class="math inline">\(\hat{\alpha}^*\)</span>):</strong> We apply the
bootstrap process:</p>
<ul>
<li>Create a bootstrap sample (by resampling with replacement).
创建一个自举样本（通过放回重采样）。</li>
<li>Calculate <span class="math inline">\(\hat{\alpha}^*\)</span> using
the sample (co)variances of this <em>new bootstrap sample</em>.
使用这个<em>新自举样本</em>的样本（协）方差计算 <span
class="math inline">\(\hat{\alpha}^*\)</span>。</li>
<li>Repeat <span class="math inline">\(B\)</span> times to get <span
class="math inline">\(B\)</span> values: <span
class="math inline">\(\hat{\alpha}^{*1}, \hat{\alpha}^{*2}, ...,
\hat{\alpha}^{*B}\)</span>. 重复 <span class="math inline">\(B\)</span>
次，得到 <span class="math inline">\(B\)</span> 个值：<span
class="math inline">\(\hat{\alpha}^{*1}, \hat{\alpha}^{*2}, ...,
\hat{\alpha}^{*B}\)</span>。</li>
</ul></li>
<li><p><strong>Estimating the Standard Error 估算标准误差:</strong> The
standard error of our original estimate <span
class="math inline">\(\hat{\alpha}\)</span> is <em>estimated</em> by the
standard deviation of all our bootstrap estimates: 我们原始估计值 <span
class="math inline">\(\hat{\alpha}\)</span>
的标准误差是通过所有自举估计值的标准差来“估算”的： <span
class="math display">\[SE_{boot}(\hat{\alpha}) = \sqrt{\frac{1}{B-1}
\sum_{j=1}^{B} (\hat{\alpha}^{*j} - \bar{\alpha}^*)^2}\]</span> where
<span class="math inline">\(\bar{\alpha}^*\)</span> is the average of
all <span class="math inline">\(B\)</span> bootstrap estimates. <span
class="math inline">\(\bar{\alpha}^*\)</span> 是所有 <span
class="math inline">\(B\)</span> 个自举估计值的平均值。</p></li>
</ol>
<p>The slides (p. 73, 77-78) show this visually. The “sampling from
population” histogram (left) is the <em>true</em> sampling distribution,
which we can only create in a simulation. The “Bootstrap” histogram
(right) is the bootstrap distribution created from <em>one</em> sample.
They look very similar, which shows the method works.
“从总体抽样”直方图（左图）是<em>真实</em>的抽样分布，我们只能在模拟中创建它。“自举”直方图（右图）是从<em>一个</em>样本创建的自举分布。它们看起来非常相似，这表明该方法有效。</p>
<h2 id="code-analysis">Code Analysis</h2>
<h3 id="r-alpha-example-slides-75-77">R: <span
class="math inline">\(\alpha\)</span> Example (Slides 75 &amp; 77)</h3>
<ul>
<li><strong>Slide 75 (<code>The R code</code>): This is a SIMULATION,
not Bootstrap.</strong>
<ul>
<li><code>for(i in 1:m)&#123;...&#125;</code>: This loop runs <code>m=1000</code>
times.</li>
<li><code>returns &lt;- rmvnorm(...)</code>: <strong>Inside the
loop,</strong> it draws a <em>brand new sample</em> from the <em>true
population</em> every time.</li>
<li><code>alpha[i] &lt;- ...</code>: It calculates <span
class="math inline">\(\hat{\alpha}\)</span> for each new sample.</li>
<li><strong>Purpose:</strong> This code shows the <em>true sampling
distribution</em> of <span class="math inline">\(\hat{\alpha}\)</span>
(the “Histogram of alpha”). You can only do this if you know the true
population, as in a simulation.</li>
</ul></li>
<li><strong>Slide 77 (<code>The R code</code>): This IS
Bootstrap.</strong>
<ul>
<li><code>returns &lt;- rmvnorm(...)</code>: <strong>Outside the
loop,</strong> this is done <em>only once</em> to get <em>one</em>
original sample.</li>
<li><code>for(i in 1:B)&#123;...&#125;</code>: This is the bootstrap loop.</li>
<li><code>sample(1:nrow(returns), n, replace = T)</code>: <strong>This
is the key line.</strong> It randomly selects row numbers <em>with
replacement</em> from the <em>single</em> <code>returns</code>
dataset.</li>
<li><code>returns_boot &lt;- returns[sample(...), ]</code>: This creates
the bootstrap sample.</li>
<li><code>alpha_bootstrap[i] &lt;- ...</code>: It calculates <span
class="math inline">\(\hat{\alpha}^*\)</span> on the
<code>returns_boot</code> sample.</li>
<li><strong>Purpose:</strong> This code generates the <em>bootstrap
distribution</em> (the “Bootstrap” histogram on slide 78) to
<em>estimate</em> the true sampling distribution.</li>
</ul></li>
</ul>
<h3 id="r-linear-regression-example-slides-79-81">R: Linear Regression
Example (Slides 79 &amp; 81)</h3>
<ul>
<li><strong>Slide 79:</strong>
<ul>
<li><code>boot.fn &lt;- function(data, index)&#123; ... &#125;</code>: Defines a
function that the <code>boot</code> package needs. It takes data and an
<code>index</code> vector.</li>
<li><code>lm(mpg~horsepower, data=data, subset=index)</code>: This is
the core. It fits a linear model <em>only</em> on the data points
specified by the <code>index</code>. The <code>boot</code> function will
automatically supply this <code>index</code> as a
resampled-with-replacement vector.</li>
<li><code>boot(Auto, boot.fn, R=1000)</code>: This runs the bootstrap.
It calls <code>boot.fn</code> 1000 times, each time with a new resampled
<code>index</code>, and collects the coefficients.</li>
</ul></li>
<li><strong>Slide 81:</strong>
<ul>
<li><code>summary(lm(...))</code>: Shows the standard output. The “Std.
Error” column (e.g., 0.860, 0.006) is calculated using <em>mathematical
theory</em>.</li>
<li><code>boot.res</code>: Shows the bootstrap output. The “std. error”
column (e.g., 0.841, 0.007) is the <strong>standard deviation of the
1000 bootstrap estimates</strong>.</li>
<li><strong>Main Point:</strong> The standard errors from the bootstrap
are very close to the theoretical ones. This confirms the uncertainty.
If the model assumptions were violated, the bootstrap SE would be more
trustworthy.</li>
<li>The histograms show the bootstrap distributions for the intercept
(<code>t1*</code>) and the slope (<code>t2*</code>). The arrows show the
95% percentile confidence interval.</li>
</ul></li>
</ul>
<h3 id="python-knn-regression-example-slide-80">Python: KNN Regression
Example (Slide 80)</h3>
<p>This shows how to get a confidence interval for a <em>single
prediction</em>.</p>
<ul>
<li><code>for i in range(n_bootstraps):</code>: The bootstrap loop.</li>
<li><code>indices = np.random.choice(train_samples.shape[0], train_samples.shape[0], replace=True)</code>:
<strong>This is the key line</strong> in Python (like
<code>sample</code> in R). It gets a new set of indices with
replacement.</li>
<li><code>X_boot, y_boot = ...</code>: Creates the bootstrap
sample.</li>
<li><code>model.fit(X_boot, y_boot)</code>: A <em>new</em> KNN model is
trained on this bootstrap sample.</li>
<li><code>bootstrap_preds.append(model.predict(predict_point))</code>:
The model (trained on <span class="math inline">\(Z^{*i}\)</span>) makes
a prediction for the <em>same</em> fixed point. This is repeated 1000
times.</li>
<li><strong>Result:</strong> You get a <em>distribution of
predictions</em> for that one point. The 2.5th and 97.5th percentiles of
this distribution give you a 95% confidence interval <em>for that
specific prediction</em>. 你会得到该点的<em>预测分布</em>。该分布的 2.5
和 97.5 百分位数为该特定预测提供了 95% 的置信区间。</li>
</ul>
<h3 id="python-knn-on-auto-data-slide-82">Python: KNN on Auto data
(Slide 82)</h3>
<ul>
<li><strong>BE CAREFUL:</strong> This slide <strong>does NOT show
Bootstrap</strong>. It shows <strong>K-Fold Cross-Validation
(CV)</strong>.</li>
<li><strong>Purpose:</strong> The goal here is <em>not</em> to find
uncertainty. The goal is to find the <strong>best
hyperparameter</strong> (the best value for <span
class="math inline">\(k\)</span>, the number of neighbors).</li>
<li><strong>Method:</strong>
<ul>
<li><code>kf = KFold(n_splits=10)</code>: Splits the data into 10 chunks
(“folds”).</li>
<li><code>for train_index, test_index in kf.split(X):</code>: It loops
10 times. Each time, it trains on 9 chunks and tests on 1 chunk.</li>
</ul></li>
<li><strong>Key Difference for Exam:</strong>
<ul>
<li><strong>Bootstrap:</strong> Samples <em>with replacement</em> to
estimate <strong>uncertainty/standard error</strong>.</li>
<li><strong>Cross-Validation:</strong> Splits data <em>without
replacement</em> into <span class="math inline">\(K\)</span> folds to
estimate model <strong>performance/prediction error</strong> and tune
hyperparameters.</li>
<li><strong>自举法</strong>：使用<em>有放回</em>的样本来估计<strong>不确定性/标准误差</strong>。</li>
<li><strong>交叉验证</strong>：将数据<em>无放回</em>地分成 <span
class="math inline">\(K\)</span>
份，以估计模型<strong>性能/预测误差</strong>并调整超参数。</li>
</ul></li>
</ul>
<h1
id="the-mathematical-theory-of-bootstrap-and-the-extension-to-cross-validation-cv.">7.
The mathematical theory of Bootstrap and the extension to
Cross-Validation (CV).</h1>
<h2 id="code-analysis-bootstrap-for-a-knn-prediction-slide-85">1. Code
Analysis: Bootstrap for a KNN Prediction (Slide 85)</h2>
<p>This Python code shows a different use of bootstrap: <strong>finding
the confidence interval for a single prediction</strong>, not for a
model coefficient.</p>
<ul>
<li><strong>Goal:</strong> To estimate the uncertainty of a KNN model’s
prediction for a <em>specific</em> new data point
(<code>predict_point</code>).</li>
<li><strong>Process:</strong>
<ol type="1">
<li><strong>Train Full Model:</strong> A KNN model (<code>knn</code>) is
first trained on the <em>entire</em> dataset. It makes one prediction
(<code>knpred</code>) for <code>predict_point</code>. This is our <span
class="math inline">\(\hat{f}(x_0)\)</span>.</li>
<li><strong>Bootstrap Loop
(<code>for i in range(n_bootstraps)</code>):</strong>
<ul>
<li><code>indices = np.random.choice(...)</code>: <strong>This is the
core bootstrap step.</strong> It creates a new list of indices by
sampling <em>with replacement</em> from the original data.</li>
<li><code>X_boot, y_boot = ...</code>: This creates the new bootstrap
dataset (<span class="math inline">\(Z^{*i}\)</span>).</li>
<li><code>km.fit(X_boot, y_boot)</code>: A <em>new</em> KNN model
(<code>km</code>) is trained <em>only</em> on this bootstrap
sample.</li>
<li><code>bootstrap_preds.append(km.predict(predict_point))</code>: This
newly trained model makes a prediction for the <em>same</em>
<code>predict_point</code>. This value is <span
class="math inline">\(\hat{f}^{*i}(x_0)\)</span>.</li>
</ul></li>
<li><strong>Analyze Distribution:</strong> After 1000 loops,
<code>bootstrap_preds</code> contains 1000 different predictions for the
same point.</li>
<li><strong>Confidence Interval:</strong>
<ul>
<li><code>np.percentile(bootstrap_preds, [2.5, 97.5])</code>: This finds
the 2.5th and 97.5th percentiles of the 1000 bootstrap predictions.</li>
<li>The resulting <code>[lower_bound, upper_bound]</code> (e.g.,
<code>[13.70, 15.70]</code>) forms the 95% confidence interval for the
prediction.</li>
</ul></li>
</ol></li>
<li><strong>Histogram Plot:</strong> The plot on the right visually
confirms this. It shows the distribution of the 1000 bootstrap
predictions, with the 95% confidence interval marked by the red dashed
lines.</li>
</ul>
<h2
id="mathematical-understanding-why-does-bootstrap-work-slides-87-88">2.
Mathematical Understanding: Why Does Bootstrap Work? (Slides 87-88)</h2>
<p>This is the theoretical justification for the entire method. It’s
based on an analogy. 这是整个方法的理论依据。它基于一个类比。</p>
<h3 id="the-true-world-slide-87-top">The “True” World (Slide 87,
Top)</h3>
<ul>
<li><p><strong>Population:</strong> There is a true, unknown population
distribution <span class="math inline">\(F\)</span>.
存在一个真实的、未知的总体分布 <span
class="math inline">\(F\)</span>。</p></li>
<li><p><strong>Parameter:</strong> We want to know a true parameter,
<span class="math inline">\(\theta\)</span>, which is a function of
<span class="math inline">\(F\)</span> (e.g., the true population mean).
我们想知道一个真实的参数 <span
class="math inline">\(\theta\)</span>，它是 <span
class="math inline">\(F\)</span>
的函数（例如，真实的总体均值）。</p></li>
<li><p><strong>Sample:</strong> We get <em>one</em> sample <span
class="math inline">\(X_1, ..., X_n\)</span> from <span
class="math inline">\(F\)</span>. 我们从 <span
class="math inline">\(F\)</span> 中获取<em>一个</em>样本 <span
class="math inline">\(X_1, ..., X_n\)</span>。</p></li>
<li><p><strong>Statistic:</strong> We calculate our best estimate <span
class="math inline">\(\hat{\theta}\)</span> from our sample. (e.g., the
sample mean <span class="math inline">\(\bar{x}\)</span>). <span
class="math inline">\(\hat{\theta}\)</span> is our proxy for <span
class="math inline">\(\theta\)</span>. 我们从样本中计算出最佳估计值
<span class="math inline">\(\hat{\theta}\)</span>。（例如，样本均值
<span class="math inline">\(\bar{x}\)</span>）。<span
class="math inline">\(\hat{\theta}\)</span> 是 <span
class="math inline">\(\theta\)</span> 的替代值。</p></li>
<li><p><strong>The Problem:</strong> We want to know the accuracy of
<span class="math inline">\(\hat{\theta}\)</span>. How much would <span
class="math inline">\(\hat{\theta}\)</span> vary if we could draw many
samples? We want the <em>sampling distribution</em> of <span
class="math inline">\(\hat{\theta}\)</span> around <span
class="math inline">\(\theta\)</span>, specifically the distribution of
the error: <span class="math inline">\((\hat{\theta} - \theta)\)</span>.
我们想知道 <span class="math inline">\(\hat{\theta}\)</span>
的准确率。如果我们可以抽取多个样本，<span
class="math inline">\(\hat{\theta}\)</span> 会有多少变化？我们想要 <span
class="math inline">\(\hat{\theta}\)</span> 围绕 <span
class="math inline">\(\theta\)</span> 的
<em>抽样分布</em>，具体来说是误差的分布：<span
class="math inline">\((\hat{\theta} - \theta)\)</span>。</p></li>
<li><p><strong>CLT:</strong> The Central Limit Theorem states that <span
class="math inline">\(\sqrt{n}(\hat{\theta} - \theta)
\xrightarrow{\text{dist}} N(0, Var_F(\theta))\)</span>.</p></li>
<li><p><strong>中心极限定理</strong>：<span
class="math inline">\(\sqrt{n}(\hat{\theta} - \theta)
\xrightarrow{\text{dist}} N(0, Var_F(\theta))\)</span>。</p></li>
<li><p><strong>The Catch:</strong> This is <strong>UNKNOWN</strong>
because we don’t know <span
class="math inline">\(F\)</span>.这是<strong>未知</strong>的，因为我们不知道
<span class="math inline">\(F\)</span>。</p></li>
</ul>
<h3 id="the-bootstrap-world-slide-87-bottom">The “Bootstrap” World
(Slide 87, Bottom)</h3>
<ul>
<li><strong>Population:</strong> We <em>pretend</em> our original sample
<em>is</em> the population. We call its distribution the “empirical
distribution,” <span class="math inline">\(\hat{F}_n\)</span>.
我们<em>假设</em>原始样本<em>就是</em>总体。我们称其分布为“经验分布”，即
<span class="math inline">\(\hat{F}_n\)</span>。</li>
<li><strong>Parameter:</strong> In this new world, the “true” parameter
is our original statistic, <span
class="math inline">\(\hat{\theta}\)</span> (which is a function of
<span class="math inline">\(\hat{F}_n\)</span>).
在这个新世界中，“真实”参数是我们原始的统计量 <span
class="math inline">\(\hat{\theta}\)</span>（它是 <span
class="math inline">\(\hat{F}_n\)</span> 的函数）。</li>
<li><strong>Sample:</strong> We draw <em>many</em> bootstrap samples
<span class="math inline">\(X_1^*, ..., X_n^*\)</span> <em>from <span
class="math inline">\(\hat{F}_n\)</span></em> (i.e., sampling <em>with
replacement</em> from our original sample). 我们从 <span
class="math inline">\(\hat{F}_n\)</span>* 中抽取 <em>许多</em> 自举样本
<span class="math inline">\(X_1^*, ...,
X_n^*\)</span>（即从原始样本中进行 <em>有放回</em> 抽样）。</li>
<li><strong>Statistic:</strong> From each bootstrap sample, we calculate
a <em>bootstrap statistic</em>, <span
class="math inline">\(\hat{\theta}^*\)</span>.
从每个自举样本中，我们计算一个 <em>自举统计量</em>，即 <span
class="math inline">\(\hat{\theta}^*\)</span>。</li>
<li><strong>The Solution:</strong> We can now <em>empirically</em> find
the distribution of <span class="math inline">\(\hat{\theta}^*\)</span>
around <span class="math inline">\(\hat{\theta}\)</span>. We look at the
distribution of the bootstrap error: <span
class="math inline">\((\hat{\theta}^* - \hat{\theta})\)</span>.
我们现在可以 <em>凭经验</em> 找到 <span
class="math inline">\(\hat{\theta}^*\)</span> 围绕 <span
class="math inline">\(\hat{\theta}\)</span>
的分布。我们来看看自举误差的分布：<span
class="math inline">\((\hat{\theta}^* - \hat{\theta})\)</span>。</li>
<li><strong>CLT:</strong> The CLT also states that <span
class="math inline">\(\sqrt{n}(\hat{\theta}^* - \hat{\theta})
\xrightarrow{\text{dist}} N(0, Var_{\hat{F}_n}(\theta))\)</span>.</li>
<li><strong>The Power:</strong> This distribution is
<strong>ESTIMABLE!</strong> We just run the bootstrap <span
class="math inline">\(B\)</span> times and we get <span
class="math inline">\(B\)</span> values of <span
class="math inline">\(\hat{\theta}^*\)</span>. We can then calculate
their variance, standard deviation, and percentiles directly.
这个分布是<strong>可估计的！</strong>我们只需运行 <span
class="math inline">\(B\)</span> 次自举程序，就能得到 <span
class="math inline">\(B\)</span> 个 <span
class="math inline">\(\hat{\theta}^*\)</span>
值。然后我们可以直接计算它们的方差、标准差和百分位数。</li>
</ul>
<h3 id="the-core-approximation-slide-88">The Core Approximation (Slide
88)</h3>
<p>The entire method relies on the assumption that <strong>the
(knowable) bootstrap distribution is a good approximation of the
(unknown) true sampling distribution.</strong>
整个方法依赖于以下假设：<strong>（已知的）自举分布能够很好地近似（未知的）真实抽样分布</strong>。</p>
<p>The distribution of the <em>bootstrap error</em> approximates the
distribution of the <em>true error</em>.
<em>自举误差</em>的分布近似于<em>真实误差</em>的分布。</p>
<p><span class="math display">\[\text{distribution of }
\sqrt{n}(\hat{\theta}^* - \hat{\theta}) \approx \text{distribution of }
\sqrt{n}(\hat{\theta} - \theta)\]</span></p>
<p>This is why: * The <strong>standard deviation</strong> of the <span
class="math inline">\(\hat{\theta}^*\)</span> values is our estimate for
the <strong>standard error</strong> of <span
class="math inline">\(\hat{\theta}\)</span>.
值的<strong>标准差</strong>是我们对 <span
class="math inline">\(\hat{\theta}\)</span>
的<strong>标准误差</strong>的估计值。 * The <strong>percentiles</strong>
of the <span class="math inline">\(\hat{\theta}^*\)</span> distribution
(e.g., 2.5th and 97.5th) can be used to build a <strong>confidence
interval</strong> for the true parameter <span
class="math inline">\(\theta\)</span>.
分布的<strong>百分位数</strong>（例如，第 2.5 个和第 97.5
个）可用于为真实参数 <span class="math inline">\(\theta\)</span>
建立<strong>置信区间</strong>。</p>
<h2 id="extension-cross-validation-cv-analysis">3. Extension:
Cross-Validation (CV) Analysis</h2>
<h3 id="cv-for-hyperparameter-tuning-slide-84-超参数调优的-cv">CV for
Hyperparameter Tuning (Slide 84) 超参数调优的 CV</h3>
<p>This plot is the <em>result</em> of the 10-fold CV code shown in the
previous set of slides (slide 82). * <strong>Purpose:</strong> To find
the optimal hyperparameter <span class="math inline">\(k\)</span>
(number of neighbors) for the KNN model. * <strong>X-axis:</strong>
Number of Neighbors (<span class="math inline">\(k\)</span>). *
<strong>Y-axis:</strong> CV Error (Mean Squared Error). *
<strong>Analysis:</strong> * <strong>Low <span
class="math inline">\(k\)</span> (e.g., <span class="math inline">\(k=1,
2\)</span>):</strong> High error. The model is too complex and
<strong>overfitting</strong> to the training data. * <strong>High <span
class="math inline">\(k\)</span> (e.g., <span
class="math inline">\(k&gt;40\)</span>):</strong> Error slowly
increases. The model is too simple and <strong>underfitting</strong>
(e.g., averaging too many neighbors). * <strong>Optimal <span
class="math inline">\(k\)</span>:</strong> The “sweet spot” is at the
bottom of the “U” shape, around <strong><span class="math inline">\(k
\approx 20-30\)</span></strong>, which gives the lowest CV error.</p>
<ul>
<li><strong>目的</strong>：为 KNN 模型找到最优超参数 <span
class="math inline">\(k\)</span>（邻居数）。</li>
<li><strong>X 轴：</strong>邻居数 (<span
class="math inline">\(k\)</span>)。</li>
<li><strong>Y 轴：</strong>CV 误差（均方误差）。</li>
<li><strong>分析</strong>：**</li>
<li><strong>低 <span class="math inline">\(k\)</span>（例如，<span
class="math inline">\(k=1,
2\)</span>）：</strong>误差较大。模型过于复杂，并且与训练数据<strong>过拟合</strong>。</li>
<li><strong>高 <span class="math inline">\(k\)</span>（例如，<span
class="math inline">\(k&gt;40\)</span>）：</strong>误差缓慢增加。模型过于简单且<strong>欠拟合</strong>（例如，对太多邻居进行平均）。</li>
<li><strong>最优 <span
class="math inline">\(k\)</span>：</strong>“最佳点”位于“U”形的底部，大约为<strong><span
class="math inline">\(k \approx 20-30\)</span></strong>，此时 CV
误差最低。</li>
</ul>
<h3 id="why-cv-over-estimates-test-error-slide-89">Why CV Over-Estimates
Test Error (Slide 89)</h3>
<p>This is a subtle but important theoretical point. * <strong>Our
Goal:</strong> We want to know the test error of our <em>final
model</em> (<span class="math inline">\(\hat{f}^{\text{full}}\)</span>),
which we will train on the <strong>full dataset</strong> (all <span
class="math inline">\(n\)</span> observations).
我们想知道<em>最终模型</em> (<span
class="math inline">\(\hat{f}^{\text{full}}\)</span>)
的测试误差，我们将在<strong>完整数据集</strong>（所有 <span
class="math inline">\(n\)</span> 个观测值）上训练该模型。 * <strong>What
CV Measures:</strong> <span class="math inline">\(k\)</span>-fold CV
does <em>not</em> test the final model. It tests <span
class="math inline">\(k\)</span> different models (<span
class="math inline">\(\hat{f}^{(k)}\)</span>), each trained on a
<em>smaller</em> dataset (of size <span
class="math inline">\(\frac{k-1}{k} \times n\)</span>). <span
class="math inline">\(k\)</span> 倍 CV <em>不</em>测试最终模型。它测试了
<span class="math inline">\(k\)</span> 个不同的模型 (<span
class="math inline">\(\hat{f}^{(k)}\)</span>)，每个模型都基于一个<em>较小</em>的数据集（大小为
<span class="math inline">\(\frac{k-1}{k} \times
n\)</span>）进行训练。</p>
<ul>
<li><strong>The Logic:</strong>
<ol type="1">
<li>Models trained on <em>less data</em> generally perform
<em>worse</em> than models trained on <em>more data</em>.
基于<em>较少数据</em>训练的模型通常比基于<em>较多数据</em>训练的模型表现<em>更差</em>。</li>
<li>The CV error is the average error of models trained on <span
class="math inline">\(\frac{k-1}{k} n\)</span> observations. CV
误差是使用 <span class="math inline">\(\frac{k-1}{k} n\)</span>
个观测值训练的模型的平均误差。</li>
<li>The “true test error” is the error of the model trained on <span
class="math inline">\(n\)</span> observations. “真实测试误差”是使用
<span class="math inline">\(n\)</span> 个观测值训练的模型的误差。</li>
</ol></li>
<li><strong>Conclusion:</strong> Since the CV models are trained on
smaller datasets, they will, on average, have a slightly higher error
than the final model. Therefore, <strong>the CV error score is a
slightly <em>pessimistic</em> estimate (it over-estimates) the true test
error of the final model.</strong> 由于 CV
模型是在较小的数据集上训练的，因此它们的平均误差会略高于最终模型。因此，<strong>CV
误差分数是一个略微<em>悲观</em>的估计（它高估了）最终模型的真实测试误差。</strong></li>
</ul>
<h3 id="correction-of-cv-error-slides-90-91">Correction of CV Error
(Slides 90-91)</h3>
<ul>
<li><p><strong>Theory (Slide 91):</strong> Advanced theory suggests the
expected test error <span class="math inline">\(R(n)\)</span> behaves
like <span class="math inline">\(R(n) = R^* + c/n\)</span>, where <span
class="math inline">\(R^*\)</span> is the irreducible error and <span
class="math inline">\(n\)</span> is the sample size. This formula
mathematically confirms that error <em>decreases</em> as sample size
<span class="math inline">\(n\)</span> <em>increases</em>.
高级理论表明，预期测试误差 <span class="math inline">\(R(n)\)</span>
的行为类似于 <span class="math inline">\(R(n) = R^* + c/n\)</span>，其中
<span class="math inline">\(R^*\)</span> 是不可约误差，<span
class="math inline">\(n\)</span>
是样本量。该公式从数学上证实了误差会随着样本量 <span
class="math inline">\(n\)</span> 的增加而<em>减小</em>。</p></li>
<li><p><strong>R Code (Slide 90):</strong> The <code>cv.glm</code>
function from the <code>boot</code> library automatically provides
this.</p>
<ul>
<li><code>cv.err$delta</code>: This output vector contains two
values.</li>
<li><code>[1] 24.23151</code> (Raw CV Error): This is the standard
Leave-One-Out CV (LOOCV) error.</li>
<li><code>[2] 24.23114</code> (Adjusted CV Error): This is a
bias-corrected estimate that accounts for the overestimation problem.
It’s slightly lower, representing a more accurate guess for the error of
the <em>final model</em> trained on all <span
class="math inline">\(n\)</span> data points.</li>
</ul></li>
</ul>
<p># The “Correction of CV Error” extension.</p>
<h3 id="summary">Summary</h3>
<p>This section provides a deeper mathematical look at <em>why</em>
k-fold cross-validation (CV) slightly <strong>over-estimates</strong>
the true test error. 本节从数学角度更深入地阐述了 <em>为什么</em> k
折交叉验证 (CV) 会略微<strong>高估</strong>真实测试误差。</p>
<ol type="1">
<li><p><strong>The Overestimation 高估:</strong> CV trains on <span
class="math inline">\(\frac{k-1}{k}\)</span> of the data, which is
<em>less</em> than the full dataset (size <span
class="math inline">\(n\)</span>). Models trained on less data are
generally <em>worse</em>. Therefore, the average error from CV (<span
class="math inline">\(CV_k\)</span>) is slightly <em>higher</em> (more
pessimistic) than the true error of the final model trained on all <span
class="math inline">\(n\)</span> data (<span
class="math inline">\(R(n)\)</span>). CV 训练的数据为 <span
class="math inline">\(\frac{k-1}{k}\)</span>，小于完整数据集（大小为
<span
class="math inline">\(n\)</span>）。使用较少数据训练的模型通常<em>更差</em>。因此，CV
的平均误差 (<span class="math inline">\(CV_k\)</span>)
略高于（更悲观地）基于所有 <span class="math inline">\(n\)</span>
个数据训练的最终模型的真实误差 (<span
class="math inline">\(R(n)\)</span>)。</p></li>
<li><p><strong>A Simple Correction 简单修正:</strong> A mathematical
formula, <span class="math inline">\(\tilde{CV_k} = \frac{k-1}{k} \cdot
CV_k\)</span>, is proposed to “correct” this overestimation.</p></li>
<li><p><strong>The Critical Flaw 关键缺陷:</strong> This correction is
derived <em>assuming</em> the <strong>irreducible error (<span
class="math inline">\(R^*\)</span>) is
zero</strong>.此修正是在<em>假设</em><strong>不可约误差 (<span
class="math inline">\(R^*\)</span>)
为零</strong>的情况下得出的。</p></li>
<li><p><strong>The Takeaway 要点 (Code Analysis):</strong> The Python
code demonstrates a real-world scenario where there is noise
(<code>noise_std = 0.5</code>), meaning <span class="math inline">\(R^*
&gt; 0\)</span>. In this case, the <strong>simple correction
fails</strong>—it produces an error (0.217) that is <em>less
accurate</em> and further from the true error (0.272) than the
<strong>original raw CV error</strong> (0.271).</p></li>
</ol>
<p>Python
代码演示了一个存在噪声（<code>noise_std = 0.5</code>）的真实场景，即
<span class="math inline">\(R^* &gt;
0\)</span>。在这种情况下，<strong>简单修正失败</strong>——它产生的误差
(0.217) <em>精度较低</em>，并且与真实误差 (0.272) 的距离比<strong>原始
CV 误差</strong> (0.271) 更远。</p>
<p><strong>Exam Conclusion:</strong> For most real-world problems (which
have noise), the <strong>raw <span class="math inline">\(k\)</span>-fold
CV error is a better and more reliable estimate</strong> of the true
test error than the simple (and flawed) correction.
对于大多数实际问题（包含噪声），<strong>原始 <span
class="math inline">\(k\)</span> 倍 CV
误差比简单（且有缺陷的）修正方法更能准确、可靠地估计真实测试误差</strong>。</p>
<h3 id="mathematical-understanding-1">Mathematical Understanding</h3>
<p>This section explains the theory of <em>why</em> <span
class="math inline">\(CV_k &gt; R(n)\)</span> and derives the simple
correction. 本节解释了为什么 <span class="math inline">\(CV_k &gt;
R(n)\)</span>，并推导出简单的修正方法。</p>
<ol type="1">
<li><p><strong>Assumed Error Behavior 假设误差行为:</strong> We assume
the test error <span class="math inline">\(R(n)\)</span> for a model
trained on <span class="math inline">\(n\)</span> data points behaves
like: 我们假设基于 <span class="math inline">\(n\)</span>
个数据点训练的模型的测试误差 <span class="math inline">\(R(n)\)</span>
的行为如下： <span class="math display">\[R(n) = R^* +
\frac{c}{n}\]</span></p>
<ul>
<li><span class="math inline">\(R^*\)</span>: The <strong>irreducible
error</strong> (the “noise floor” you can never beat).
<strong>不可约误差</strong>（即你永远无法克服的“本底噪声”）。</li>
<li><span class="math inline">\(c/n\)</span>: The model variance, which
<em>decreases</em> as sample size <span class="math inline">\(n\)</span>
<em>increases</em>. 模型方差，随着样本量 <span
class="math inline">\(n\)</span> 的增加而减小。</li>
</ul></li>
<li><p><strong>Test Error vs. CV Error 测试误差 vs. CV
误差:</strong></p>
<ul>
<li><strong>Test Error of Interest:</strong> This is the error of our
<em>final model</em> trained on all <span
class="math inline">\(n\)</span> points: <span
class="math display">\[R(n) = R^* + \frac{c}{n}\]</span></li>
<li><strong>感兴趣的测试误差</strong>：这是我们在所有 <span
class="math inline">\(n\)</span>
个点上训练的<em>最终模型</em>的误差：</li>
<li><strong>k-fold CV Error:</strong> This is the average error of <span
class="math inline">\(k\)</span> models, each trained on a smaller
sample of size <span class="math inline">\(n&#39; =
(\frac{k-1}{k})n\)</span>.</li>
<li><strong>k 倍 CV 误差</strong>：这是 <span
class="math inline">\(k\)</span>
个模型的平均误差，每个模型都使用一个较小的样本（大小为 <span
class="math inline">\(n&#39; = (\frac{k-1}{k})n\)</span>）进行训练。
<span class="math display">\[CV_k \approx R(n&#39;) =
R\left(\frac{k-1}{k}n\right) = R^* +
\frac{c}{\left(\frac{k-1}{k}\right)n} = R^* +
\frac{ck}{(k-1)n}\]</span></li>
</ul></li>
<li><p><strong>The Overestimation 高估:</strong> Let’s compare <span
class="math inline">\(CV_k\)</span> and <span
class="math inline">\(R(n)\)</span>: <span class="math display">\[CV_k
\approx R^* + \left(\frac{k}{k-1}\right) \frac{c}{n}\]</span> <span
class="math display">\[R(n) = R^* + \left(\frac{k-1}{k-1}\right)
\frac{c}{n}\]</span> Since <span class="math inline">\(k &gt;
(k-1)\)</span>, the factor <span
class="math inline">\(\left(\frac{k}{k-1}\right)\)</span> is
<strong>greater than 1</strong>. This means the <span
class="math inline">\(CV_k\)</span> error term is larger than the <span
class="math inline">\(R(n)\)</span> error term. Thus: <strong><span
class="math inline">\(CV_k &gt; \text{Test error of interest }
R(n)\)</span></strong> 由于 <span class="math inline">\(k &gt;
(k-1)\)</span>，因子 <span
class="math inline">\(\left(\frac{k}{k-1}\right)\)</span> <strong>大于
1</strong>。这意味着 <span class="math inline">\(CV_k\)</span>
误差项大于 <span class="math inline">\(R(n)\)</span> 误差项。因此：
<strong><span class="math inline">\(CV_k &gt; \text{目标测试误差 }
R(n)\)</span></strong></p></li>
<li><p><strong>Deriving the (Flawed) Correction
推导（有缺陷的）修正:</strong> This correction makes a <strong>strong
assumption: <span class="math inline">\(R^* \approx 0\)</span></strong>
(the model is perfectly specified, and there is no noise).
此修正基于一个<strong>强假设：<span class="math inline">\(R^* \approx
0\)</span></strong>（模型完全正确，且无噪声）。</p>
<ul>
<li>If <span class="math inline">\(R^* = 0\)</span>, then <span
class="math inline">\(R(n) \approx \frac{c}{n}\)</span></li>
<li>If <span class="math inline">\(R^* = 0\)</span>, then <span
class="math inline">\(CV_k \approx \frac{ck}{(k-1)n}\)</span></li>
</ul>
<p>Now, look at the ratio between them: <span
class="math display">\[\frac{R(n)}{CV_k} \approx \frac{c/n}{ck/((k-1)n)}
= \frac{c}{n} \cdot \frac{(k-1)n}{ck} = \frac{k-1}{k}\]</span></p>
<p>This gives us the correction formula by isolating <span
class="math inline">\(R(n)\)</span>: 通过分离 <span
class="math inline">\(R(n)\)</span>，我们得到了校正公式： <span
class="math display">\[R(n) \approx \left(\frac{k-1}{k}\right) \cdot
CV_k\]</span> This corrected version is denoted <span
class="math inline">\(\tilde{CV_k}\)</span>.这个校正版本表示为 <span
class="math inline">\(\tilde{CV_k}\)</span>。</p></li>
</ol>
<h3 id="code-analysis-slides-92-93">Code Analysis (Slides 92-93)</h3>
<p>The Python code is an experiment designed to <strong>test the
correction formula</strong>.</p>
<ul>
<li><p><strong>Goal:</strong> Compare the “Raw CV Error” (<span
class="math inline">\(CV_k\)</span>), the “Corrected CV Error” (<span
class="math inline">\(\tilde{CV_k}\)</span>), and the “True Test Error”
(<span class="math inline">\(R(n)\)</span>) in a realistic
setting.</p></li>
<li><p><strong>Key Setup:</strong></p>
<ol type="1">
<li><code>def f(x)</code>: Defines the true, underlying function <span
class="math inline">\(y = x^2 + 15\sin(x)\)</span>.</li>
<li><code>noise_std = 0.5</code>: <strong>This is the most important
line.</strong> It adds significant random noise to the data. This
ensures that the <strong>irreducible error <span
class="math inline">\(R^*\)</span> is large and <span
class="math inline">\(R^* &gt; 0\)</span></strong>.</li>
<li><code>y = f(...) + np.random.normal(...)</code>: Creates the noisy
training data (the blue dots).</li>
</ol></li>
<li><p><strong>CV Calculation (Standard K-Fold):</strong></p>
<ul>
<li><code>kf = KFold(...)</code>: Sets up 5-fold CV (<span
class="math inline">\(k=5\)</span>).</li>
<li><code>for train_index, val_index in kf.split(x):</code>: This is the
standard loop. It trains on 4 folds and validates on 1 fold.</li>
<li><code>cv_error = np.mean(cv_mse_list)</code>: Calculates the
<strong>raw <span class="math inline">\(CV_5\)</span> error</strong>.
This is the first result (e.g., <strong>0.2715</strong>).</li>
</ul></li>
<li><p><strong>Correction Calculation:</strong></p>
<ul>
<li><code>correction_factor = (k_splits - 1) / k_splits</code>: This is
<span class="math inline">\(\frac{k-1}{k}\)</span>, which is <span
class="math inline">\(4/5 = 0.8\)</span>.</li>
<li><code>corrected_cv_error = correction_factor * cv_error</code>: This
applies the flawed formula from the math section (<span
class="math inline">\(0.2715 \times 0.8\)</span>). This is the second
result (e.g., <strong>0.2172</strong>).</li>
</ul></li>
<li><p><strong>“True” Test Error Calculation:</strong></p>
<ul>
<li><code>knn.fit(x, y)</code>: Trains the <em>final model</em> on the
<em>entire</em> noisy dataset.</li>
<li><code>n_test = 1000</code>: Creates a <em>new, large</em> test set
to estimate the true error.</li>
<li><code>true_test_error = mean_squared_error(...)</code>: Calculates
the error of the final model on this new test set. This is our best
estimate of <span class="math inline">\(R(n)\)</span> (e.g.,
<strong>0.2725</strong>).</li>
</ul></li>
<li><p><strong>Analysis of Results (Slide 93):</strong></p>
<ul>
<li><strong>Raw 5-Fold CV MSE:</strong> 0.2715</li>
<li><strong>True test error:</strong> 0.2725</li>
<li><strong>Corrected 5-Fold CV MSE:</strong> 0.2172</li>
</ul>
<p>The <strong>Raw CV Error (0.2715) is an excellent estimate</strong>
of the True Test Error (0.2725). The <strong>Corrected Error (0.2172) is
much worse</strong>. This experiment <em>proves</em> that when noise
(<span class="math inline">\(R^*\)</span>) is present, the simple
correction formula should not be used.</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/10/01/5054C4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/01/5054C4/" class="post-title-link" itemprop="url">MSDM 5054 - Statistical Machine Learning-L4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-01 21:00:00" itemprop="dateCreated datePublished" datetime="2025-10-01T21:00:00+08:00">2025-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-18 23:00:24" itemprop="dateModified" datetime="2025-10-18T23:00:24+08:00">2025-10-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计机器学习Lecture-4</p>
<p><a target="_blank" rel="noopener" href="https://www.math.hkust.edu.hk/~madxia/">Lecturer: Prof.XIA
DONG</a></p>
<h1 id="what-is-classification">1. What is Classification?</h1>
<p>Classification is a type of <strong>supervised machine
learning</strong> where the goal is to predict a
<strong>categorical</strong> or qualitative response. Unlike regression
where you predict a continuous numerical value (like a price or
temperature), classification assigns an input to a specific category or
class.
分类是一种<strong>监督式机器学习</strong>，其目标是预测<strong>分类</strong>或定性响应。与预测连续数值（例如价格或温度）的回归不同，分类将输入分配到特定的类别或类别。</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li><p><strong>Goal:</strong> Predict the class of a subject based on
input features.</p></li>
<li><p><strong>Output (Response):</strong> The output is a category,
such as ‘Yes’/‘No’, ‘Spam’/‘Not Spam’, or
‘High’/‘Medium’/‘Low’.</p></li>
<li><p><strong>Applications:</strong> Common examples include email spam
detectors, medical diagnosis (e.g., virus carrier vs. non-carrier), and
fraud detection.</p>
<ul>
<li><strong>目标</strong>：根据输入特征预测主题的类别。</li>
<li><strong>输出（响应）：</strong>输出是一个类别，例如“是”/“否”、“垃圾邮件”/“非垃圾邮件”或“高”/“中”/“低”。</li>
<li><strong>应用</strong>：常见示例包括垃圾邮件检测器、医学诊断（例如，病毒携带者与非病毒携带者）和欺诈检测。
The example used in the slides is a credit card <strong>Default
dataset</strong>. The goal is to predict whether a customer will
<strong>default</strong> (‘Yes’ or ‘No’) on their payments based on
their monthly <strong>income</strong> and account
<strong>balance</strong>.</li>
</ul></li>
</ul>
<p>## Why Not Use Linear Regression?为什么不使用线性回归？</p>
<p>At first, it might seem possible to use linear regression for
classification. For a binary (two-class) problem like the default
dataset, you could code the outcomes as numbers, for example:</p>
<ul>
<li>Default = ‘No’ =&gt; <span class="math inline">\(y = 0\)</span></li>
<li>Default = ‘Yes’ =&gt; <span class="math inline">\(y =
1\)</span></li>
</ul>
<p>You could then fit a standard linear regression model: <span
class="math inline">\(Y \approx \beta_0 + \beta_1 X\)</span>. In this
context, we would interpret the prediction <span
class="math inline">\(\hat{y}\)</span> as the <em>probability</em> of
default, so we’d be modeling <span class="math inline">\(P(Y=1|X) =
\beta_0 + \beta_1 X\)</span>.</p>
<p>However, this approach has two major problems:
然而，这种方法有两个主要问题： <strong>1. The Output Is Not a
Probability</strong> A linear model can produce outputs that are less
than 0 or greater than 1. This doesn’t make sense for a probability,
which must always be between 0 and 1.</p>
<p>The image below is the most important one for understanding this
issue. The left plot shows a linear regression line fit to the 0/1
default data. You can see the line goes below 0 and would eventually go
above 1 for higher balances. The right plot shows a logistic regression
curve, which always stays between 0 and 1.</p>
<ul>
<li><strong>Left (Linear Regression):</strong> The straight blue line
predicts probabilities &lt; 0 for low balances.</li>
<li><strong>Right (Logistic Regression):</strong> The S-shaped blue
curve correctly constrains the probability output between 0 and 1.</li>
</ul>
<p><strong>2. It Doesn’t Work for Multi-Class Problems</strong> If you
have more than two categories (e.g., ‘mild’, ‘moderate’, ‘severe’), you
might code them as 0, 1, and 2. A linear regression model would
incorrectly assume that the “distance” between ‘mild’ and ‘moderate’ is
the same as the distance between ‘moderate’ and ‘severe’, which is
usually not a valid assumption.</p>
<p><strong>1. 输出不是概率</strong> 线性模型可以产生小于 0 或大于 1
的输出。这对于概率来说毫无意义，因为概率必须始终介于 0 和 1 之间。</p>
<p>下图是理解这个问题最重要的图。左图显示了与 0/1
默认数据拟合的线性回归线。您可以看到，该线低于
0，并且最终会随着余额的增加而高于
1。右图显示了逻辑回归曲线，它始终保持在 0 和 1 之间。</p>
<ul>
<li><strong>左图（线性回归）：</strong>蓝色直线预测低余额的概率小于
0。</li>
<li><strong>右图（逻辑回归）：</strong>S
形蓝色曲线正确地将概率输出限制在 0 和 1 之间。</li>
</ul>
<p><strong>2.它不适用于多类别问题</strong>
如果您有两个以上的类别（例如，“轻度”、“中度”、“重度”），您可能会将它们编码为
0、1 和
2。线性回归模型会错误地假设“轻度”和“中度”之间的“距离”与“中度”和“重度”之间的距离相同，这通常不是一个有效的假设。</p>
<p>## The Solution: Logistic Regression</p>
<p>Instead of modeling the response <span
class="math inline">\(y\)</span> directly, logistic regression models
the <strong>probability</strong> that <span
class="math inline">\(y\)</span> belongs to a particular class. To solve
the issue of the output not being a probability, it uses the
<strong>logistic function</strong> (also known as the sigmoid
function).</p>
<p>This function takes any real-valued input and squeezes it into an
output between 0 and 1.</p>
<p>The formula for the probability in a logistic regression model is:
<span class="math display">\[P(Y=1|X) = \frac{e^{\beta_0 + \beta_1 X}}{1
+ e^{\beta_0 + \beta_1 X}}\]</span> This S-shaped function, shown in the
right-hand plot above, ensures that the output is always a valid
probability. We can then set a threshold (e.g., 0.5) to make the final
class prediction. If <span class="math inline">\(P(Y=1|X) &gt;
0.5\)</span>, we predict ‘Yes’; otherwise, we predict ‘No’.</p>
<p>## 解决方案：逻辑回归</p>
<p>逻辑回归不是直接对响应 <span class="math inline">\(y\)</span>
进行建模，而是对 <span class="math inline">\(y\)</span>
属于特定类别的<strong>概率</strong>进行建模。为了解决输出不是概率的问题，它使用了<strong>逻辑函数</strong>（也称为
S 型函数）。</p>
<p>此函数接受任何实值输入，并将其压缩为介于 0 和 1 之间的输出。</p>
<p>逻辑回归模型中的概率公式为： <span class="math display">\[P(Y=1|X) =
\frac{e^{\beta_0 + \beta_1 X}}{1 + e^{\beta_0 + \beta_1 X}}\]</span>
如上图右侧所示，这个 S
形函数确保输出始终是有效概率。然后，我们可以设置一个阈值（例如
0.5）来进行最终的类别预测。如果 <span class="math inline">\(P(Y=1|X)
&gt; 0.5\)</span>，则预测“是”；否则，预测“否”。</p>
<p>## Data Visualization &amp; Code in Python</p>
<p>The slides use R to visualize the data. The boxplots are particularly
important because they show which variable is a better predictor.</p>
<ul>
<li><p><strong>Balance vs. Default:</strong> The boxplots for balance
show a clear difference. The median balance for those who default
(‘Yes’) is much higher than for those who do not (‘No’). This suggests
<strong>balance is a strong predictor</strong>.</p></li>
<li><p><strong>Income vs. Default:</strong> The boxplots for income show
a lot of overlap. The median incomes for both groups are very similar.
This suggests <strong>income is a weak predictor</strong>.</p></li>
<li><p><strong>余额
vs. 违约</strong>：余额的箱线图显示出明显的差异。违约者（“是”）的余额中位数远高于未违约者（“否”）。这表明<strong>余额是一个强有力的预测指标</strong>。</p></li>
<li><p><strong>收入
vs. 违约</strong>：收入的箱线图显示出很大的重叠。两组的收入中位数非常相似。这表明<strong>收入是一个弱的预测指标</strong>。</p></li>
</ul>
<p>Here’s how you could perform similar analysis and modeling in Python
using <code>seaborn</code> and <code>scikit-learn</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume &#x27;default_data.csv&#x27; has columns: &#x27;default&#x27; (Yes/No), &#x27;balance&#x27;, &#x27;income&#x27;</span></span><br><span class="line"><span class="comment"># You would load your data like this:</span></span><br><span class="line"><span class="comment"># df = pd.read_csv(&#x27;default_data.csv&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For demonstration, let&#x27;s create some sample data</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;balance&#x27;</span>: [<span class="number">1200</span>, <span class="number">2100</span>, <span class="number">800</span>, <span class="number">1800</span>, <span class="number">500</span>, <span class="number">1600</span>, <span class="number">2200</span>, <span class="number">1900</span>],</span><br><span class="line">    <span class="string">&#x27;income&#x27;</span>: [<span class="number">45000</span>, <span class="number">60000</span>, <span class="number">30000</span>, <span class="number">55000</span>, <span class="number">25000</span>, <span class="number">48000</span>, <span class="number">70000</span>, <span class="number">65000</span>],</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: [<span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;No&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;Yes&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. Data Visualization (like the slides) ---</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">14</span>, <span class="number">5</span>))</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Predictor Analysis for Default&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boxplot for Balance</span></span><br><span class="line">sns.boxplot(ax=axes[<span class="number">0</span>], x=<span class="string">&#x27;default&#x27;</span>, y=<span class="string">&#x27;balance&#x27;</span>, data=df)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&#x27;Balance vs. Default Status&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boxplot for Income</span></span><br><span class="line">sns.boxplot(ax=axes[<span class="number">1</span>], x=<span class="string">&#x27;default&#x27;</span>, y=<span class="string">&#x27;income&#x27;</span>, data=df)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&#x27;Income vs. Default Status&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. Logistic Regression Modeling ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert categorical &#x27;default&#x27; column to 0s and 1s</span></span><br><span class="line">df[<span class="string">&#x27;default_encoded&#x27;</span>] = df[<span class="string">&#x27;default&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x == <span class="string">&#x27;Yes&#x27;</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define features (X) and target (y)</span></span><br><span class="line">X = df[[<span class="string">&#x27;balance&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]]</span><br><span class="line">y = df[<span class="string">&#x27;default_encoded&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Split data into training and testing sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and train the logistic regression model</span></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions on new data</span></span><br><span class="line"><span class="comment"># For example, a person with a $2000 balance and $50,000 income</span></span><br><span class="line">new_customer = [[<span class="number">2000</span>, <span class="number">50000</span>]]</span><br><span class="line">predicted_prob = model.predict_proba(new_customer)</span><br><span class="line">prediction = model.predict(new_customer)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Customer data: Balance=2000, Income=50000&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Probability of No Default vs. Default: <span class="subst">&#123;predicted_prob&#125;</span>&quot;</span>) <span class="comment"># [[P(No), P(Yes)]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Final Prediction (0=No, 1=Yes): <span class="subst">&#123;prediction&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="the-mathematical-foundation-of-logistic-regression">2. the
mathematical foundation of logistic regression</h1>
<p>This set of slides explains the mathematical foundation of logistic
regression, how its parameters are estimated using Maximum Likelihood
Estimation (MLE), and how an iterative algorithm called Newton-Raphson
is used to perform this estimation.</p>
<p>逻辑回归的数学基础、如何使用最大似然估计 (MLE)
估计其参数，以及如何使用名为 Newton-Raphson 的迭代算法进行估计。</p>
<h2
id="the-logistic-regression-model-from-probabilities-to-log-odds逻辑回归模型从概率到对数几率">2.1
The Logistic Regression Model: From Probabilities to
Log-Odds逻辑回归模型：从概率到对数几率</h2>
<p>The core of logistic regression is transforming a linear model into a
valid probability. This is done using the <strong>logistic
function</strong>, also known as the sigmoid function.
逻辑回归的核心是将线性模型转换为有效的概率。这可以通过<strong>逻辑函数</strong>（也称为
S 型函数）来实现。 #### <strong>Key Mathematical Formulas</strong></p>
<ol type="1">
<li><p><strong>Probability of Class 1:</strong> The model assumes the
probability of an observation <span
class="math inline">\(\mathbf{x}\)</span> belonging to class 1 is given
by the sigmoid function: <span class="math display">\[
P(y=1|\mathbf{x}) = \frac{1}{1 + \exp(-\beta^T \mathbf{x})} =
\frac{\exp(\beta^T \mathbf{x})}{1 + \exp(\beta^T \mathbf{x})}
\]</span> This function always outputs a value between 0 and 1, making
it perfect for modeling probabilities.</p></li>
<li><p><strong>Odds:</strong> The odds are the ratio of the probability
of an event happening to the probability of it not happening. <span
class="math display">\[
\text{Odds} = \frac{P(y=1|\mathbf{x})}{P(y=0|\mathbf{x})} = \exp(\beta^T
\mathbf{x})
\]</span></p></li>
<li><p><strong>Log-Odds (Logit):</strong> By taking the natural
logarithm of the odds, we get a linear relationship with the predictors.
This is called the <strong>logit transformation</strong>. <span
class="math display">\[
\text{logit}(P(y=1|\mathbf{x})) =
\log\left(\frac{P(y=1|\mathbf{x})}{P(y=0|\mathbf{x})}\right) = \beta^T
\mathbf{x}
\]</span> This final equation is the heart of the model. It states that
the log-odds of the outcome are a linear function of the predictors.
This provides a great interpretation: a one-unit increase in a predictor
<span class="math inline">\(x_j\)</span> changes the log-odds by <span
class="math inline">\(\beta_j\)</span>.</p></li>
<li><p><strong>类别 1 的概率</strong>：该模型假设观测值 <span
class="math inline">\(\mathbf{x}\)</span> 属于类别 1 的概率由 S
型函数给出： <span class="math display">\[
P(y=1|\mathbf{x}) = \frac{1}{1 + \exp(-\beta^T \mathbf{x})} =
\frac{\exp(\beta^T \mathbf{x})}{1 + \exp(\beta^T \mathbf{x})}
\]</span> 此函数的输出值始终介于 0 和 1
之间，非常适合用于概率建模。</p></li>
<li><p><strong>几率</strong>：**几率是事件发生的概率与不发生的概率之比。
<span class="math display">\[
\text{Odds} = \frac{P(y=1|\mathbf{x})}{P(y=0|\mathbf{x})} = \exp(\beta^T
\mathbf{x})
\]</span></p></li>
<li><p><strong>对数概率
(Logit)</strong>：通过对概率取自然对数，我们可以得到概率与预测变量之间的线性关系。这被称为<strong>logit
变换</strong>。 <span class="math display">\[
\text{logit}(P(y=1|\mathbf{x})) =
\log\left(\frac{P(y=1|\mathbf{x})}{P(y=0|\mathbf{x})}\right) = \beta^T
\mathbf{x}
\]</span>
最后一个方程是模型的核心。它指出结果的对数概率是预测变量的线性函数。这提供了一个很好的解释：预测变量
<span class="math inline">\(x_j\)</span>
每增加一个单位，对数概率就会改变 <span
class="math inline">\(\beta_j\)</span>。</p></li>
</ol>
<h2
id="fitting-the-model-maximum-likelihood-estimation-mle-拟合模型最大似然估计-mle">2.2
Fitting the Model: Maximum Likelihood Estimation (MLE)
拟合模型：最大似然估计 (MLE)</h2>
<p>Unlike linear regression, which uses least squares to find the
best-fit line, logistic regression uses <strong>Maximum Likelihood
Estimation (MLE)</strong>. The goal of MLE is to find the parameter
values (the <span class="math inline">\(\beta\)</span> coefficients)
that maximize the probability of observing the actual data that we have.
与使用最小二乘法寻找最佳拟合线的线性回归不同，逻辑回归使用<strong>最大似然估计
(MLE)</strong>。MLE
的目标是找到使观测到实际数据的概率最大化的参数值（<span
class="math inline">\(\beta\)</span> 系数）。</p>
<ol type="1">
<li><p><strong>Likelihood Function:</strong> This is the joint
probability of observing all the data points in our sample. Assuming
each observation is independent, it’s the product of the individual
probabilities:
1.<strong>似然函数</strong>：这是观测到样本中所有数据点的联合概率。假设每个观测值都是独立的，它是各个概率的乘积：
<span class="math display">\[
L(\beta) = \prod_{i=1}^{n} P(y_i|\mathbf{x}_i)
\]</span> A clever way to write this for a binary (0/1) outcome is:
<span class="math display">\[
L(\beta) = \prod_{i=1}^{n} \frac{\exp(y_i \beta^T \mathbf{x}_i)}{1 +
\exp(\beta^T \mathbf{x}_i)}
\]</span></p></li>
<li><p><strong>Log-Likelihood Function:</strong> Products are difficult
to work with mathematically, so we work with the logarithm of the
likelihood, which turns the product into a sum. Maximizing the
log-likelihood is the same as maximizing the likelihood.</p></li>
<li><p><strong>对数似然函数</strong>：乘积在数学上很难处理，所以我们使用似然的对数，将乘积转化为和。最大化对数似然与最大化似然相同。
<span class="math display">\[
\ell(\beta) = \log(L(\beta)) = \sum_{i=1}^{n} \left[ y_i \beta^T
\mathbf{x}_i - \log(1 + \exp(\beta^T \mathbf{x}_i)) \right]
\]</span> <strong>Key Takeaway:</strong> The slides correctly state that
there is <strong>no explicit formula</strong> to solve for the <span
class="math inline">\(\hat{\beta}\)</span> that maximizes this function.
We must find it using a numerical optimization algorithm.
没有<strong>明确的公式</strong>来求解最大化该函数的<span
class="math inline">\(\hat{\beta}\)</span>。我们必须使用数值优化算法来找到它。</p></li>
</ol>
<h2 id="the-algorithm-newton-raphson-算法牛顿-拉夫森算法">2.3 The
Algorithm: Newton-Raphson 算法：牛顿-拉夫森算法</h2>
<p>The slides introduce the <strong>Newton-Raphson algorithm</strong> as
the method to find the optimal <span
class="math inline">\(\hat{\beta}\)</span>. It’s an efficient iterative
algorithm for finding the roots of a function (i.e., where <span
class="math inline">\(f(x)=0\)</span>).</p>
<p><strong>How does this apply to logistic regression?</strong> To
maximize the log-likelihood function <span
class="math inline">\(\ell(\beta)\)</span>, we need to find the point
where its derivative (gradient) is equal to zero. So, Newton-Raphson is
used to solve <span class="math inline">\(\frac{d\ell(\beta)}{d\beta} =
0\)</span>.</p>
<p>它是一种高效的迭代算法，用于求函数的根（即，当<span
class="math inline">\(f(x)=0\)</span>时）。</p>
<p><strong>这如何应用于逻辑回归？</strong> 为了最大化对数似然函数 <span
class="math inline">\(\ell(\beta)\)</span>，我们需要找到其导数（梯度）等于零的点。因此，牛顿-拉夫森法用于求解
<span class="math inline">\(\frac{d\ell(\beta)}{d\beta} =
0\)</span>。</p>
<h4 id="the-general-newton-raphson-method"><strong>The General
Newton-Raphson Method</strong></h4>
<p>The algorithm starts with an initial guess, <span
class="math inline">\(x^{old}\)</span>, and iteratively refines it using
the following update rule, which is based on a Taylor series
approximation: <span class="math display">\[
x^{new} = x^{old} - \frac{f(x^{old})}{f&#39;(x^{old})}
\]</span> where <span class="math inline">\(f&#39;(x)\)</span> is the
derivative of <span class="math inline">\(f(x)\)</span>. You repeat this
step until the value of <span class="math inline">\(x\)</span>
converges.</p>
<p>该算法从初始估计 <span class="math inline">\(x^{old}\)</span>
开始，并使用以下基于泰勒级数近似的更新规则迭代地对其进行优化： <span
class="math display">\[
x^{new} = x^{old} - \frac{f(x^{old})}{f&#39;(x^{old})}
\]</span> 其中 <span class="math inline">\(f&#39;(x)\)</span> 是 <span
class="math inline">\(f(x)\)</span> 的导数。重复此步骤，直到 <span
class="math inline">\(x\)</span> 的值收敛。</p>
<h4
id="important-image-newton-raphson-example-x3---4-0"><strong>Important
Image: Newton-Raphson Example (<span class="math inline">\(x^3 - 4 =
0\)</span>)</strong></h4>
<p>[Image showing iterations of Newton-Raphson]</p>
<p>This slide is a great illustration of the algorithm’s power. *
<strong>Goal:</strong> Find <span class="math inline">\(x\)</span> such
that <span class="math inline">\(f(x) = x^3 - 4 = 0\)</span>. *
<strong>Function:</strong> <span class="math inline">\(f(x) = x^3 -
4\)</span> * <strong>Derivative:</strong> <span
class="math inline">\(f&#39;(x) = 3x^2\)</span> * <strong>Update
Rule:</strong> <span class="math inline">\(x^{new} = x^{old} -
\frac{(x^{old})^3 - 4}{3(x^{old})^2}\)</span> Starting with a guess of
<span class="math inline">\(x^{old} = 2\)</span>, the algorithm
converges to the true answer (<span class="math inline">\(4^{1/3}
\approx 1.5874\)</span>) in just 4 steps.</p>
<ul>
<li><strong>目标</strong>：找到 <span
class="math inline">\(x\)</span>，使得 <span class="math inline">\(f(x)
= x^3 - 4 = 0\)</span>。</li>
<li><strong>函数</strong>：<span class="math inline">\(f(x) = x^3 -
4\)</span></li>
<li><strong>导数</strong>：<span class="math inline">\(f&#39;(x) =
3x^2\)</span></li>
<li><strong>更新规则</strong>：<span class="math inline">\(x^{new} =
x^{old} - \frac{(x^{old})^3 - 4}{3(x^{old})^2}\)</span> 从 <span
class="math inline">\(x^{old} = 2\)</span> 的猜测开始，该算法仅用 4
步就收敛到真实答案 (<span class="math inline">\(4^{1/3} \approx
1.5874\)</span>)。</li>
</ul>
<h4 id="code-understanding-python"><strong>Code Understanding
(Python)</strong></h4>
<p>The slides show Python code implementing Newton-Raphson. Let’s break
down the key function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the function we want to find the root of</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(x) - x*x + <span class="number">3</span> * np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define its derivative</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f_prime</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(x) - <span class="number">2</span>*x + <span class="number">3</span> * np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Newton-Raphson method</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newton_raphson</span>(<span class="params">x0, tol=<span class="number">1e-10</span>, max_iter=<span class="number">100</span></span>):</span><br><span class="line">    x = x0 <span class="comment"># Start with the initial guess</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        fx = f(x)      <span class="comment"># Calculate f(x_old)</span></span><br><span class="line">        fpx = f_prime(x) <span class="comment"># Calculate f&#x27;(x_old)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fpx == <span class="number">0</span>: <span class="comment"># Cannot divide by zero</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Zero derivative. No solution found.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is the core update rule</span></span><br><span class="line">        x_new = x - fx / fpx</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the change is small enough to stop</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(x_new - x) &lt; tol:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Converged to <span class="subst">&#123;x_new&#125;</span> after <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> iterations.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> x_new</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update x for the next iteration</span></span><br><span class="line">        x = x_new</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exceeded maximum iterations. No solution found.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initial guess and execution</span></span><br><span class="line">x0 = <span class="number">0.5</span></span><br><span class="line">root = newton_raphson(x0)</span><br></pre></td></tr></table></figure>
<p>The slides show that with a good initial guess
(<code>x0 = 0.5</code>), the algorithm converges quickly. With a bad one
(<code>x0 = 50</code>), it still converges but takes many more steps.
This highlights the importance of the starting point. The slides also
show an implementation of <strong>Gradient Descent</strong>, another
popular optimization algorithm which uses the update rule
<code>x_new = x - learning_rate * gradient</code>.</p>
<h1
id="provide-a-great-case-study-on-logistic-regression-particularly-on-the-important-concept-of-confounding-variables.-heres-a-summary-covering-the-math-code-and-key-insights.">Provide
a great case study on logistic regression, particularly on the important
concept of confounding variables. Here’s a summary covering the math,
code, and key insights.</h1>
<ol start="3" type="1">
<li><h1 id="core-concept-logistic-regression-核心概念逻辑回归">Core
Concept: Logistic Regression 📈 # 核心概念：逻辑回归 📈</h1></li>
</ol>
<p>Logistic regression is a statistical method used for <strong>binary
classification</strong>, which means predicting an outcome that can only
be one of two things (e.g., Yes/No, True/False, 1/0).</p>
<p>In this example, the goal is to predict the probability that a
customer will <strong>default</strong> on a loan (Yes or No) based on
factors like their account <code>balance</code>, <code>income</code>,
and whether they are a <code>student</code>.</p>
<p>The core of logistic regression is the <strong>sigmoid (or logistic)
function</strong>, which takes any real-valued number and squishes it to
a value between 0 and 1, representing a probability.</p>
<p><span class="math display">\[
\hat{P}(Y=1|X) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 X_1 + ... + \beta_p
X_p)}}
\]</span></p>
<ul>
<li><span class="math inline">\(\hat{P}(Y=1|X)\)</span> is the predicted
probability of the outcome being “Yes” (e.g., default).</li>
<li><span class="math inline">\(\beta_0\)</span> is the intercept.</li>
<li><span class="math inline">\(\beta_1, ..., \beta_p\)</span> are the
coefficients for each input variable (<span class="math inline">\(X_1,
..., X_p\)</span>). The model’s job is to find the best values for these
<span class="math inline">\(\beta\)</span> coefficients.</li>
</ul>
<hr />
<p>逻辑回归是一种用于<strong>二元分类</strong>的统计方法，这意味着预测结果只能是两种情况之一（例如，是/否、真/假、1/0）。</p>
<p>在本例中，目标是根据客户账户“余额”、“收入”以及是否为“学生”等因素，预测客户<strong>拖欠</strong>贷款（是或否）的概率。</p>
<p>逻辑回归的核心是<strong>Sigmoid（或逻辑）函数</strong>，它将任何实数压缩为介于
0 和 1 之间的值，以表示概率。</p>
<p><span class="math display">\[
\hat{P}(Y=1|X) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 X_1 + ... + \beta_p
X_p)}}
\]</span></p>
<ul>
<li><span class="math inline">\(\hat{P}(Y=1|X)\)</span>
是结果为“是”（例如，默认）的预测概率。</li>
<li><span class="math inline">\(\beta_0\)</span> 是截距。</li>
<li><span class="math inline">\(\beta_1, ..., \beta_p\)</span>
是每个输入变量 (<span class="math inline">\(X_1, ..., X_p\)</span>)
的系数。模型的任务是找到这些 <span class="math inline">\(\beta\)</span>
系数的最佳值。</li>
</ul>
<h2 id="how-the-model-learns-mathematical-foundation">3.1 How the Model
“Learns” (Mathematical Foundation)</h2>
<p>The slides show that the model’s coefficients (<span
class="math inline">\(\beta\)</span>) are found using an algorithm like
<strong>Newton-Raphson</strong>. This is an iterative process to find
the values that <strong>maximize the log-likelihood function</strong>.
Think of this as finding the coefficient values that make the observed
data most
probable.这是一个迭代过程，用于查找<strong>最大化对数似然函数</strong>的值。可以将其视为查找使观测数据概率最大的系数值。</p>
<p>The key slide for this is the one titled “Newton-Raphson Iterative
Algorithm”. It shows the formulas for: * The <strong>Gradient</strong>
(<span class="math inline">\(\nabla\ell\)</span>): The direction of the
steepest ascent of the log-likelihood function. * The
<strong>Hessian</strong> (<span class="math inline">\(H\)</span>): The
curvature of the log-likelihood function.</p>
<ul>
<li><strong>梯度</strong> (<span
class="math inline">\(\nabla\ell\)</span>)：对数似然函数最陡上升的方向。</li>
<li><strong>黑森矩阵</strong> (<span
class="math inline">\(H\)</span>)：对数似然函数的曲率。</li>
</ul>
<p>The updating rule is given by: <span class="math display">\[
\beta^{new} = \beta^{old} - H^{-1}\nabla\ell
\]</span> This formula is used repeatedly until the coefficient values
stop changing significantly, meaning the algorithm has converged to the
best fit. This process is also referred to as <strong>Iteratively
Reweighted Least Squares (IRLS)</strong>.
此公式反复使用，直到系数值不再发生显著变化，这意味着算法已收敛到最佳拟合值。此过程也称为<strong>迭代重加权最小二乘法
(IRLS)</strong>。</p>
<hr />
<h2 id="the-puzzle-a-tale-of-two-models">3.2 The Puzzle: A Tale of Two
Models 🕵️‍♂️</h2>
<p>The most important story in these slides is how the effect of being a
student changes depending on the model. This is a classic example of a
<strong>confounding variable</strong>.</p>
<h4 id="model-1-simple-logistic-regression-default-vs.-student">Model 1:
Simple Logistic Regression (Default vs. Student)</h4>
<p>When predicting default using <em>only</em> student status, the model
is: <code>default ~ student</code></p>
<p>From the slides, the coefficients are: * Intercept (<span
class="math inline">\(\beta_0\)</span>): -3.5041 * student[Yes] (<span
class="math inline">\(\beta_1\)</span>): <strong>0.4049</strong>
(positive)</p>
<p>The equation for the log-odds is: <span class="math display">\[
\log\left(\frac{P(\text{default})}{1-P(\text{default})}\right) = -3.5041
+ 0.4049 \times (\text{is\_student})
\]</span></p>
<p><strong>Conclusion:</strong> The positive coefficient (0.4049)
suggests that <strong>students are more likely to default</strong> than
non-students. The slides calculate the probabilities: * <strong>Student
Default Probability:</strong> 4.31% * <strong>Non-Student Default
Probability:</strong> 2.92%</p>
<p>学生身份的影响如何根据模型而变化。这是一个典型的<strong>混杂变量</strong>的例子。</p>
<h4 id="模型-1简单逻辑回归违约-vs.-学生">模型 1：简单逻辑回归（违约
vs. 学生）</h4>
<p>仅使用学生身份预测违约时，模型为： <code>default ~ student</code></p>
<p>幻灯片中显示的系数为： * 截距 (<span
class="math inline">\(\beta_0\)</span>): -3.5041 * 学生[是] (<span
class="math inline">\(\beta_1\)</span>):
<strong>0.4049</strong>（正）</p>
<p>对数概率公式为： <span class="math display">\[
\log\left(\frac{P(\text{default})}{1-P(\text{default})}\right) = -3.5041
+ 0.4049 \times (\text{is\_student})
\]</span></p>
<p><strong>结论</strong>：正系数 (0.4049)
表明<strong>学生比非学生更有可能违约</strong>。幻灯片计算了以下概率： *
<strong>学生违约概率</strong>：4.31% *
<strong>非学生违约概率</strong>：2.92%</p>
<h2
id="model-2-multiple-logistic-regression-default-vs.-all-variables-模型-2多元逻辑回归违约-vs.-所有变量">3.3
Model 2: Multiple Logistic Regression (Default vs. All Variables) 模型
2：多元逻辑回归（违约 vs. 所有变量）</h2>
<p>When we add <code>balance</code> and <code>income</code> to the
model, it becomes: <code>default ~ student + balance + income</code></p>
<p>From the slides, the new coefficients are: * Intercept (<span
class="math inline">\(\beta_0\)</span>): -10.8690 * balance (<span
class="math inline">\(\beta_1\)</span>): 0.0057 * income (<span
class="math inline">\(\beta_2\)</span>): 0.0030 * student[Yes] (<span
class="math inline">\(\beta_3\)</span>): <strong>-0.6468</strong>
(negative)</p>
<p><strong>The Shocking Twist!</strong> The coefficient for
<code>student[Yes]</code> is now <strong>negative</strong>.</p>
<p><strong>Conclusion:</strong> When we control for balance and income,
<strong>students are actually <em>less</em> likely to default</strong>
than non-students with the same balance and income.</p>
<h4 id="why-the-change-the-confounding-variable-explained">Why the
Change? The Confounding Variable Explained</h4>
<p>The key insight, explained on the slide with multi-colored text
bubbles, is that <strong>students, on average, have higher credit card
balances</strong>.</p>
<ul>
<li>In the simple model, the <code>student</code> variable was
inadvertently capturing the risk associated with having a high
<code>balance</code>. The model mistakenly concluded “being a student
causes default.”</li>
<li>In the multiple model, the <code>balance</code> variable properly
accounts for the risk from a high balance. With that effect isolated,
the <code>student</code> variable can show its true, underlying
relationship with default, which is negative.</li>
</ul>
<p>This demonstrates why it’s crucial to consider multiple relevant
variables to avoid drawing incorrect conclusions. <strong>The most
important slides are the ones that present this paradox and its
explanation.</strong></p>
<p><strong>令人震惊的转折！</strong> <code>student[Yes]</code>
的系数现在为<strong>负</strong>。</p>
<p><strong>结论：</strong>当我们控制余额和收入时，<strong>学生实际上比具有相同余额和收入的非学生更<em>低</em>于违约</strong>。</p>
<h4 id="为什么会有变化混杂变量解释">为什么会有变化？混杂变量解释</h4>
<p>幻灯片上用彩色文字气泡解释了关键的见解，即<strong>学生平均拥有更高的信用卡余额</strong>。</p>
<ul>
<li>在简单模型中，“学生”变量无意中捕捉到了高余额带来的风险。该模型错误地得出了“学生身份导致违约”的结论。</li>
<li>在多元模型中，“余额”变量正确地解释了高余额带来的风险。在分离出这一影响后，“学生”变量可以显示其与违约之间真实的潜在关系，即负相关关系。</li>
</ul>
<p>这说明了为什么考虑多个相关变量以避免得出错误结论至关重要。</p>
<hr />
<h3 id="code-implementation-r-vs.-python">Code Implementation: R
vs. Python</h3>
<p>The slides use R’s <code>glm()</code> (Generalized Linear Model)
function. Here’s how you would replicate this in Python.</p>
<h4 id="r-code-from-slides">R Code (from slides)</h4>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simple Model</span></span><br><span class="line">glmod2 <span class="operator">&lt;-</span> glm<span class="punctuation">(</span>default <span class="operator">~</span> student<span class="punctuation">,</span> data<span class="operator">=</span>Default<span class="punctuation">,</span> family<span class="operator">=</span>binomial<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>glmod2<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Model</span></span><br><span class="line">glmod3 <span class="operator">&lt;-</span> glm<span class="punctuation">(</span>default <span class="operator">~</span> .<span class="punctuation">,</span> data<span class="operator">=</span>Default<span class="punctuation">,</span> family<span class="operator">=</span>binomial<span class="punctuation">)</span> <span class="comment"># &#x27;.&#x27; means all other variables</span></span><br><span class="line">summary<span class="punctuation">(</span>glmod3<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h4 id="python-equivalent">Python Equivalent</h4>
<p>We can use two popular libraries: <code>statsmodels</code> (which
gives R-style summaries) and <code>scikit-learn</code> (the standard for
machine learning).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume &#x27;Default&#x27; is a pandas DataFrame with columns:</span></span><br><span class="line"><span class="comment"># &#x27;default&#x27; (0/1), &#x27;student&#x27; (0/1), &#x27;balance&#x27;, &#x27;income&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Using statsmodels (recommended for interpretation) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare the data</span></span><br><span class="line"><span class="comment"># For statsmodels, we need to manually add the intercept</span></span><br><span class="line">X_simple = Default[[<span class="string">&#x27;student&#x27;</span>]]</span><br><span class="line">X_simple = sm.add_constant(X_simple)</span><br><span class="line">y = Default[<span class="string">&#x27;default&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_multiple = Default[[<span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;balance&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]]</span><br><span class="line">X_multiple = sm.add_constant(X_multiple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple Model: default ~ student</span></span><br><span class="line">model_simple = sm.Logit(y, X_simple).fit()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- Simple Model ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model_simple.summary())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Model: default ~ student + balance + income</span></span><br><span class="line">model_multiple = sm.Logit(y, X_multiple).fit()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- Multiple Model ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model_multiple.summary())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Using scikit-learn (recommended for prediction tasks) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare the data (scikit-learn adds intercept by default)</span></span><br><span class="line">X_simple_sk = Default[[<span class="string">&#x27;student&#x27;</span>]]</span><br><span class="line">y_sk = Default[<span class="string">&#x27;default&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X_multiple_sk = Default[[<span class="string">&#x27;student&#x27;</span>, <span class="string">&#x27;balance&#x27;</span>, <span class="string">&#x27;income&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple Model</span></span><br><span class="line">clf_simple = LogisticRegression().fit(X_simple_sk, y_sk)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nSimple Model Intercept (scikit-learn): <span class="subst">&#123;clf_simple.intercept_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Simple Model Coefficient (scikit-learn): <span class="subst">&#123;clf_simple.coef_&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Model</span></span><br><span class="line">clf_multiple = LogisticRegression().fit(X_multiple_sk, y_sk)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nMultiple Model Intercept (scikit-learn): <span class="subst">&#123;clf_multiple.intercept_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Multiple Model Coefficients (scikit-learn): <span class="subst">&#123;clf_multiple.coef_&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1
id="making-predictions-and-the-decision-boundary-进行预测和决策边界">4
Making Predictions and the Decision Boundary 🎯进行预测和决策边界</h1>
<p>Once the model is trained (i.e., we have the coefficients <span
class="math inline">\(\hat{\beta}\)</span>), we can make predictions.
一旦模型训练完成（即，我们有了系数 <span
class="math inline">\(\hat{\beta}\)</span>），我们就可以进行预测了。 ##
Math Behind Predictions</p>
<p>The model outputs the <strong>log-odds</strong>, which can be
converted into a probability. A key concept is the <strong>decision
boundary</strong>, which is the threshold where the model is uncertain
(probability = 50%).
模型输出<strong>对数概率</strong>，它可以转换为概率。一个关键概念是<strong>决策边界</strong>，它是模型不确定的阈值（概率
= 50%）。</p>
<ol type="1">
<li><p><strong>The Estimated Odds</strong>: The core output of the
linear part of the model is the exponential of the linear equation,
which gives the odds of the outcome being ‘Yes’ (or 1).
<strong>估计概率</strong>：模型线性部分的核心输出是线性方程的指数，它给出了结果为“是”（或
1）的概率。</p>
<p><span class="math display">\[
\]</span>$$\frac{\hat{P}(y=1|\mathbf{x}_0)}{\hat{P}(y=0|\mathbf{x}_0)} =
\exp(\hat{\beta}^\top \mathbf{x}_0)</p>
<p><span class="math display">\[
\]</span><span class="math display">\[
\]</span></p></li>
<li><p><strong>The Decision Rule</strong>: We classify a new observation
<span class="math inline">\(\mathbf{x}_0\)</span> by comparing its
predicted odds to a threshold <span
class="math inline">\(\delta\)</span>.
<strong>决策规则</strong>：我们通过比较新观测值 <span
class="math inline">\(\mathbf{x}_0\)</span> 的预测概率与阈值 <span
class="math inline">\(\delta\)</span> 来对其进行分类。</p>
<ul>
<li>Predict <span class="math inline">\(y=1\)</span> if <span
class="math inline">\(\exp(\hat{\beta}^\top \mathbf{x}_0) &gt;
\delta\)</span></li>
<li>Predict <span class="math inline">\(y=0\)</span> if <span
class="math inline">\(\exp(\hat{\beta}^\top \mathbf{x}_0) &lt;
\delta\)</span> A common default is <span
class="math inline">\(\delta=1\)</span>, which means we predict ‘Yes’ if
the probability is greater than 0.5.</li>
</ul></li>
<li><p><strong>The Linear Boundary</strong>: The decision boundary
itself is where the odds are exactly equal to the threshold. By taking
the logarithm, we see that this boundary is a <strong>linear
equation</strong>. This is why logistic regression is called a
<strong>linear classifier</strong>.
<strong>线性边界</strong>：决策边界本身就是概率恰好等于阈值的地方。取对数后，我们发现这个边界是一个<strong>线性方程</strong>。这就是逻辑回归被称为<strong>线性分类器</strong>的原因。
<span class="math display">\[
\]</span>$$\hat{\beta}^\top \mathbf{x} = \log(\delta)</p>
<p><span class="math display">\[
\]</span>$$For <span class="math inline">\(\delta=1\)</span>, the
boundary is simply <span class="math inline">\(\hat{\beta}^\top
\mathbf{x} = 0\)</span>.</p></li>
</ol>
<p>This concept is visualized perfectly in the slide titled “Linear
Classifier,” which shows a straight line neatly separating two classes
of data points.
题为“线性分类器”的幻灯片完美地展示了这一概念，它展示了一条直线，将两类数据点巧妙地分隔开来。</p>
<h2 id="visualizing-the-confounding-effect">Visualizing the Confounding
Effect</h2>
<p>The most important image in this set is <strong>Figure 4.3</strong>,
as it visually explains the confounding puzzle from the first set of
slides.</p>
<ul>
<li><strong>Right Panel (Boxplots)</strong>: This shows that
<strong>students (Yes) tend to have higher credit card balances</strong>
than non-students (No). This is the source of the confounding.</li>
<li><strong>Left Panel (Default Rates)</strong>:
<ul>
<li>The <strong>dashed lines</strong> show the <em>overall</em> default
rates. The orange line (students) is higher than the blue line
(non-students). This matches our simple model
(<code>default ~ student</code>).</li>
<li>The <strong>solid S-shaped curves</strong> show the probability of
default as a function of balance. For any <em>given</em> balance, the
blue curve (non-students) is slightly higher than the orange curve
(students). This means that <strong>at the same level of debt, students
are <em>less</em> likely to default</strong>. This matches our multiple
regression model
(<code>default ~ student + balance + income</code>).</li>
</ul></li>
</ul>
<p>This single figure brilliantly illustrates how a variable can appear
to have one effect in isolation but the opposite effect when controlling
for a confounding factor. *
<strong>右侧面板（箱线图）</strong>：这表明<strong>学生（是）的信用卡余额往往高于非学生（否）。这就是混杂效应的根源。
* </strong>左图（违约率）<strong>： *
</strong>虚线<strong>显示<em>总体</em>违约率。橙色线（学生）高于蓝色线（非学生）。这与我们的简单模型（“违约
~ 学生”）相符。 * </strong>S
形实线<strong>显示违约概率与余额的关系。对于任何<em>给定</em>的余额，蓝色曲线（非学生）略高于橙色曲线（学生）。这意味着</strong>在相同的债务水平下，学生违约的可能性<em>较小</em>。这与我们的多元回归模型（“违约
~ 学生 + 余额 + 收入”）相符。</p>
<p>这张图巧妙地说明了为什么一个变量在单独使用时似乎会产生一种影响，但在控制混杂因素后却会产生相反的影响。</p>
<h2 id="an-important-edge-case-perfect-separation">An Important Edge
Case: Perfect Separation ⚠️</h2>
<p>What happens if the data can be perfectly separated by a straight
line? 如果数据可以用一条直线完美分离，会发生什么？</p>
<p>One might think this is the ideal scenario, but it causes a problem
for the logistic regression algorithm. The model will try to find
coefficients that make the probabilities for each class as close to 1
and 0 as possible. To do this, the magnitude of the coefficients (<span
class="math inline">\(\hat{\beta}\)</span>) must grow infinitely large.
人们可能认为这是理想情况，但它会给逻辑回归算法带来问题。模型会尝试找到使每个类别的概率尽可能接近
1 和 0 的系数。为此，系数 (<span
class="math inline">\(\hat{\beta}\)</span>) 的大小必须无限大。</p>
<p>The slide “Non-convergence for perfectly separated case” demonstrates
this:</p>
<ul>
<li><p><strong>The Code</strong>: It generates two distinct,
non-overlapping clusters of data points using Python’s
<code>scikit-learn</code>.</p></li>
<li><p><strong>Parameter Estimates Graph</strong>: It shows the
<code>Intercept</code>, <code>Coefficient 1</code>, and
<code>Coefficient 2</code> values increasing or decreasing without limit
as the algorithm runs through more iterations. They never converge to a
stable value.</p></li>
<li><p><strong>Decision Boundary Graph</strong>: The decision boundary
itself might look reasonable, but the underlying coefficients are
unstable.</p></li>
<li><p><strong>代码</strong>：它使用 Python 的 <code>scikit-learn</code>
生成两个不同的、不重叠的数据点聚类。</p></li>
<li><p><strong>参数估计图</strong>：它显示“截距”、“系数 1”和“系数
2”的值随着算法迭代次数的增加或减少而无限增大或减小。它们永远不会收敛到一个稳定的值。</p></li>
<li><p><strong>决策边界图</strong>：决策边界本身可能看起来合理，但底层系数是不稳定的。</p></li>
</ul>
<p><strong>Key Takeaway</strong>: If your logistic regression model
fails to converge, the first thing you should check for is perfect
separation in your training data.
<strong>关键要点</strong>：如果您的逻辑回归模型未能收敛，您应该检查的第一件事就是训练数据是否完美分离。</p>
<h2 id="code-understanding">Code Understanding</h2>
<p>The slides provide useful code snippets in both R and Python.</p>
<h2 id="r-code-plotting-predictions">R Code (Plotting Predictions)</h2>
<p>This code generates the plot with the two S-shaped curves (one for
students, one for non-students) showing the probability of default as
balance increases.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="comment"># Create a data frame for prediction with a range of balances</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="comment"># One version for students, one for non-students</span></span><br><span class="line">Default.st <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>balance<span class="operator">=</span>seq<span class="punctuation">(</span><span class="number">500</span><span class="punctuation">,</span> <span class="number">2500</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> student<span class="operator">=</span><span class="string">&quot;Yes&quot;</span><span class="punctuation">)</span></span><br><span class="line">Default.nonst <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>balance<span class="operator">=</span>seq<span class="punctuation">(</span><span class="number">500</span><span class="punctuation">,</span> <span class="number">2500</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> student<span class="operator">=</span><span class="string">&quot;No&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="comment"># Use the trained multiple regression model (glmod3) to predict probabilities</span></span><br><span class="line">pred.st <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>glmod3<span class="punctuation">,</span> Default.st<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line">pred.nonst <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>glmod3<span class="punctuation">,</span> Default.nonst<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="comment"># Plot the results</span></span><br><span class="line">plot<span class="punctuation">(</span>Default.st<span class="operator">$</span>balance<span class="punctuation">,</span> pred.st<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;l&quot;</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> ...<span class="punctuation">)</span> <span class="operator">/</span><span class="operator">/</span> Students</span><br><span class="line">lines<span class="punctuation">(</span>Default.nonst<span class="operator">$</span>balance<span class="punctuation">,</span> pred.nonst<span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> ...<span class="punctuation">)</span> <span class="operator">/</span><span class="operator">/</span> Non<span class="operator">-</span>students</span><br></pre></td></tr></table></figure>
<h4 id="python-code-visualizing-the-decision-boundary">Python Code
(Visualizing the Decision Boundary)</h4>
<p>This Python code uses <code>scikit-learn</code> and
<code>matplotlib</code> to create the plot showing the linear decision
boundary.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import necessary libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Generate synthetic data with two classes</span></span><br><span class="line">X, y = make_classification(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Initialize and fit the logistic regression model</span></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Create a mesh grid of points to make predictions over the entire plot area</span></span><br><span class="line">xx, yy = np.meshgrid(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Predict the probability for each point on the grid</span></span><br><span class="line">probs = model.predict_proba(np.c_[xx.ravel(), yy.ravel()])[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Plot the decision boundary where the probability is 0.5</span></span><br><span class="line">plt.contour(xx, yy, probs.reshape(xx.shape), levels=[<span class="number">0.5</span>], ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Scatter plot the actual data points</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, ...)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="other-important-remarks">Other Important Remarks</h3>
<p>The “Remarks” slide briefly mentions some key extensions:</p>
<ul>
<li><p><strong>Probit Model</strong>: An alternative to logistic
regression that uses the cumulative distribution function (CDF) of the
standard normal distribution instead of the sigmoid function. The
results are often very similar.</p></li>
<li><p><strong>Softmax Regression</strong>: An extension of logistic
regression used for multi-class classification (when there are more than
two possible outcomes).</p></li>
<li><p><strong>Probit
模型</strong>：逻辑回归的替代方法，它使用标准正态分布的累积分布函数
(CDF) 代替 S 型函数。结果通常非常相似。</p></li>
<li><p><strong>Softmax
回归</strong>：逻辑回归的扩展，用于多类分类（当存在两个以上可能结果时）。</p></li>
</ul>
<h1
id="here-is-a-summary-of-the-slides-on-linear-discriminant-analysis-lda-including-the-key-mathematical-formulas-visual-explanations-and-how-to-implement-it-in-python.">5.
Here is a summary of the slides on Linear Discriminant Analysis (LDA),
including the key mathematical formulas, visual explanations, and how to
implement it in Python.</h1>
<h2
id="the-main-idea-classification-using-probabilities-使用概率进行分类">The
Main Idea: Classification Using Probabilities 使用概率进行分类</h2>
<p>Linear Discriminant Analysis (LDA) is a classification method. For a
given input <strong>x</strong>, it calculates the probability that
<strong>x</strong> belongs to each class and then assigns
<strong>x</strong> to the class with the <strong>highest
probability</strong>.</p>
<p>It does this using <strong>Bayes’ Theorem</strong>, which provides a
formula for the posterior probability <span class="math inline">\(P(Y=k
| X=x)\)</span>, or the probability that the class is <span
class="math inline">\(k\)</span> given the input <span
class="math inline">\(x\)</span>. 线性判别分析 (LDA)
是一种分类方法。对于给定的输入 <strong>x</strong>，它计算
<strong>x</strong> 属于每个类别的概率，然后将 <strong>x</strong>
分配给<strong>概率最高</strong>的类别。</p>
<p>它使用<strong>贝叶斯定理</strong>来实现这一点，该定理提供了后验概率
<span class="math inline">\(P(Y=k | X=x)\)</span> 的公式，即给定输入
<span class="math inline">\(x\)</span>，该类别属于 <span
class="math inline">\(k\)</span> 的概率。 <span class="math display">\[
p_k(x) = P(Y=k|X=x) = \frac{\pi_k f_k(x)}{\sum_{l=1}^{K} \pi_l f_l(x)}
\]</span></p>
<ul>
<li><span class="math inline">\(p_k(x)\)</span> is the <strong>posterior
probability</strong> we want to maximize.</li>
<li><span class="math inline">\(\pi_k = P(Y=k)\)</span> is the
<strong>prior probability</strong> of class <span
class="math inline">\(k\)</span> (how common the class is overall).</li>
<li><span class="math inline">\(f_k(x) = f(x|Y=k)\)</span> is the
<strong>class-conditional probability density function</strong> of
observing input <span class="math inline">\(x\)</span> if it belongs to
class <span class="math inline">\(k\)</span>.</li>
</ul>
<p>To classify a new observation <span class="math inline">\(x\)</span>,
we simply find the class <span class="math inline">\(k\)</span> that
makes <span class="math inline">\(p_k(x)\)</span> the largest.
为了对新的观察值 <span class="math inline">\(x\)</span>
进行分类，我们只需找到使 <span class="math inline">\(p_k(x)\)</span>
最大的类别 <span class="math inline">\(k\)</span> 即可。</p>
<hr />
<h2 id="key-assumptions-of-lda">Key Assumptions of LDA</h2>
<p>LDA’s power comes from a specific, simplifying assumption about the
data’s distribution. LDA
的强大之处在于它对数据分布进行了特定的简化假设。</p>
<ol type="1">
<li><p><strong>Gaussian Distribution:</strong> LDA assumes that the data
within each class <span class="math inline">\(k\)</span> follows a
p-dimensional multivariate normal (or Gaussian) distribution, denoted as
<span class="math inline">\(X|Y=k \sim \mathcal{N}(\mu_k,
\Sigma)\)</span>.</p></li>
<li><p><strong>Common Covariance:</strong> A crucial assumption is that
all classes share the <strong>same covariance matrix</strong> <span
class="math inline">\(\Sigma\)</span>. This means that while the classes
may have different centers (means, <span
class="math inline">\(\mu_k\)</span>), their shape and orientation
(covariance, <span class="math inline">\(\Sigma\)</span>) are
identical.</p></li>
<li><p><strong>高斯分布</strong>：LDA 假设每个类 <span
class="math inline">\(k\)</span> 中的数据服从 p
维多元正态（或高斯）分布，表示为 <span class="math inline">\(X|Y=k \sim
\mathcal{N}(\mu_k, \Sigma)\)</span>。</p></li>
<li><p><strong>共同协方差</strong>：一个关键假设是所有类共享<strong>相同的协方差矩阵</strong>
<span
class="math inline">\(\Sigma\)</span>。这意味着虽然类可能具有不同的中心（均值，<span
class="math inline">\(\mu_k\)</span>），但它们的形状和方向（协方差，<span
class="math inline">\(\Sigma\)</span>）是相同的。</p></li>
</ol>
<p>The probability density function for a class <span
class="math inline">\(k\)</span> is: <span class="math display">\[
f_k(x) = \frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}} \exp \left( -\frac{1}{2}(x
- \mu_k)^T \Sigma^{-1} (x - \mu_k) \right)
\]</span></p>
<p>The image above (from your slide “Knowing normal distribution”)
illustrates this. The two “bells” have different centers (different
<span class="math inline">\(\mu_k\)</span>) but similar shapes. The one
on the right is “tilted,” indicating correlation between variables,
which is captured in the shared covariance matrix <span
class="math inline">\(\Sigma\)</span>.
上图（摘自幻灯片“了解正态分布”）说明了这一点。两个“钟”形的中心不同（<span
class="math inline">\(\mu_k\)</span>
不同），但形状相似。右边的钟形“倾斜”，表示变量之间存在相关性，这体现在共享协方差矩阵
<span class="math inline">\(\Sigma\)</span> 中。</p>
<hr />
<h2 id="the-math-behind-lda-the-discriminant-function-判别函数">The Math
Behind LDA: The Discriminant Function 判别函数</h2>
<p>Since we only need to find the class <span
class="math inline">\(k\)</span> that maximizes the posterior
probability <span class="math inline">\(p_k(x)\)</span>, we can simplify
the math. The denominator in Bayes’ theorem is the same for all classes,
so we only need to maximize the numerator: <span
class="math inline">\(\pi_k f_k(x)\)</span>.
由于我们只需要找到使后验概率 <span class="math inline">\(p_k(x)\)</span>
最大化的类别 <span
class="math inline">\(k\)</span>，因此可以简化数学计算。贝叶斯定理中的分母对于所有类别都是相同的，因此我们只需要最大化分子：<span
class="math inline">\(\pi_k f_k(x)\)</span>。 Taking the logarithm
(which doesn’t change which class is maximal) and removing constant
terms gives us the <strong>linear discriminant function</strong>, <span
class="math inline">\(\delta_k(x)\)</span>:
取对数（这不会改变哪个类别是最大值）并移除常数项，得到<strong>线性判别函数</strong>，<span
class="math inline">\(\delta_k(x)\)</span>：</p>
<p><span class="math display">\[
\delta_k(x) = x^T \Sigma^{-1} \mu_k - \frac{1}{2} \mu_k^T \Sigma^{-1}
\mu_k + \log(\pi_k)
\]</span></p>
<p>This function is <strong>linear</strong> in <span
class="math inline">\(x\)</span>, which is why the method is called
<em>Linear</em> Discriminant Analysis. The decision boundary between any
two classes, say class <span class="math inline">\(k\)</span> and class
<span class="math inline">\(l\)</span>, is the set of points where <span
class="math inline">\(\delta_k(x) = \delta_l(x)\)</span>, which defines
a linear hyperplane. 该函数关于 <span class="math inline">\(x\)</span>
是<strong>线性</strong>的，因此该方法被称为<em>线性</em>判别分析。任意两个类别（例如类别
<span class="math inline">\(k\)</span> 和类别 <span
class="math inline">\(l\)</span>）之间的决策边界是满足 <span
class="math inline">\(\delta_k(x) = \delta_l(x)\)</span>
的点的集合，这定义了一个线性超平面。</p>
<p>The image above (from your “Graph of LDA” slide) is very important. *
<strong>Left:</strong> The ellipses show the true 95% probability
contours for three Gaussian classes. The dashed lines are the ideal
Bayes decision boundaries, which are perfectly linear because the
assumption of common covariance holds. * <strong>Right:</strong> This
shows a sample of data points drawn from those distributions. The solid
lines are the LDA decision boundaries calculated from the sample. They
are a very good estimate of the ideal boundaries. 上图（来自您的“LDA
图”幻灯片）非常重要。 *
<strong>左图：</strong>椭圆显示了三个高斯类别的真实 95%
概率轮廓。虚线是理想的贝叶斯决策边界，由于共同协方差假设成立，因此它们是完美的线性。
*
<strong>右图：</strong>这显示了从这些分布中抽取的数据点样本。实线是根据样本计算出的
LDA 决策边界。它们是对理想边界的非常好的估计。 ***</p>
<h2
id="practical-implementation-estimating-the-parameters-实际应用估计参数">Practical
Implementation: Estimating the Parameters 实际应用：估计参数</h2>
<p>In a real-world scenario, we don’t know the true parameters (<span
class="math inline">\(\mu_k\)</span>, <span
class="math inline">\(\Sigma\)</span>, <span
class="math inline">\(\pi_k\)</span>). Instead, we
<strong>estimate</strong> them from our training data (<span
class="math inline">\(n\)</span> total samples, with <span
class="math inline">\(n_k\)</span> samples in class <span
class="math inline">\(k\)</span>).
在实际场景中，我们不知道真正的参数（<span
class="math inline">\(\mu_k\)</span>、<span
class="math inline">\(\Sigma\)</span>、<span
class="math inline">\(\pi_k\)</span>）。相反，我们根据训练数据（<span
class="math inline">\(n\)</span> 个样本，<span
class="math inline">\(n_k\)</span> 个样本属于 <span
class="math inline">\(k\)</span> 类）来<strong>估计</strong>它们。</p>
<ul>
<li><strong>Prior Probability (<span
class="math inline">\(\hat{\pi}_k\)</span>):</strong> The proportion of
training samples in class <span class="math inline">\(k\)</span>. <span
class="math display">\[\hat{\pi}_k = \frac{n_k}{n}\]</span></li>
<li><strong>Class Mean (<span
class="math inline">\(\hat{\mu}_k\)</span>):</strong> The average of the
training samples in class <span class="math inline">\(k\)</span>. <span
class="math display">\[\hat{\mu}_k = \frac{1}{n_k} \sum_{i: y_i=k}
x_i\]</span></li>
<li><strong>Common Covariance (<span
class="math inline">\(\hat{\Sigma}\)</span>):</strong> A weighted
average of the sample covariance matrices for each class. This is often
called the “pooled” covariance. <span
class="math display">\[\hat{\Sigma} = \frac{1}{n-K} \sum_{k=1}^{K}
\sum_{i: y_i=k} (x_i - \hat{\mu}_k)(x_i - \hat{\mu}_k)^T\]</span></li>
<li><strong>先验概率 (<span
class="math inline">\(\hat{\pi}_k\)</span>)：</strong>训练样本在 <span
class="math inline">\(k\)</span> 类中的比例。 <span
class="math display">\[\hat{\pi}_k = \frac{n_k}{n}\]</span></li>
<li><strong>类别均值 (<span
class="math inline">\(\hat{\mu}_k\)</span>)：</strong>训练样本在 <span
class="math inline">\(k\)</span> 类中的平均值。 <span
class="math display">\[\hat{\mu}_k = \frac{1}{n_k} \sum_{i: y_i=k}
x_i\]</span></li>
<li><strong>公共协方差 (<span
class="math inline">\(\hat{\Sigma}\)</span>)：</strong>每个类的样本协方差矩阵的加权平均值。这通常被称为“合并”协方差。
<span class="math display">\[\hat{\Sigma} = \frac{1}{n-K} \sum_{k=1}^{K}
\sum_{i: y_i=k} (x_i - \hat{\mu}_k)(x_i - \hat{\mu}_k)^T\]</span></li>
</ul>
<p>We then plug these estimates into the discriminant function to get
<span class="math inline">\(\hat{\delta}_k(x)\)</span> and classify a
new observation <span class="math inline">\(x\)</span> to the class with
the largest score. 然后，我们将这些估计值代入判别函数，得到 <span
class="math inline">\(\hat{\delta}_k(x)\)</span>，并将新的观测值 <span
class="math inline">\(x\)</span> 归类到得分最高的类别。 ***</p>
<h2 id="evaluating-performance">Evaluating Performance</h2>
<p>After training the model, we evaluate its performance using a
<strong>confusion matrix</strong>.
训练模型后，我们使用<strong>混淆矩阵</strong>来评估其性能。</p>
<p>This matrix shows the true classes versus the predicted classes. *
<strong>Diagonal elements</strong> (9644, 81) are correct predictions. *
<strong>Off-diagonal elements</strong> (23, 252) are errors.
该矩阵显示了真实类别与预测类别的对比。 * <strong>对角线元素</strong>
(9644, 81) 表示正确预测。 * <strong>非对角线元素</strong> (23, 252)
表示错误预测。</p>
<p>From this matrix, we can calculate key metrics: * <strong>Overall
Error Rate:</strong> Total incorrect predictions / Total predictions. *
Example: <span class="math inline">\((252 + 23) / 10000 =
2.75\%\)</span> * <strong>Sensitivity (True Positive Rate):</strong>
Correctly predicted positives / Total actual positives. It answers: “Of
all the people who actually defaulted, what fraction did we catch?” *
Example: <span class="math inline">\(81 / 333 = 24.3\%\)</span>. The
sensitivity is <span class="math inline">\(1 - 75.7\% = 24.3\%\)</span>.
* <strong>Specificity (True Negative Rate):</strong> Correctly predicted
negatives / Total actual negatives. It answers: “Of all the people who
did not default, what fraction did we correctly identify?” * Example:
<span class="math inline">\(9644 / 9667 = 99.8\%\)</span>. The
specificity is <span class="math inline">\(1 - 0.24\% =
99.8\%\)</span>.</p>
<p>The example in your slides shows a high error rate for “default”
people (75.7%) because the classes are <strong>unbalanced</strong>—there
are far fewer defaulters. This highlights the importance of looking at
class-specific metrics, not just the overall error rate.</p>
<hr />
<h2 id="python-code-understanding">Python Code Understanding</h2>
<p>In Python, you can easily implement LDA using the
<code>scikit-learn</code> library. The code conceptually mirrors the
steps we discussed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, classification_report</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume you have your data X (features) and y (labels)</span></span><br><span class="line"><span class="comment"># X = features (e.g., balance, income)</span></span><br><span class="line"><span class="comment"># y = labels (e.g., 0 for &#x27;no-default&#x27;, 1 for &#x27;default&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Split data into training and testing sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Create an instance of the LDA model</span></span><br><span class="line">lda = LinearDiscriminantAnalysis()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Fit the model to the training data</span></span><br><span class="line"><span class="comment"># This is where the model calculates the estimates:</span></span><br><span class="line"><span class="comment">#  - Prior probabilities (pi_k)</span></span><br><span class="line"><span class="comment">#  - Class means (mu_k)</span></span><br><span class="line"><span class="comment">#  - Pooled covariance matrix (Sigma)</span></span><br><span class="line">lda.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Make predictions on new, unseen data</span></span><br><span class="line">predictions = lda.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Evaluate the model&#x27;s performance</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y_test, predictions))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nClassification Report:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, predictions))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LinearDiscriminantAnalysis()</code> creates the classifier
object.</li>
<li><code>lda.fit(X_train, y_train)</code> is the core training step
where the model learns the <span
class="math inline">\(\hat{\pi}_k\)</span>, <span
class="math inline">\(\hat{\mu}_k\)</span>, and <span
class="math inline">\(\hat{\Sigma}\)</span> parameters from the
data.</li>
<li><code>lda.predict(X_test)</code> uses the learned discriminant
function <span class="math inline">\(\hat{\delta}_k(x)\)</span> to
classify each sample in the test set.</li>
<li><code>confusion_matrix</code> and <code>classification_report</code>
are tools to evaluate the results, just like in the slides.</li>
</ul>
<h1
id="here-is-a-summary-of-the-provided-slides-on-linear-discriminant-analysis-lda-focusing-on-mathematical-concepts-python-code-interpretation-and-key-visuals.">6.
Here is a summary of the provided slides on Linear Discriminant Analysis
(LDA), focusing on mathematical concepts, Python code interpretation,
and key visuals.</h1>
<h2 id="core-concept-lda-for-classification">Core Concept: LDA for
Classification</h2>
<p>Linear Discriminant Analysis (LDA) is a classification method that
models the probability that an observation belongs to a certain class.
It works by finding a linear combination of features that best separates
two or more classes.</p>
<p>The decision is based on <strong>Bayes’ theorem</strong>. For a given
observation with features <span class="math inline">\(X=x\)</span>, LDA
calculates the <strong>posterior probability</strong>, <span
class="math inline">\(p_k(x) = Pr(Y=k|X=x)\)</span>, for each class
<span class="math inline">\(k\)</span>. This is the probability that the
observation belongs to class <span class="math inline">\(k\)</span>
given its features. 线性判别分析 (LDA)
是一种分类方法，它对观测值属于某个类别的概率进行建模。它的工作原理是找到能够最好地区分两个或多个类别的特征的线性组合。</p>
<p>该决策基于<strong>贝叶斯定理</strong>。对于特征为 <span
class="math inline">\(X=x\)</span> 的给定观测值，LDA 会计算每个类别
<span class="math inline">\(k\)</span>
的<strong>后验概率</strong>，<span class="math inline">\(p_k(x) =
Pr(Y=k|X=x)\)</span>。这是给定观测值的特征后，该观测值属于类别 <span
class="math inline">\(k\)</span> 的概率。</p>
<p>By default, the Bayes classifier assigns an observation to the class
with the highest posterior probability. For a binary (two-class) problem
like ‘Yes’ vs. ‘No’, this means:
默认情况下，贝叶斯分类器将观测值分配给后验概率最高的类别。对于像“是”与“否”这样的二分类问题，这意味着：</p>
<ul>
<li>Assign to ‘Yes’ if <span class="math inline">\(Pr(Y=\text{Yes}|X=x)
&gt; 0.5\)</span></li>
<li>Assign to ‘No’ otherwise</li>
</ul>
<h2 id="modifying-the-decision-threshold">Modifying the Decision
Threshold</h2>
<p>The default 0.5 threshold isn’t always optimal. In many real-world
scenarios, the cost of one type of error is much higher than another.
For example, in credit card default prediction: 默认的 0.5
阈值并非总是最优的。在许多实际场景中，一种错误的代价远高于另一种。例如，在信用卡违约预测中：</p>
<ul>
<li><strong>False Negative:</strong> Incorrectly classifying a person
who will default as someone who won’t. (The bank loses money).</li>
<li><strong>False Positive:</strong> Incorrectly classifying a person
who won’t default as someone who will. (The bank loses a potential
customer).</li>
</ul>
<p>A bank might decide that missing a defaulter is much worse than
denying a good customer. To catch more potential defaulters, they can
<strong>lower the probability threshold</strong>.
银行可能会认为错过一个违约者比拒绝一个优质客户更糟糕。为了捕捉更多潜在的违约者，他们可以<strong>降低概率阈值</strong>。</p>
<p>A modified rule could be: <span class="math display">\[
Pr(\text{default}=\text{Yes}|X=x) &gt; 0.2
\]</span> This makes the model more “sensitive” to flagging potential
defaulters, even at the cost of misclassifying more non-defaulters.
降低阈值<strong>会提高敏感度</strong>，但<strong>会降低特异性</strong>。</p>
<p>This decision leads to a <strong>trade-off</strong> between two key
performance metrics: * <strong>Sensitivity (True Positive
Rate):</strong> The ability to correctly identify positive cases. (e.g.,
<code>Correctly identified defaulters / Total actual defaulters</code>).
* <strong>Specificity (True Negative Rate):</strong> The ability to
correctly identify negative cases. (e.g.,
<code>Correctly identified non-defaulters / Total actual non-defaulters</code>).</p>
<p>这一决策会导致两个关键绩效指标之间的<strong>权衡</strong>： *
<strong>敏感度（真阳性率）：</strong>正确识别阳性案例的能力。（例如，“正确识别的违约者/实际违约者总数”）。
*
<strong>特异性（真阴性率）：</strong>正确识别阴性案例的能力。（例如，“正确识别的非违约者/实际非违约者总数”）。</p>
<p>Lowering the threshold <strong>increases sensitivity</strong> but
<strong>decreases specificity</strong>. ## Python Code Explained</p>
<p>The slides show how to implement and adjust LDA using Python’s
<code>scikit-learn</code> library.</p>
<h2 id="basic-lda-implementation">Basic LDA Implementation</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the necessary library</span></span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize and train the LDA model</span></span><br><span class="line">lda = LinearDiscriminantAnalysis()</span><br><span class="line">lda_train = lda.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get predictions using the default 0.5 threshold</span></span><br><span class="line">y_pred = lda.predict(X)</span><br></pre></td></tr></table></figure>
<p>This code trains an LDA model and makes predictions using the
standard 50% probability boundary.</p>
<h2 id="adjusting-the-prediction-threshold">Adjusting the Prediction
Threshold</h2>
<p>To use a custom threshold (e.g., 0.2), you don’t use the
<code>.predict()</code> method. Instead, you get the class probabilities
with <code>.predict_proba()</code> and apply the threshold manually.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Get the probabilities for each class</span></span><br><span class="line"><span class="comment"># lda.predict_proba(X) returns an array like [[P(No), P(Yes)], ...]</span></span><br><span class="line"><span class="comment"># We select the second column [:, 1] for the &#x27;Yes&#x27; class probability</span></span><br><span class="line">lda_probs = lda.predict_proba(X)[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Define a custom threshold</span></span><br><span class="line">threshold = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Apply the threshold to get new predictions</span></span><br><span class="line"><span class="comment"># This creates a boolean array (True where prob &gt; 0.2, else False)</span></span><br><span class="line"><span class="comment"># We then convert True/False to &#x27;Yes&#x27;/&#x27;No&#x27; labels</span></span><br><span class="line">lda_pred1 = np.where(lda_probs &gt; threshold, <span class="string">&quot;Yes&quot;</span>, <span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>This is the core technique for tuning the classifier’s behavior to
meet specific business needs, as demonstrated on slides 55 and 56 for
both LDA and Logistic Regression.</p>
<h2 id="important-images-to-understand">Important Images to
Understand</h2>
<ol type="1">
<li><strong>Confusion Matrix (Slide 49):</strong> This table is crucial.
It breaks down the model’s predictions into True Positives, True
Negatives, False Positives, and False Negatives. All key metrics like
error rate, sensitivity, and specificity are calculated from this
matrix. <strong>混淆矩阵（幻灯片
49）：</strong>这张表至关重要。它将模型的预测分解为真阳性、真阴性、假阳性和假阴性。所有关键指标，例如错误率、灵敏度和特异性，都基于此矩阵计算得出。</li>
<li><strong>LDA Decision Boundaries (Slide 51):</strong> This plot
provides a powerful visual intuition. It shows the data points for two
classes and the decision boundary line. The different parallel lines
show how changing the threshold from 0.5 to 0.1 or 0.9 shifts the
boundary, making the model classify more or fewer points into the
minority class. <strong>LDA 决策边界（幻灯片
51）：</strong>这张图提供了强大的视觉直观性。它展示了两个类别的数据点和决策边界线。不同的平行线显示了将阈值从
0.5 更改为 0.1 或 0.9
时边界如何移动，从而使模型将更多或更少的点归入少数类</li>
<li><strong>Error Rate Tradeoff Curve (Slide 53):</strong> This graph is
the most important for understanding the business implication of
changing the threshold. It clearly shows that as the threshold changes,
the error rate for one class goes down while the error rate for the
other goes up. The overall error is minimized at a certain point, but
that may not be the optimal point from a business perspective.
<strong>错误率权衡曲线（幻灯片
53）：</strong>这张图对于理解更改阈值的业务含义至关重要。它清楚地表明，随着阈值的变化，一个类别的错误率下降，而另一个类别的错误率上升。总体误差在某个点达到最小，但从业务角度来看，这可能并非最佳点。</li>
<li><strong>ROC Curve (Slides 54 &amp; 55):</strong> The Receiver
Operating Characteristic (ROC) curve plots Sensitivity vs. (1 -
Specificity) for <em>all possible thresholds</em>. An ideal classifier
has a curve that “hugs” the top-left corner, indicating high sensitivity
and high specificity. It’s a standard way to visualize and compare the
overall performance of different classifiers. <strong>ROC 曲线（幻灯片
54 和 55）：</strong> 接收者操作特性 (ROC)
曲线绘制了<em>所有可能阈值</em>的灵敏度与（1 -
特异性）的关系。理想的分类器曲线“紧贴”左上角，表示高灵敏度和高特异性。这是可视化和比较不同分类器整体性能的标准方法。</li>
</ol>
<h1
id="here-is-a-summary-of-the-provided-slides-on-linear-and-quadratic-discriminant-analysis-including-the-key-formulas-python-code-equivalents-and-explanations-of-the-important-concepts.">7.
Here is a summary of the provided slides on Linear and Quadratic
Discriminant Analysis, including the key formulas, Python code
equivalents, and explanations of the important concepts.</h1>
<h2 id="key-goal-classification"><strong>Key Goal:
Classification</strong></h2>
<p>Both <strong>Linear Discriminant Analysis (LDA)</strong> and
<strong>Quadratic Discriminant Analysis (QDA)</strong> are
classification algorithms. Their main goal is to find a decision
boundary to separate different classes (e.g., “default” vs. “not
default”) in the data. <strong>线性判别分析 (LDA)</strong> 和
<strong>二次判别分析 (QDA)</strong>
都是分类算法。它们的主要目标是找到一个决策边界来区分数据中的不同类别（例如，“默认”与“非默认”）。</p>
<h3 id="linear-discriminant-analysis-lda">## Linear Discriminant
Analysis (LDA)</h3>
<p>LDA creates a <strong>linear</strong> decision boundary between
classes. LDA 在类别之间创建<strong>线性</strong>决策边界。</p>
<h4 id="core-idea-fishers-interpretation"><strong>Core Idea (Fisher’s
Interpretation)</strong></h4>
<p>Imagine you have data points for different classes in a 3D space.
Fisher’s idea is to find the best angle to shine a “flashlight” on the
data to project its shadow onto a 2D wall (or a 1D line). The “best”
projection is the one where the shadows of the different classes are
<strong>as far apart from each other as possible</strong>, while the
shadows within each class are <strong>as tightly packed as
possible</strong>. 想象一下，你在三维空间中拥有不同类别的数据点。Fisher
的思想是找到最佳角度，用“手电筒”照射数据，将其阴影投射到二维墙壁（或一维线上）。
“最佳”投影是不同类别的阴影<strong>彼此之间尽可能远</strong>，而每个类别内的阴影<strong>尽可能紧密</strong>的投影。</p>
<ul>
<li><strong>Maximize:</strong> The distance between the means of the
projected classes (Between-Class Variance).
投影类别均值之间的距离（类间方差）。</li>
<li><strong>Minimize:</strong> The spread or variance within each
projected class (Within-Class Variance).
每个投影类别内的扩散或方差（类内方差）。 This is the most important
image for understanding the intuition behind LDA. It shows how
projecting the data onto a specific line (defined by vector
<code>w</code>) can make the two classes clearly separable.
这是理解LDA背后直觉的最重要图像。它展示了如何将数据投影到特定直线（由向量“w”定义）上，从而使两个类别清晰可分。</li>
</ul>
<h4 id="key-mathematical-formulas"><strong>Key Mathematical
Formulas</strong></h4>
<p>To achieve this, LDA maximizes a ratio called the <strong>Rayleigh
quotient</strong>. LDA最大化一个称为<strong>瑞利商</strong>的比率。</p>
<ol type="1">
<li><strong>Within-Class Covariance (<span
class="math inline">\(\hat{\Sigma}_W\)</span>)</strong>: Measures the
spread of data <em>inside</em> each class. <strong>类内协方差 (<span
class="math inline">\(\hat{\Sigma}_W\)</span>)</strong>：衡量每个类别<em>内部</em>数据的扩散程度。
<span class="math display">\[\hat{\Sigma}_W = \frac{1}{n-K}
\sum_{k=1}^{K} \sum_{i: y_i=k} (x_i - \hat{\mu}_k)(x_i -
\hat{\mu}_k)^\top\]</span></li>
<li><strong>Between-Class Covariance (<span
class="math inline">\(\hat{\Sigma}_B\)</span>)</strong>: Measures the
spread <em>between</em> the means of different classes.
<strong>类间协方差 (<span
class="math inline">\(\hat{\Sigma}_B\)</span>)</strong>：衡量不同类别均值<em>之间</em>的差异。
<span class="math display">\[\hat{\Sigma}_B = \sum_{k=1}^{K} n_k
(\hat{\mu}_k - \hat{\mu})(\hat{\mu}_k - \hat{\mu})^\top\]</span></li>
<li><strong>Objective Function</strong>: Find the projection vector
<span class="math inline">\(w\)</span> that maximizes the ratio of
between-class variance to within-class variance.
<strong>目标函数</strong>：找到投影向量 <span
class="math inline">\(w\)</span>，使类间方差与类内方差之比最大化。 <span
class="math display">\[\max_w \frac{w^\top \hat{\Sigma}_B w}{w^\top
\hat{\Sigma}_W w}\]</span></li>
</ol>
<h4 id="ldas-main-assumption"><strong>LDA’s Main
Assumption</strong></h4>
<p>The key assumption of LDA is that all classes share the <strong>same
covariance matrix (<span
class="math inline">\(\Sigma\)</span>)</strong>. They can have different
means (<span class="math inline">\(\mu_k\)</span>), but their spread and
orientation must be identical. This assumption is what results in a
linear decision boundary. LDA
的关键假设是所有类别共享<strong>相同的协方差矩阵 (<span
class="math inline">\(\Sigma\)</span>)</strong>。它们可以具有不同的均值
(<span
class="math inline">\(\mu_k\)</span>)，但它们的散度和方向必须相同。正是这一假设导致了线性决策边界。</p>
<h3 id="quadratic-discriminant-analysis-qda">## Quadratic Discriminant
Analysis (QDA)</h3>
<p>QDA is a more flexible extension of LDA that creates a
<strong>quadratic</strong> (curved) decision boundary. QDA 是 LDA
的更灵活的扩展，它创建了<strong>二次</strong>（曲线）决策边界。 ####
<strong>Core Idea &amp; Key Assumption</strong></p>
<p>QDA starts with the same principles as LDA but drops the key
assumption. QDA assumes that <strong>each class has its own unique
covariance matrix (<span
class="math inline">\(\Sigma_k\)</span>)</strong>. QDA 的原理与 LDA
相同，但放弃了关键假设。QDA 假设<strong>每个类别都有自己独特的协方差矩阵
(<span class="math inline">\(\Sigma_k\)</span>)</strong>。</p>
<p>This means each class can have its own spread, shape, and
orientation. This additional flexibility allows for a more complex,
curved decision boundary.
这意味着每个类别可以拥有自己的散度、形状和方向。这种额外的灵活性使得决策边界更加复杂、曲线化。</p>
<h4 id="key-mathematical-formula"><strong>Key Mathematical
Formula</strong></h4>
<p>The classification is made using a discrimination function, <span
class="math inline">\(\delta_k(x)\)</span>. We assign a data point <span
class="math inline">\(x\)</span> to the class <span
class="math inline">\(k\)</span> for which <span
class="math inline">\(\delta_k(x)\)</span> is largest. The function for
QDA is: <span class="math display">\[\delta_k(x) = -\frac{1}{2}(x -
\mu_k)^\top \Sigma_k^{-1}(x - \mu_k) - \frac{1}{2}\log(|\Sigma_k|) +
\log \pi_k\]</span> The term containing <span
class="math inline">\(x^\top \Sigma_k^{-1} x\)</span> makes this
function a <strong>quadratic</strong> function of <span
class="math inline">\(x\)</span>.</p>
<h3 id="lda-vs.-qda-the-trade-off">## LDA vs. QDA: The Trade-Off</h3>
<p>The choice between LDA and QDA is a classic <strong>bias-variance
trade-off</strong>. 在 LDA 和 QDA
之间进行选择是典型的<strong>偏差-方差权衡</strong>。</p>
<ul>
<li><p><strong>Use LDA when:</strong></p>
<ul>
<li>The assumption of a common covariance matrix is reasonable (the
classes have similar shapes).</li>
<li>You have a small amount of training data, as LDA is less prone to
overfitting.</li>
<li>Simplicity is preferred. LDA is less flexible (high bias) but has
lower variance.</li>
<li>假设共同协方差矩阵是合理的（类别具有相似的形状）。</li>
<li>训练数据量较少，因为 LDA 不易过拟合。</li>
<li>简洁是首选。LDA 灵活性较差（偏差较大），但方差较小。</li>
</ul></li>
<li><p><strong>Use QDA when:</strong></p>
<ul>
<li>The classes have clearly different shapes and spreads (different
covariance matrices).</li>
<li>You have a large amount of training data to properly estimate the
separate covariance matrices for each class.</li>
<li>QDA is more flexible (low bias) but can have high variance, meaning
it might overfit on smaller datasets.</li>
<li>类别具有明显不同的形状和分布（不同的协方差矩阵）。</li>
<li>拥有大量训练数据，可以正确估计每个类别的独立协方差矩阵。</li>
<li>QDA
更灵活（偏差较小），但方差较大，这意味着它可能在较小的数据集上过拟合。
<strong>Rule of Thumb:</strong> If the class variances are equal or
close, LDA is better. Otherwise, QDA is better.
<strong>经验法则：</strong> 如果类别方差相等或接近，则 LDA
更佳。否则，QDA 更好。</li>
</ul></li>
</ul>
<h3 id="code-understanding-python-equivalent">## Code Understanding
(Python Equivalent)</h3>
<p>The slides show code in R. Here’s how you would perform LDA and
evaluate it in Python using the popular <code>scikit-learn</code>
library.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score, roc_curve, auc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume &#x27;df&#x27; is your DataFrame with features and a &#x27;target&#x27; column</span></span><br><span class="line"><span class="comment"># X = df.drop(&#x27;target&#x27;, axis=1)</span></span><br><span class="line"><span class="comment"># y = df[&#x27;target&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Split data into training and testing sets</span></span><br><span class="line"><span class="comment"># X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Fit an LDA model (equivalent to lda() in R)</span></span><br><span class="line">lda = LinearDiscriminantAnalysis()</span><br><span class="line">lda.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Make predictions (equivalent to predict() in R)</span></span><br><span class="line">y_pred_lda = lda.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># To fit a QDA model, the process is identical:</span></span><br><span class="line"><span class="comment"># qda = QuadraticDiscriminantAnalysis()</span></span><br><span class="line"><span class="comment"># qda.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment"># y_pred_qda = qda.predict(X_test)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create a confusion matrix (equivalent to table())</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LDA Confusion Matrix:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y_test, y_pred_lda))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Plot the ROC Curve (equivalent to the R code for ROC)</span></span><br><span class="line"><span class="comment"># Get prediction probabilities for the positive class</span></span><br><span class="line">y_pred_proba = lda.predict_proba(X_test)[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate ROC curve points</span></span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate Area Under the Curve (AUC)</span></span><br><span class="line">roc_auc = auc(fpr, tpr)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(fpr, tpr, color=<span class="string">&#x27;blue&#x27;</span>, lw=<span class="number">2</span>, label=<span class="string">f&#x27;LDA ROC curve (area = <span class="subst">&#123;roc_auc:<span class="number">.2</span>f&#125;</span>)&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], color=<span class="string">&#x27;gray&#x27;</span>, lw=<span class="number">2</span>, linestyle=<span class="string">&#x27;--&#x27;</span>) <span class="comment"># Random guess line</span></span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Positive Rate (1 - Specificity)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Positive Rate (Sensitivity)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Receiver Operating Characteristic (ROC) Curve&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="understanding-the-roc-curve"><strong>Understanding the ROC
Curve</strong></h4>
<p>The <strong>ROC Curve</strong> is another important image. It helps
you visualize a classifier’s performance across all possible
classification thresholds. <strong>ROC 曲线</strong>
是另一个重要的图像。它可以帮助您直观地了解分类器在所有可能的分类阈值下的性能。</p>
<ul>
<li>The <strong>Y-axis</strong> is the <strong>True Positive
Rate</strong> (Sensitivity): “Of all the actual positives, how many did
we correctly identify?”</li>
<li>The <strong>X-axis</strong> is the <strong>False Positive
Rate</strong>: “Of all the actual negatives, how many did we incorrectly
label as positive?”</li>
<li>A perfect classifier would have a curve that goes straight up to the
top-left corner (100% TPR, 0% FPR). The diagonal line represents a
random guess. The <strong>Area Under the Curve (AUC)</strong> summarizes
the model’s performance; a value closer to 1.0 is better.</li>
<li><strong>Y 轴</strong>
表示<strong>真阳性率</strong>（敏感度）：“在所有实际的阳性样本中，我们正确识别了多少个？”</li>
<li><strong>X 轴</strong>
表示<strong>假阳性率</strong>：“在所有实际的阴性样本中，我们错误地将多少个标记为阳性？”</li>
<li>一个完美的分类器应该有一条直线上升到左上角的曲线（真阳性率
100%，假阳性率 0%）。对角线表示随机猜测。<strong>曲线下面积
(AUC)</strong> 概括了模型的性能；该值越接近 1.0 越好。</li>
</ul>
<h1
id="here-is-a-summary-of-the-provided-slides-on-quadratic-discriminant-analysis-qda-including-the-key-formulas-code-explanations-with-python-equivalents-and-a-guide-to-the-most-important-images.">8.
Here is a summary of the provided slides on Quadratic Discriminant
Analysis (QDA), including the key formulas, code explanations with
Python equivalents, and a guide to the most important images.</h1>
<h3 id="core-concept-qda-vs.-lda">## Core Concept: QDA vs. LDA</h3>
<p>The main difference between <strong>Linear Discriminant Analysis
(LDA)</strong> and <strong>Quadratic Discriminant Analysis
(QDA)</strong> lies in their assumptions about the data.
<strong>线性判别分析 (LDA)</strong> 和 <strong>二次判别分析
(QDA)</strong> 的主要区别在于它们对数据的假设。 * <strong>LDA</strong>
assumes that all classes share the <strong>same covariance
matrix</strong> (<span class="math inline">\(\Sigma\)</span>). It models
each class as a normal distribution with a different mean (<span
class="math inline">\(\mu_k\)</span>) but the same shape and
orientation. This results in a <em>linear</em> decision boundary between
classes. 假设所有类别共享<strong>相同的协方差矩阵</strong> (<span
class="math inline">\(\Sigma\)</span>)。它将每个类别建模为均值不同
(<span class="math inline">\(\mu_k\)</span>)
但形状和方向相同的正态分布。这会导致类别之间出现 <em>线性</em>
决策边界。 * <strong>QDA</strong> is more flexible. It assumes that each
class <span class="math inline">\(k\)</span> has its <strong>own,
separate covariance matrix</strong> (<span
class="math inline">\(\Sigma_k\)</span>). This allows each class’s
distribution to have a unique shape, size, and orientation. This
flexibility results in a <em>quadratic</em> decision boundary (like a
parabola, hyperbola, or ellipse). 更灵活。它假设每个类别 <span
class="math inline">\(k\)</span> 都有其<strong>独立的协方差矩阵</strong>
(<span
class="math inline">\(\Sigma_k\)</span>)。这使得每个类别的分布具有独特的形状、大小和方向。这种灵活性导致了<em>二次</em>决策边界（类似于抛物线、双曲线或椭圆）。
<strong>Analogy</strong> 💡: Imagine you’re drawing boundaries around
different clusters of stars. LDA gives you only straight lines to
separate the clusters. QDA gives you curved lines (circles, ellipses),
which can create a much better fit if the clusters themselves are
elliptical and point in different directions.
想象一下，你正在围绕不同的星团绘制边界。LDA 只提供直线来分隔星团。QDA
提供曲线（圆形、椭圆形），如果星团本身是椭圆形且指向不同的方向，则可以产生更好的拟合效果。</p>
<h3 id="the-math-behind-qda">## The Math Behind QDA</h3>
<p>QDA classifies a new observation <span
class="math inline">\(x\)</span> to the class <span
class="math inline">\(k\)</span> that has the highest discriminant
score, <span class="math inline">\(\delta_k(x)\)</span>. The formula for
this score is what makes the boundary quadratic. QDA 将新的观测值 <span
class="math inline">\(x\)</span> 归类到具有最高判别分数 <span
class="math inline">\(\delta_k(x)\)</span> 的类 <span
class="math inline">\(k\)</span>
中。该分数的公式使得边界具有二次项。</p>
<p>The discriminant function for class <span
class="math inline">\(k\)</span> is: <span
class="math display">\[\delta_k(x) = -\frac{1}{2}(x - \mu_k)^T
\Sigma_k^{-1}(x - \mu_k) - \frac{1}{2}\log(|\Sigma_k|) +
\log(\pi_k)\]</span></p>
<p>Let’s break it down:</p>
<ul>
<li><span class="math inline">\((x - \mu_k)^T \Sigma_k^{-1}(x -
\mu_k)\)</span>: This is a quadratic term (since it involves <span
class="math inline">\(x^T \Sigma_k^{-1} x\)</span>). It measures the
squared Mahalanobis distance from <span class="math inline">\(x\)</span>
to the class mean <span class="math inline">\(\mu_k\)</span>, scaled by
that class’s specific covariance <span
class="math inline">\(\Sigma_k\)</span>.</li>
<li><span class="math inline">\(\log(|\Sigma_k|)\)</span>: A term that
penalizes classes with larger variance.</li>
<li><span class="math inline">\(\log(\pi_k)\)</span>: The prior
probability of class <span class="math inline">\(k\)</span>. This is our
initial belief about how likely class <span
class="math inline">\(k\)</span> is, before seeing the data.
<ul>
<li><span class="math inline">\((x - \mu_k)^T \Sigma_k^{-1}(x -
\mu_k)\)</span>：这是一个二次项（因为它涉及 <span
class="math inline">\(x^T \Sigma_k^{-1} x\)</span>）。它测量从 <span
class="math inline">\(x\)</span> 到类均值 <span
class="math inline">\(\mu_k\)</span>
的平方马氏距离，并根据该类的特定协方差 <span
class="math inline">\(\Sigma_k\)</span> 进行缩放。</li>
<li><span
class="math inline">\(\log(|\Sigma_k|)\)</span>：用于惩罚方差较大的类的项。</li>
<li><span class="math inline">\(\log(\pi_k)\)</span>：类 <span
class="math inline">\(k\)</span> 的先验概率。这是我们在看到数据之前对类
<span class="math inline">\(k\)</span> 可能性的初始信念。 Because each
class <span class="math inline">\(k\)</span> has its own <span
class="math inline">\(\Sigma_k\)</span>, the quadratic term doesn’t
cancel out when comparing scores between classes, leading to a quadratic
boundary. 由于每个类 <span class="math inline">\(k\)</span> 都有其自己的
<span
class="math inline">\(\Sigma_k\)</span>，因此在比较类之间的分数时，二次项不会抵消，从而导致二次边界。
<strong>Key Trade-off</strong>:</li>
</ul></li>
<li>If the class variances (<span
class="math inline">\(\Sigma_k\)</span>) are truly different,
<strong>QDA is better</strong>.</li>
<li>If the class variances are similar, <strong>LDA is often
better</strong> because it’s less flexible and less likely to overfit,
especially with a small number of training samples.</li>
<li>如果类方差 (<span class="math inline">\(\Sigma_k\)</span>)
确实不同，<strong>QDA 更好</strong>。</li>
<li>如果类方差相似，<strong>LDA
通常更好</strong>，因为它的灵活性较差，并且不太可能过拟合，尤其是在训练样本数量较少的情况下。</li>
</ul>
<h3 id="code-implementation-r-and-python">## Code Implementation: R and
Python</h3>
<p>The slides provide R code for fitting a QDA model and evaluating it.
Below is an explanation of the R code and its equivalent in Python using
the popular <code>scikit-learn</code> library.</p>
<h4 id="r-code-from-the-slides">R Code (from the slides)</h4>
<p>The code uses the <code>MASS</code> library for QDA and the
<code>ROCR</code> library for evaluation.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ######## QDA ##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Fit the model on the training data</span></span><br><span class="line"><span class="comment"># This formula `Default~.` means &quot;predict &#x27;Default&#x27; using all other variables&quot;.</span></span><br><span class="line">qda.fit.mod2 <span class="operator">&lt;-</span> qda<span class="punctuation">(</span>Default<span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Default<span class="punctuation">,</span> subset<span class="operator">=</span>train.ids<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Make predictions on the test data</span></span><br><span class="line"><span class="comment"># We are interested in the posterior probabilities for the ROC curve</span></span><br><span class="line">qda.fit.pred3 <span class="operator">&lt;-</span> predict<span class="punctuation">(</span>qda.fit.mod2<span class="punctuation">,</span> Default_test<span class="punctuation">)</span><span class="operator">$</span>posterior<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Evaluate using ROC and AUC</span></span><br><span class="line"><span class="comment"># &#x27;prediction&#x27; and &#x27;performance&#x27; are functions from the ROCR library</span></span><br><span class="line">perf <span class="operator">&lt;-</span> performance<span class="punctuation">(</span>prediction<span class="punctuation">(</span>qda.fit.pred3<span class="punctuation">,</span> Default_test<span class="operator">$</span>Default<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;auc&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Get the AUC value</span></span><br><span class="line">auc_value <span class="operator">&lt;-</span> perf<span class="operator">@</span>y.values<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># Result from slide: 0.9638683</span></span><br></pre></td></tr></table></figure>
<h4 id="python-equivalent-scikit-learn">Python Equivalent
(<code>scikit-learn</code>)</h4>
<p>Here’s how you would perform the same steps in Python.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> QuadraticDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score, roc_curve</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume &#x27;Default&#x27; is your DataFrame and &#x27;default&#x27; is the target column</span></span><br><span class="line"><span class="comment"># (preprocessing &#x27;student&#x27; and &#x27;default&#x27; columns to numbers)</span></span><br><span class="line"><span class="comment"># Default[&#x27;default_num&#x27;] = Default[&#x27;default&#x27;].apply(lambda x: 1 if x == &#x27;Yes&#x27; else 0)</span></span><br><span class="line"><span class="comment"># X = Default[[&#x27;balance&#x27;, &#x27;income&#x27;, ...]]</span></span><br><span class="line"><span class="comment"># y = Default[&#x27;default_num&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Split data into training and testing sets</span></span><br><span class="line"><span class="comment"># X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=42)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Initialize and fit the QDA model</span></span><br><span class="line">qda = QuadraticDiscriminantAnalysis()</span><br><span class="line">qda.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Predict probabilities on the test set</span></span><br><span class="line"><span class="comment"># We need the probability of the positive class (&#x27;Yes&#x27;) for the AUC calculation</span></span><br><span class="line">y_pred_proba = qda.predict_proba(X_test)[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Calculate the AUC score</span></span><br><span class="line">auc_score = roc_auc_score(y_test, y_pred_proba)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;AUC Score for QDA: <span class="subst">&#123;auc_score:<span class="number">.7</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can also plot the ROC curve</span></span><br><span class="line"><span class="comment"># fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)</span></span><br><span class="line"><span class="comment"># plt.plot(fpr, tpr)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br></pre></td></tr></table></figure>
<h3 id="model-evaluation-roc-and-auc">## Model Evaluation: ROC and
AUC</h3>
<p>The slides correctly emphasize using the <strong>ROC curve</strong>
and the <strong>Area Under the Curve (AUC)</strong> to compare model
performance.</p>
<ul>
<li><p><strong>ROC Curve (Receiver Operating Characteristic)</strong>:
This plot shows how well a model can distinguish between two classes. It
plots the <strong>True Positive Rate</strong> (y-axis) against the
<strong>False Positive Rate</strong> (x-axis) at all possible
classification thresholds. A better model has a curve that is closer to
the top-left corner.</p></li>
<li><p><strong>AUC (Area Under the Curve)</strong>: This is a single
number that summarizes the entire ROC curve.</p>
<ul>
<li><strong>AUC = 1</strong>: Perfect classifier.</li>
<li><strong>AUC = 0.5</strong>: A useless classifier (equivalent to
random guessing).</li>
<li><strong>AUC &gt; 0.7</strong>: Generally considered an acceptable
model.</li>
</ul></li>
<li><p><strong>ROC
曲线（接收者操作特征）</strong>：此图显示了模型区分两个类别的能力。它绘制了所有可能的分类阈值下的
<strong>真阳性率</strong>（y 轴）与 <strong>假阳性率</strong>（x
轴）的对比图。更好的模型的曲线越靠近左上角，效果就越好。</p>
<ul>
<li><p><strong>AUC（曲线下面积）</strong>：这是一个概括整个 ROC
曲线的数值。</p></li>
<li><p><strong>AUC = 1</strong>：完美的分类器。</p></li>
<li><p><strong>AUC =
0.5</strong>：无用的分类器（相当于随机猜测）。</p></li>
<li><p><strong>AUC &gt;
0.7</strong>：通常被认为是可接受的模型。</p></li>
</ul></li>
</ul>
<p>The slides show that for the <code>Default</code> dataset,
<strong>LDA’s AUC (0.9647) was slightly higher than QDA’s
(0.9639)</strong>. This suggests that the assumption of a common
covariance matrix (LDA) was a slightly better fit for this particular
test set, possibly because QDA’s extra flexibility wasn’t needed and it
may have slightly overfit the training data.
这表明，对于这个特定的测试集，公共协方差矩阵 (LDA)
的假设拟合度略高，可能是因为 QDA
的额外灵活性并非必需，并且可能对训练数据略微过拟合。</p>
<h3 id="key-takeaways-and-important-images">## Key Takeaways and
Important Images</h3>
<h3
id="heres-a-ranking-of-the-most-important-visual-aids-in-your-slides">Here’s
a ranking of the most important visual aids in your slides:</h3>
<ol type="1">
<li><p><strong>Slide 68/69 (Model Assumption &amp; Formula)</strong>:
These are the <strong>most critical</strong> slides. They present the
core theoretical difference between LDA and QDA and provide the
mathematical foundation (the discriminant function formula).
Understanding these is key to understanding QDA.</p></li>
<li><p><strong>Slide 73 (ROC Comparison)</strong>: This is the most
important image for <strong>practical evaluation</strong>. It visually
compares the performance of LDA and QDA side-by-side, making it easy to
see which one performs better on this specific dataset. The concept of
AUC is introduced here as the method for comparison.</p></li>
<li><p><strong>Slide 71 (Decision Boundaries with Different
Thresholds)</strong>: This is an excellent conceptual image. It shows
how the quadratic decision boundary (the curved lines) separates the
data points. It also illustrates how changing the probability threshold
(from 0.1 to 0.5 to 0.9) shifts the boundary, trading off between
precision and recall.</p></li>
</ol>
<p>Of course. Here is a summary of the remaining slides, which compare
QDA to other popular classification models like Logistic Regression and
K-Nearest Neighbors (KNN).</p>
<hr />
<h3 id="visualizing-the-core-trade-off-lda-vs.-qda">Visualizing the Core
Trade-off: LDA vs. QDA</h3>
<p>This is the most important concept in these slides. The choice
between LDA and QDA depends entirely on the underlying structure of your
data.</p>
<p>The slide shows two scenarios: 1. <strong>Left Plot (<span
class="math inline">\(\Sigma_1 = \Sigma_2\)</span>):</strong> When the
true covariance matrices of the classes are the same, the optimal
decision boundary (the Bayes classifier) is a straight line. LDA, which
assumes equal covariances, creates a linear boundary that approximates
this optimal boundary very well. QDA’s flexible, curved boundary is
unnecessarily complex and might overfit the training data. <strong>In
this case, LDA is better.</strong> 2. <strong>Right Plot (<span
class="math inline">\(\Sigma_1 \neq \Sigma_2\)</span>):</strong> When
the true covariance matrices are different, the optimal decision
boundary is a curve. QDA’s quadratic model can capture this
non-linearity much better than LDA’s rigid linear model. <strong>In this
case, QDA is better.</strong></p>
<p>This perfectly illustrates the <strong>bias-variance
tradeoff</strong>. LDA has higher bias (it’s less flexible) but lower
variance. QDA has lower bias (it’s more flexible) but higher
variance.</p>
<hr />
<h3 id="comparing-performance-on-the-default-dataset">Comparing
Performance on the “Default” Dataset</h3>
<p>The slides compare four different models on the same classification
task. Let’s look at their performance using the <strong>Area Under the
Curve (AUC)</strong>, where a higher score is better.</p>
<ul>
<li><strong>LDA AUC:</strong> 0.9647</li>
<li><strong>QDA AUC:</strong> 0.9639</li>
<li><strong>Logistic Regression AUC:</strong> 0.9645</li>
<li><strong>K-Nearest Neighbors (KNN):</strong> The plot shows test
error vs. K. The error is lowest around K=4, but it’s not directly
converted to an AUC score in the slides.</li>
</ul>
<p>Interestingly, for this particular dataset, LDA, QDA, and Logistic
Regression perform almost identically. This suggests that the decision
boundary for this problem is likely very close to linear, meaning the
extra flexibility of QDA isn’t providing much benefit.</p>
<hr />
<h3 id="pros-and-cons-which-model-to-choose">Pros and Cons: Which Model
to Choose?</h3>
<p>The final slide asks for a comparison of the models. Here’s a summary
of their key characteristics:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Decision Boundary</th>
<th style="text-align: left;">Key Pro</th>
<th style="text-align: left;">Key Con</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Logistic Regression</strong></td>
<td style="text-align: left;">Parametric</td>
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">Highly interpretable, no strong
assumptions about data distribution.</td>
<td style="text-align: left;">Inflexible; cannot capture non-linear
relationships.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Linear Discriminant Analysis
(LDA)</strong></td>
<td style="text-align: left;">Parametric</td>
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">More stable than Logistic Regression when
classes are well-separated.</td>
<td style="text-align: left;">Assumes data is normally distributed with
equal covariance matrices for all classes.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Quadratic Discriminant Analysis
(QDA)</strong></td>
<td style="text-align: left;">Parametric</td>
<td style="text-align: left;">Quadratic (Curved)</td>
<td style="text-align: left;">More flexible than LDA; can model
non-linear boundaries.</td>
<td style="text-align: left;">Requires more data to estimate parameters
and is more prone to overfitting. Assumes normality.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>K-Nearest Neighbors
(KNN)</strong></td>
<td style="text-align: left;">Non-Parametric</td>
<td style="text-align: left;">Highly Non-linear</td>
<td style="text-align: left;">Extremely flexible; makes no assumptions
about the data’s distribution.</td>
<td style="text-align: left;">Can be slow on large datasets and suffers
from the “curse of dimensionality.” Less interpretable.</td>
</tr>
</tbody>
</table>
<h4 id="summary-of-the-comparison">Summary of the Comparison:</h4>
<ul>
<li><strong>Linear Models (Logistic Regression &amp; LDA):</strong>
Choose these for simplicity, interpretability, and when you believe the
relationship between predictors and the class is linear. LDA often
outperforms Logistic Regression if its normality assumptions are
met.</li>
<li><strong>Non-Linear Models (QDA &amp; KNN):</strong> Choose these
when the decision boundary is likely more complex. QDA is a good middle
ground, offering more flexibility than LDA without being as completely
data-driven as KNN. KNN is the most flexible but requires careful tuning
of the parameter K to avoid overfitting or underfitting.</li>
</ul>
<h1
id="here-is-a-more-detailed-slide-by-slide-analysis-of-the-presentation.">9.
Here is a more detailed, slide-by-slide analysis of the
presentation.</h1>
<h2 id="four-classification-methods-comparison-by-simulation">4.6 Four
Classification Methods: Comparison by Simulation</h2>
<p>This section (slides 81-87) introduces four classification methods
and systematically compares their performance on six different simulated
datasets. The goal is to see which method works best under different
conditions (e.g., linear vs. non-linear boundaries, normal
vs. non-normal data).</p>
<p>The four methods being compared are: * <strong>Logistic
Regression:</strong> A linear method that models the log-odds as a
linear function of the predictors. * <strong>Linear Discriminant
Analysis (LDA):</strong> Another linear method. It also assumes a linear
decision boundary but makes stronger assumptions than logistic
regression (e.g., that data within each class is normally distributed
with a common covariance matrix). * <strong>Quadratic Discriminant
Analysis (QDA):</strong> A non-linear method. It assumes the log-odds
are a <em>quadratic</em> function, which creates a more flexible, curved
decision boundary. It assumes data within each class is normally
distributed, but <em>without</em> a common covariance matrix. *
<strong>K-Nearest Neighbors (KNN):</strong> A non-parametric, highly
flexible method. Two versions are tested: * <strong>KNN-1 (<span
class="math inline">\(K=1\)</span>):</strong> A very flexible (high
variance) model. * <strong>KNN-CV:</strong> A tuned model where the best
<span class="math inline">\(K\)</span> is chosen via
cross-validation.</p>
<p>比较的四种方法是： *
<strong>逻辑回归</strong>：一种将对数概率建模为预测变量线性函数的线性方法。
* <strong>线性判别分析
(LDA)</strong>：另一种线性方法。它也假设线性决策边界，但比逻辑回归做出更强的假设（例如，每个类中的数据呈正态分布，且具有共同的协方差矩阵）。
* <strong>二次判别分析
(QDA)</strong>：一种非线性方法。它假设对数概率为<em>二次</em>函数，从而创建一个更灵活、更弯曲的决策边界。它假设每个类中的数据服从正态分布，但<em>没有</em>共同的协方差矩阵。
* <strong>K最近邻
(KNN)</strong>：一种非参数化、高度灵活的方法。测试了两个版本： *
<strong>KNN-1 (<span
class="math inline">\(K=1\)</span>)</strong>：一个非常灵活（高方差）的模型。
*
<strong>KNN-CV</strong>：一个经过调整的模型，通过交叉验证选择最佳的<span
class="math inline">\(K\)</span>。</p>
<h3 id="analysis-of-simulation-scenarios">Analysis of Simulation
Scenarios</h3>
<p>The performance is measured by the <strong>test error rate</strong>
(lower is better), shown in the boxplots for each scenario.
性能通过<strong>测试错误率</strong>（越低越好）来衡量，每个场景的箱线图都显示了该错误率。</p>
<ul>
<li><strong>Scenario 1 (Slide 82):</strong>
<ul>
<li><strong>Setup:</strong> A <strong>linear</strong> decision boundary.
Data is <strong>normally distributed</strong> with <em>uncorrelated</em>
predictors.</li>
<li><strong>Result:</strong> <strong>LDA and Logistic Regression perform
best</strong>. Their test error rates are low and similar. This is
expected, as the setup perfectly matches their core assumption (linear
boundary). QDA is slightly worse because its extra flexibility (being
quadratic) is unnecessary. KNN-1 is the worst, as its high flexibility
leads to high variance (overfitting).</li>
<li><strong>结果：</strong> <strong>LDA
和逻辑回归表现最佳</strong>。它们的测试错误率较低且相似。这是意料之中的，因为设置完全符合它们的核心假设（线性边界）。QDA
略差，因为其额外的灵活性（二次方）是不必要的。KNN-1
最差，因为其高灵活性导致方差较大（过拟合）。</li>
</ul></li>
<li><strong>Scenario 2 (Slide 83):</strong>
<ul>
<li><strong>Setup:</strong> Same as Scenario 1 (<strong>linear</strong>
boundary, <strong>normal</strong> data), but now the two predictors have
a <strong>correlation of 0.5</strong>.</li>
<li><strong>Result:</strong> <strong>Almost no change</strong> from
Scenario 1. <strong>LDA and Logistic Regression are still the
best</strong>. This shows that these linear methods are robust to
correlation between predictors.</li>
<li><strong>结果：</strong>与场景 1
相比<strong>几乎没有变化</strong>。<strong>LDA
和逻辑回归仍然是最佳</strong>。这表明这些线性方法对预测因子之间的相关性具有鲁棒性。</li>
</ul></li>
<li><strong>Scenario 3 (Slide 84):</strong>
<ul>
<li><strong>Setup:</strong> A <strong>linear</strong> decision boundary,
but the data is drawn from a <strong>t-distribution</strong> (which is
non-normal and has “heavy tails,” or more extreme outliers).</li>
<li><strong>Result:</strong> <strong>Logistic Regression is the clear
winner</strong>. LDA’s performance gets worse because its assumption of
<em>normality</em> is violated by the t-distribution. QDA’s performance
deteriorates significantly due to the non-normality. This highlights a
key difference: logistic regression is more robust to violations of the
normality assumption.</li>
<li><strong>结果：</strong>逻辑回归明显胜出**。LDA 的性能会变差，因为 t
分布违反了其正态性假设。QDA
的性能由于非正态性而显著下降。这凸显了一个关键区别：逻辑回归对违反正态性假设的情况更稳健。</li>
</ul></li>
<li><strong>Scenario 4 (Slide 85):</strong>
<ul>
<li><strong>Setup:</strong> A <strong>quadratic</strong> decision
boundary. Data is <strong>normally distributed</strong> with different
correlations in each class.</li>
<li><strong>Result:</strong> <strong>QDA is the clear winner</strong> by
a large margin. This setup perfectly matches QDA’s assumption (quadratic
boundary from normal data with different covariance structures). All
other methods (LDA, Logistic, KNN) are linear or not flexible enough, so
they perform poorly.</li>
<li><strong>结果：</strong>QDA 明显胜出**，且遥遥领先。此设置完全符合
QDA
的假设（来自具有不同协方差结构的正态数据的二次边界）。所有其他方法（LDA、Logistic、KNN）都是线性的或不够灵活，因此性能不佳。</li>
</ul></li>
<li><strong>Scenario 5 (Slide 86):</strong>
<ul>
<li><strong>Setup:</strong> Another <strong>quadratic</strong> boundary,
but generated in a different way (using a logistic function of quadratic
terms).</li>
<li><strong>Result:</strong> <strong>QDA performs best again</strong>,
closely followed by the flexible <strong>KNN-CV</strong>. The linear
methods (LDA, Logistic) have poor performance because they cannot
capture the curve.</li>
<li><strong>结果：QDA
再次表现最佳</strong>，紧随其后的是灵活的<strong>KNN-CV</strong>。线性方法（LDA、Logistic）性能较差，因为它们无法捕捉曲线。</li>
</ul></li>
<li><strong>Scenario 6 (Slide 87):</strong>
<ul>
<li><strong>Setup:</strong> A <strong>complex, non-linear</strong>
decision boundary (more complex than a simple quadratic curve).</li>
<li><strong>Result:</strong> The <strong>flexible KNN-CV method is the
winner</strong>. Its non-parametric nature allows it to approximate the
complex shape. QDA is not flexible <em>enough</em> and performs worse.
This slide highlights the bias-variance trade-off: the overly simple
KNN-1 is the worst, but the <em>tuned</em> KNN-CV is the best.</li>
<li><strong>结果：</strong>灵活的 KNN-CV
方法胜出**。其非参数特性使其能够近似复杂的形状。 QDA
不够灵活，性能较差。这张幻灯片重点介绍了偏差-方差权衡：过于简单的 KNN-1
最差，而 <em>调整后的</em> KNN-CV 最好。</li>
</ul></li>
</ul>
<h2 id="r-example-on-smarket-data">4.7 R Example on Smarket Data</h2>
<p>This section (slides 88-93) applies Logistic Regression and LDA to
the <code>Smarket</code> dataset from the <code>ISLR</code> package to
predict the stock market’s <code>Direction</code> (Up or Down).
本节（幻灯片 88-93）将逻辑回归和 LDA
应用于“ISLR”包中的“Smarket”数据集，以预测股市的“方向”（上涨或下跌）。
### Data Preparation (Slides 88, 89, 90)</p>
<ol type="1">
<li><strong>Load Data:</strong> The <code>ISLR</code> library is loaded,
and the <code>Smarket</code> dataset is explored. It contains daily
percentage returns (<code>Lag1</code>…<code>Lag5</code> for the previous
5 days, <code>Today</code>), <code>Volume</code>, and the
<code>Year</code>.</li>
<li><strong>Explore Data:</strong> A correlation matrix
(<code>cor(Smarket[,-9])</code>) is computed, and a plot of
<code>Volume</code> over time is generated.</li>
<li><strong>Split Data:</strong> The data is split into a training set
(Years 2001-2004) and a test set (Year 2005).
<ul>
<li><code>train &lt;- (Year&lt;2005)</code></li>
<li><code>Smarket.2005 &lt;- Smarket[!train,]</code></li>
<li><code>Direction.2005 &lt;- Direction[!train]</code></li>
<li>The test set has 252 observations.</li>
</ul></li>
<li><strong>加载数据</strong>：加载“ISLR”库，并探索“Smarket”数据集。该数据集包含每日百分比收益率（前
5 天的“Lag1”…“Lag5”，“今日”）、“成交量”和“年份”。</li>
<li><strong>探索数据</strong>：计算相关矩阵
(<code>cor(Smarket[,-9])</code>)，并生成“成交量”随时间变化的图表。</li>
<li><strong>拆分数据</strong>：将数据拆分为训练集（年份
2001-2004）和测试集（年份 2005）。
<ul>
<li><code>train &lt;- (Year&lt;2005)</code></li>
<li><code>Smarket.2005 &lt;- Smarket[!train,]</code></li>
<li><code>Direction.2005 &lt;- Direction[!train]</code></li>
<li>测试集包含 252 个观测值。</li>
</ul></li>
</ol>
<h3 id="model-1-logistic-regression-all-predictors-slide-90">Model 1:
Logistic Regression (All Predictors) (Slide 90)</h3>
<ul>
<li><strong>Model:</strong> A logistic regression model is fit on the
training data using <em>all</em> predictors.
<ul>
<li><code>glm.fit &lt;- glm(Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume, data=Smarket, family=binomial, subset=train)</code></li>
</ul></li>
<li><strong>Prediction:</strong> The model is used to predict the
direction for the 2005 test data.
<ul>
<li><code>glm.probs &lt;- predict(glm.fit, Smarket.2005, type="response")</code></li>
<li>A threshold of 0.5 is used to classify: if <span
class="math inline">\(P(\text{Up}) &gt; 0.5\)</span>, predict “Up”.</li>
</ul></li>
<li><strong>Results:</strong>
<ul>
<li><strong>Test Error Rate:</strong> 0.5198 (or <strong>48.0%
accuracy</strong>).</li>
<li><strong>Conclusion:</strong> This is “not good!”—it’s worse than
flipping a coin. This suggests the model is either too complex or the
predictors are not useful.</li>
</ul></li>
</ul>
<h3 id="model-2-logistic-regression-lag1-lag2-slide-91">Model 2:
Logistic Regression (Lag1 &amp; Lag2) (Slide 91)</h3>
<ul>
<li><strong>Model:</strong> Based on the poor results, a simpler model
is tried, using only <code>Lag1</code> and <code>Lag2</code>.
<ul>
<li><code>glm.fit &lt;- glm(Direction ~ Lag1 + Lag2, data=Smarket, family=binomial, subset=train)</code></li>
</ul></li>
<li><strong>Prediction:</strong> Predictions are made on the 2005 test
set.</li>
<li><strong>Results:</strong>
<ul>
<li><strong>Test Error Rate:</strong> 0.4404 (or <strong>55.95%
accuracy</strong>). This is an improvement.</li>
<li><strong>Confusion Matrix:</strong> | | True Down | True Up | | :— |
:— | :— | | <strong>Pred Down</strong> | 77 | 69 | | <strong>Pred
Up</strong> | 35 | 71 |</li>
<li><strong>ROC and AUC:</strong> The ROC (Receiver Operating
Characteristic) curve is plotted, and the AUC (Area Under the Curve) is
calculated.</li>
<li><strong>AUC Value:</strong> <strong>0.5584</strong>. This is very
close to 0.5 (which represents a random-chance model), indicating that
the model has very weak predictive power, even though its accuracy is
above 50%.</li>
</ul></li>
</ul>
<h3 id="model-3-lda-lag1-lag2-slide-92">Model 3: LDA (Lag1 &amp; Lag2)
(Slide 92)</h3>
<ul>
<li><strong>Model:</strong> LDA is now performed using the same setup:
<code>Lag1</code> and <code>Lag2</code> as predictors, trained on the
2001-2004 data.
<ul>
<li><code>library(MASS)</code></li>
<li><code>lda.fit &lt;- lda(Direction ~ Lag1 + Lag2, data=Smarket, subset=train)</code></li>
</ul></li>
<li><strong>Prediction:</strong> Predictions are made on the 2005 test
set.
<ul>
<li><code>lda.pred &lt;- predict(lda.fit, Smarket.2005)</code></li>
</ul></li>
<li><strong>Results:</strong>
<ul>
<li><strong>Test Error Rate:</strong> 0.4404 (or <strong>55.95%
accuracy</strong>).</li>
<li><strong>Confusion Matrix:</strong> | | True Down | True Up | | :— |
:— | :— | | <strong>Pred Down</strong> | 77 | 69 | | <strong>Pred
Up</strong> | 35 | 71 |</li>
<li><strong>Observation:</strong> The confusion matrix and accuracy are
<em>identical</em> to the logistic regression model.</li>
</ul></li>
</ul>
<h3 id="final-comparison-slide-93">Final Comparison (Slide 93)</h3>
<ul>
<li><strong>ROC and AUC for LDA:</strong> The ROC curve for the LDA
model is plotted.</li>
<li><strong>AUC Value:</strong> <strong>0.5584</strong>.</li>
<li><strong>Main Conclusion:</strong> As highlighted in the green box,
<strong>“LDA has identical performance as Logistic regression!”</strong>
In this specific practical example, using these two predictors, both
linear methods produce the exact same confusion matrix, the same
accuracy (56%), and the same AUC (0.558). This reinforces the
theoretical idea that both are fitting a linear boundary.</li>
</ul>
<h3 id="最终比较幻灯片-93">最终比较（幻灯片 93）</h3>
<ul>
<li><strong>LDA 的 ROC 和 AUC：</strong>绘制了 LDA 模型的 ROC
曲线。</li>
<li><strong>AUC 值：</strong>0.5584**。</li>
<li><strong>主要结论：</strong>如绿色方框所示，“LDA 的性能与 Logistic
回归相同！”**
在这个具体的实际示例中，使用这两个预测变量，两种线性方法都产生了完全相同的混淆矩阵、相同的准确率（56%）和相同的
AUC（0.558）。这强化了两者均拟合线性边界的理论观点。</li>
</ul>
<h2 id="r-example-on-smarket-data-continued">4.7 R Example on Smarket
Data (Continued)</h2>
<p>The previous slides showed that Logistic Regression and Linear
Discriminant Analysis (LDA) had <strong>identical performance</strong>
on the Smarket dataset (using <code>Lag1</code> and <code>Lag2</code>),
both achieving 56% test accuracy and an AUC of 0.558. The analysis now
tests a more flexible method, QDA.</p>
<h3 id="model-3-qda-lag1-lag2-slides-94-95">Model 3: QDA (Lag1 &amp;
Lag2) (Slides 94-95)</h3>
<ul>
<li><strong>Model:</strong> A Quadratic Discriminant Analysis (QDA)
model is fit on the same training data (2001-2004) using only the
<code>Lag1</code> and <code>Lag2</code> predictors.
<ul>
<li><code>qda.fit &lt;- qda(Direction ~ Lag1 + Lag2, data=Smarket, subset=train)</code></li>
</ul></li>
<li><strong>Prediction:</strong> The model is used to predict the market
direction for the 2005 test set.</li>
<li><strong>Results:</strong>
<ul>
<li><strong>Test Accuracy:</strong> The model achieves a test accuracy
of <strong>0.5992 (or 60%)</strong>.</li>
<li><strong>AUC:</strong> The Area Under the Curve (AUC) for the QDA
model is <strong>0.562</strong>.</li>
</ul></li>
<li><strong>Conclusion:</strong> As the slide highlights, <strong>“QDA
has better test performance than LDA and Logistic
regression!”</strong></li>
</ul>
<h3 id="smarket-example-summary">Smarket Example Summary</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">Method</th>
<th style="text-align: left;">Model Type</th>
<th style="text-align: left;">Test Accuracy</th>
<th style="text-align: left;">AUC</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Logistic Regression</strong></td>
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">~56%</td>
<td style="text-align: left;">0.558</td>
</tr>
<tr>
<td style="text-align: left;"><strong>LDA</strong></td>
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">~56%</td>
<td style="text-align: left;">0.558</td>
</tr>
<tr>
<td style="text-align: left;"><strong>QDA</strong></td>
<td style="text-align: left;">Quadratic</td>
<td style="text-align: left;"><strong>~60%</strong></td>
<td style="text-align: left;"><strong>0.562</strong></td>
</tr>
</tbody>
</table>
<p>This practical example reinforces the lessons from the simulations
(Section 4.6). The two linear methods (LDA, Logistic) had identical
performance. The more flexible, non-linear QDA model performed better,
suggesting that the true decision boundary between “Up” and “Down”
(based on <code>Lag1</code> and <code>Lag2</code>) is not perfectly
linear.</p>
<h2 id="kernel-lda">4.8 Kernel LDA</h2>
<p>This new section introduces an even more advanced non-linear method,
Kernel LDA.</p>
<h3 id="the-problem-linear-inseparability-slide-97">The Problem: Linear
Inseparability (Slide 97)</h3>
<p>The section starts with a clear visual example. A dataset of two
concentric circles (a “donut” shape) is <strong>linearly
inseparable</strong>. It is impossible to draw a single straight line to
separate the inner (purple) class from the outer (yellow) class.</p>
<h3 id="the-solution-the-kernel-trick-slides-97-99">The Solution: The
Kernel Trick (Slides 97, 99)</h3>
<ol type="1">
<li><strong>Nonlinear Transformation:</strong> The data is “lifted” into
a higher-dimensional <em>feature space</em> using a <strong>nonlinear
transformation</strong>, <span class="math inline">\(x \mapsto
\phi(x)\)</span>. In the example on the slide, the 2D data is
transformed, and in this new space, the two classes <em>become</em>
<strong>linearly separable</strong>.</li>
<li><strong>The “Kernel Trick”:</strong> The main idea (from slide 99)
is that we don’t need to explicitly compute this complex transformation
<span class="math inline">\(\phi(x)\)</span>. LDA (based on Fisher’s
approach) only requires inner products of the data points. The “kernel
trick” allows us to replace the inner product in the high-dimensional
feature space (<span class="math inline">\(x_i^T x_j\)</span>) with a
simple <strong>kernel function</strong>, <span
class="math inline">\(k(x_i, x_j)\)</span>, computed in the original,
low-dimensional space.
<ul>
<li>An example of such a kernel is the <strong>Gaussian (RBF)
kernel</strong>: <span class="math inline">\(k(x_i, x_j) \propto
e^{-\|x_i - x_j\|^2 / \sigma^2}\)</span>.</li>
</ul></li>
</ol>
<h3 id="academic-foundations-slide-98">Academic Foundations (Slide
98)</h3>
<p>This method is based on foundational academic papers that generalized
linear methods using kernels: * <strong>Fisher discriminant analysis
with kernels</strong> (Mika, 1999) * <strong>Generalized Discriminant
Analysis Using a Kernel Approach</strong> (Baudat, 2000) *
<strong>Kernel principal component analysis</strong> (Schölkopf,
1997)</p>
<p>In short, Kernel LDA is an extension of LDA that uses the kernel
trick to find a linear boundary in a high-dimensional feature space,
which corresponds to a highly non-linear boundary in the original
space.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/27/QM9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/QM9/" class="post-title-link" itemprop="url">QM9 Dataset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-27 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-27T21:00:00+08:00">2025-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-29 03:57:13" itemprop="dateModified" datetime="2025-09-29T03:57:13+08:00">2025-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dataset/" itemprop="url" rel="index"><span itemprop="name">dataset</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="qm9-数据集的xyz格式详解">1. QM9 数据集的XYZ格式详解</h3>
<p>这个数据集使用的 “XYZ-like”
格式是一种<strong>扩展的、非标准的XYZ格式</strong>。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 43%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr>
<th>行号</th>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>第 1 行</strong></td>
<td><code>na</code></td>
<td>一个整数，代表分子中的原子总数。</td>
</tr>
<tr>
<td><strong>第 2 行</strong></td>
<td><code>Properties 1-17</code></td>
<td>包含17个理化性质的数值，用制表符或空格分隔。</td>
</tr>
<tr>
<td><strong>第 3 到 na+2 行</strong></td>
<td><code>Element  x  y  z  charge</code></td>
<td>每行代表一个原子。依次是：元素符号、x/y/z坐标（单位：埃）、Mulliken部分电荷（单位：e）。</td>
</tr>
<tr>
<td><strong>第 na+3 行</strong></td>
<td><code>Frequencies</code></td>
<td>分子的振动频率（3na-5或3na-6个）。</td>
</tr>
<tr>
<td><strong>第 na+4 行</strong></td>
<td><code>SMILES_GDB9   SMILES_relaxed</code></td>
<td>来自GDB9的SMILES字符串和弛豫后的几何构型的SMILES字符串。</td>
</tr>
<tr>
<td><strong>第 na+5 行</strong></td>
<td><code>InChI_GDB9    InChI_relaxed</code></td>
<td>对应的InChI字符串。</td>
</tr>
</tbody>
</table>
<p><strong>与标准XYZ格式对比：</strong> *
<strong>标准格式</strong>只有第1行（原子数）、第2行（注释）和后续的原子坐标行（仅含元素和xyz坐标）。
*
<strong>QM9格式</strong>在第2行插入了大量属性数据，在原子坐标行增加了电荷列，并在文件末尾附加了频率、SMILES和InChI信息。</p>
<h3 id="readme">2. readme</h3>
<ol type="1">
<li><strong>数据集核心内容</strong>:
<ul>
<li>它包含了<strong>133,885个</strong>小型有机分子（由H, C, N, O,
F元素组成）的量子化学计算数据。</li>
<li>所有分子的几何构型都经过了<strong>DFT/B3LYP/6-31G(2df,p)</strong>水平的优化。</li>
<li><code>dsC7O2H10nsd.xyz.tar.bz2</code>是该数据集的一个子集，专门包含<strong>6,095个C₇H₁₀O₂的同分异构体</strong>，其能量学性质在更高精度的<strong>G4MP2</strong>理论水平下计算。</li>
</ul></li>
<li><strong>文件结构与格式</strong>:
<ul>
<li>明确指出每个分子存储在单独的<code>.xyz</code>文件中，并详细描述了上述的<strong>非标准XYZ扩展格式</strong>。</li>
<li>详细列出了记录在文件第2行的<strong>17种理化性质</strong>，包括转动常数(A,
B,
C)、偶极矩(mu)、HOMO/LUMO能级、零点振动能(zpve)、内能(U)、焓(H)和吉布斯自由能(G)等。</li>
</ul></li>
<li><strong>数据来源与计算方法</strong>:
<ul>
<li>数据源于<strong>GDB-9</strong>化学数据库。</li>
<li>主要使用了两种量子化学理论水平：<strong>B3LYP</strong>用于大部分属性计算，<strong>G4MP2</strong>用于C₇H₁₀O₂子集的能量计算。</li>
</ul></li>
<li><strong>引用要求</strong>:
<ul>
<li>文件明确要求，如果使用该数据集，需要引用Raghunathan
Ramakrishnan等人在2014年发表于《Scientific Data》的论文。</li>
</ul></li>
<li><strong>其他信息</strong>:
<ul>
<li>提供了一些额外文件（如<code>validation.txt</code>,
<code>uncharacterized.txt</code>）的说明。</li>
<li>提到了数据集中有少数几个分子在几何优化时难以收敛。</li>
</ul></li>
</ol>
<h3 id="可视化">3. 可视化</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import ase.io</span><br><span class="line">import nglview as nv</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">def parse_qm9_xyz(file_path):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    Parses a QM9 extended XYZ file and returns a standard XYZ string.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    with open(file_path, <span class="string">&#x27;r&#x27;</span>) as f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># First line is the number of atoms</span></span><br><span class="line">    num_atoms = int(lines[0].strip())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The next line is properties (skip it)</span></span><br><span class="line">    <span class="comment"># The next num_atoms lines are the coordinates</span></span><br><span class="line">    coord_lines = lines[2:2+num_atoms]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Rebuild a standard XYZ format string in memory</span></span><br><span class="line">    standard_xyz = f<span class="string">&quot;&#123;num_atoms&#125;\n&quot;</span></span><br><span class="line">    standard_xyz += <span class="string">&quot;Comment line\n&quot;</span> <span class="comment"># Add a standard comment line</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> coord_lines:</span><br><span class="line">        parts = line.split()</span><br><span class="line">        <span class="comment"># Keep only the element and the x, y, z coordinates</span></span><br><span class="line">        standard_xyz += f<span class="string">&quot;&#123;parts[0]&#125; &#123;parts[1]&#125; &#123;parts[2]&#125; &#123;parts[3]&#125;\n&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">return</span> standard_xyz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your data file</span></span><br><span class="line">file_path = <span class="string">&quot;/root/QM9/QM9/Data_for_6095_constitutional_isomers_of_C7H10O2.xyz/dsC7O2H10nsd_0001.xyz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Parse the special file format into a standard XYZ string</span></span><br><span class="line">standard_xyz_data = parse_qm9_xyz(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. ASE reads the standard XYZ data from the string variable</span></span><br><span class="line"><span class="comment">#    We use io.StringIO to make the string behave like a file</span></span><br><span class="line">atoms = ase.io.read(io.StringIO(standard_xyz_data), format=<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Create the nglview visualization widget</span></span><br><span class="line">view = nv.show_ase(atoms)</span><br><span class="line">view.add_ball_and_stick()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the widget in the notebook output</span></span><br><span class="line">view</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>定义解析函数 <code>parse_qm9_xyz</code></strong>:
<ul>
<li><strong>目的</strong>:
将这个函数作为专门处理QM9特殊格式的工具。代码主体清晰，易于复用。</li>
<li><strong>读取文件</strong>: <code>with open(...)</code>
安全地打开文件，并用 <code>f.readlines()</code>
将文件所有行一次性读入一个列表 <code>lines</code> 中。</li>
<li><strong>提取原子数量</strong>:
<code>num_atoms = int(lines[0].strip())</code>
读取第一行（<code>lines[0]</code>），去除可能存在的空格（<code>.strip()</code>），并将其转换为整数。这是构建标准XYZ格式的必要信息。</li>
<li><strong>提取坐标信息</strong>:
<code>coord_lines = lines[2:2+num_atoms]</code>
标信息从第3行开始（索引为2），持续<code>num_atoms</code>行。通过列表切片，精确地提取出所有包含原子坐标的行，跳过了第2行的属性信息。</li>
<li><strong>构建标准XYZ格式字符串</strong>:
<ul>
<li>创建一个名为 <code>standard_xyz</code> 的新字符串。</li>
<li>首先，将原子数量和换行符写入。</li>
<li>然后，添加一行标准的注释（“Comment
line”），这是标准XYZ格式所要求的。</li>
<li>最后，遍历刚刚提取的 <code>coord_lines</code> 列表。对于每一行，使用
<code>.split()</code>
将其拆分成多个部分（例如：<code>['C', 'x', 'y', 'z', 'charge']</code>）。只取前四部分（元素符号和xyz坐标），并重新组合成新的一行，<strong>从而丢弃了末尾的Mulliken电荷数据</strong>。</li>
</ul></li>
<li><strong>返回结果</strong>:
函数返回一个包含了标准XYZ格式数据的、干净的字符串。</li>
</ul></li>
<li><strong>主程序执行流程</strong>:
<ul>
<li><strong>调用函数</strong>:
<code>standard_xyz_data = parse_qm9_xyz(file_path)</code>
调用上面的函数，完成从文件到标准格式字符串的转换。</li>
<li><strong>在内存中读取</strong>:
<code>ase.io.read(io.StringIO(standard_xyz_data), format="xyz")</code>
这一步非常高效。<code>io.StringIO</code> 将我们的字符串变量
<code>standard_xyz_data</code>
模拟成一个内存中的文本文件。这样，<code>ase.io.read</code>
就可以直接读取它，而无需先将清洗后的数据写入一个临时文件再读取，节省了磁盘I/O操作。</li>
<li><strong>可视化</strong>: 接下来的代码 (<code>nv.show_ase</code>等)
就和最初的设想一样了，因为此时 <code>atoms</code>
对象已经是通过标准、干净的数据成功创建的了。</li>
</ul></li>
</ol>
<p><img src="/imgs/QM9/C7O2H10/C7O2H10.png" alt="C7O2H10"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/27/fusionnetwork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/27/fusionnetwork/" class="post-title-link" itemprop="url">FusionProt - 论文阅读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-27 11:00:00" itemprop="dateCreated datePublished" datetime="2025-09-27T11:00:00+08:00">2025-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-29 03:56:14" itemprop="dateModified" datetime="2025-09-29T03:56:14+08:00">2025-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Paper-Reading/" itemprop="url" rel="index"><span itemprop="name">Paper Reading</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Fusing Sequence and Structural Information for Unified Protein
Representation Learning</p>
<p><a
target="_blank" rel="noopener" href="https://openreview.net/forum?id=imcinaOHod">FusionProt</a></p>
<h2 id="蛋白质表示学习">1 蛋白质表示学习：</h2>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>FusionProt :可学习融合
token和迭代双向信息交换，实现序列与结构的动态协同学习，而非静态拼接。</p>
<h2 id="一维1d氨基酸序列和三维3d空间结构">2.
一维（1D）氨基酸序列和三维（3D）空间结构：</h2>
<ul>
<li><p><strong>单模态依赖:</strong>
ProteinBERT、ESM-2仅基于序列</p></li>
<li><p><strong>静态融合缺陷 :</strong>ESM-GearNet、SaProt
结合序列与结构，但采用 “单向 / 一次性融合”</p></li>
</ul>
<p>好的，完全没有问题。这是对 <code>FusionNetwork</code>
模型架构代码的中文复述分析。</p>
<h2 id="模型总体">3. 模型总体</h2>
<p><img src="/imgs/fusionProt/FusionProt.png" alt="fusion">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@R.register(<span class="params"><span class="string">&quot;models.FusionNetwork&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FusionNetwork</span>(nn.Module, core.Configurable):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sequence_model, structure_model, fusion=<span class="string">&quot;series&quot;</span>, cross_dim=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(FusionNetwork, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.sequence_model = sequence_model</span><br><span class="line">        <span class="variable language_">self</span>.structure_model = structure_model</span><br><span class="line">        <span class="variable language_">self</span>.output_dim = sequence_model.output_dim + structure_model.output_dim</span><br><span class="line">        <span class="variable language_">self</span>.inject_step = <span class="number">5</span>   <span class="comment"># (sequence_layers / structure_layers) layers</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>class FusionNetwork(...)</code></strong>:
定义了模型类，它继承自 PyTorch 的基础模块 <code>nn.Module</code>。</li>
<li><strong><code>__init__(...)</code></strong>:
构造函数，接收已经初始化好的 <code>sequence_model</code> 和
<code>structure_model</code> 作为输入。</li>
<li><strong><code>self.output_dim</code></strong>:
定义了模型最终输出特征的维度。因为最后会将两个模型的特征拼接起来，所以是两者输出维度之和。</li>
<li><strong><code>self.inject_step = 5</code></strong>:定义了信息“注入”或“交流”的频率。这里设置为
5，意味着<strong>每经过序列模型的 5
层，就会进行一次信息交换</strong>。</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Structure embeddings layer</span></span><br><span class="line">raw_input_dim = <span class="number">21</span>  <span class="comment"># amino acid tokens</span></span><br><span class="line"><span class="variable language_">self</span>.structure_embed_linear = nn.Linear(raw_input_dim, structure_model.input_dim)</span><br><span class="line"><span class="variable language_">self</span>.embedding_batch_norm = nn.BatchNorm1d(structure_model.input_dim)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>self.structure_embed_linear</code></strong>:
一个线性层，用于将原始的结构输入（比如 21
种氨基酸的独热编码）转换为结构模型（GNN）所期望的输入维度。</li>
<li><strong><code>self.embedding_batch_norm</code></strong>:
批归一化层，用于稳定结构嵌入层的训练过程。</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Normal Initialization of the 3D structure token</span></span><br><span class="line">structure_token = nn.Parameter(torch.Tensor(structure_model.input_dim).unsqueeze(<span class="number">0</span>))</span><br><span class="line">nn.init.normal_(structure_token, mean=<span class="number">0.0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"><span class="variable language_">self</span>.structure_token = nn.Parameter(structure_token.squeeze(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>self.structure_token</code></strong>: 一个可学习的向量
(<code>nn.Parameter</code>)。这个“令牌”不代表任何真实的原子或氨基酸，而是一个抽象的载体。在训练过程中，它将<strong>学习如何编码和表示整个蛋白质的全局
3D 结构信息</strong>。它就像一个信息信使。</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linear Transformation between structure to sequential spaces</span></span><br><span class="line"><span class="variable language_">self</span>.structure_linears = nn.ModuleList([...])</span><br><span class="line"><span class="variable language_">self</span>.seq_linears = nn.ModuleList([...])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>self.structure_linears</code> /
<code>self.seq_linears</code></strong>:
序列模型和结构模型内部处理的特征向量维度可能不同。当“3D
令牌”需要在两个模型之间传递时，这些线性层负责将它的表示从一个模型的特征空间转换到另一个模型的特征空间。</li>
</ul>
<h2 id="前向">4. 前向</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, graph, <span class="built_in">input</span>, all_loss=<span class="literal">None</span>, metric=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Build a new protein graph with the 3D token (the lase node)</span></span><br><span class="line">    new_graph = <span class="variable language_">self</span>.build_protein_graph_with_3d_token(graph)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先调用辅助函数，将输入的蛋白质图谱进行改造：为图谱增加一个代表“3D
令牌”的新节点，并将这个新节点与图中所有其他节点连接起来。</li>
</ul>
<h5 id="序列模型的初始化"><strong>序列模型的初始化</strong></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sequence (ESM) model initialization</span></span><br><span class="line">sequence_input = <span class="variable language_">self</span>.sequence_model.mapping[graph.residue_type]</span><br><span class="line">sequence_input[sequence_input == -<span class="number">1</span>] = graph.residue_type[sequence_input == -<span class="number">1</span>]</span><br><span class="line">size = graph.num_residues</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if sequence size is not bigger than max seq length</span></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="variable language_">self</span>.sequence_model.max_input_length).<span class="built_in">any</span>():</span><br><span class="line">    starts = size.cumsum(<span class="number">0</span>) - size</span><br><span class="line">    size = size.clamp(<span class="built_in">max</span>=<span class="variable language_">self</span>.sequence_model.max_input_length)</span><br><span class="line">    ends = starts + size</span><br><span class="line">    mask = functional.multi_slice_mask(starts, ends, graph.num_residues)</span><br><span class="line">    sequence_input = sequence_input[mask]</span><br><span class="line">    graph = graph.subresidue(mask)</span><br><span class="line">size_ext = size</span><br><span class="line"></span><br><span class="line"><span class="comment"># BOS == CLS</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.sequence_model.alphabet.prepend_bos:</span><br><span class="line">    bos = torch.ones(graph.batch_size, dtype=torch.long, device=<span class="variable language_">self</span>.sequence_model.device) * <span class="variable language_">self</span>.sequence_model.alphabet.cls_idx</span><br><span class="line">    sequence_input, size_ext = functional._extend(bos, torch.ones_like(size_ext), sequence_input, size_ext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.sequence_model.alphabet.append_eos:</span><br><span class="line">    eos = torch.ones(graph.batch_size, dtype=torch.long, device=<span class="variable language_">self</span>.sequence_model.device) * <span class="variable language_">self</span>.sequence_model.alphabet.eos_idx</span><br><span class="line">    sequence_input, size_ext = functional._extend(sequence_input, size_ext, eos, torch.ones_like(size_ext))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding</span></span><br><span class="line">tokens = functional.variadic_to_padded(sequence_input, size_ext, value=<span class="variable language_">self</span>.sequence_model.alphabet.padding_idx)[<span class="number">0</span>]</span><br><span class="line">repr_layers = [<span class="variable language_">self</span>.sequence_model.repr_layer]</span><br><span class="line"><span class="keyword">assert</span> tokens.ndim == <span class="number">2</span></span><br><span class="line">padding_mask = tokens.eq(<span class="variable language_">self</span>.sequence_model.model.padding_idx)  <span class="comment"># B, T</span></span><br></pre></td></tr></table></figure>
<ul>
<li>序列数据进行 Transformer 模型（如 ESM）所需的标准预处理。</li>
<li>包括添加序列开始（BOS）和结束（EOS）标记，以及将所有序列填充（Padding）到相同长度，以便进行批处理。</li>
</ul>
<h5 id="模型初始化与初次融合"><strong>模型初始化与初次融合</strong></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sequence embedding layer</span></span><br><span class="line">x = <span class="variable language_">self</span>.sequence_model.model.embed_scale * <span class="variable language_">self</span>.sequence_model.model.embed_tokens(tokens)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.sequence_model.model.token_dropout:</span><br><span class="line">    x.masked_fill_((tokens == <span class="variable language_">self</span>.sequence_model.model.mask_idx).unsqueeze(-<span class="number">1</span>), <span class="number">0.0</span>)</span><br><span class="line">    <span class="comment"># x: B x T x C</span></span><br><span class="line">    mask_ratio_train = <span class="number">0.15</span> * <span class="number">0.8</span></span><br><span class="line">    src_lengths = (~padding_mask).<span class="built_in">sum</span>(-<span class="number">1</span>)</span><br><span class="line">    mask_ratio_observed = (tokens == <span class="variable language_">self</span>.sequence_model.model.mask_idx).<span class="built_in">sum</span>(-<span class="number">1</span>).to(x.dtype) / src_lengths</span><br><span class="line">    x = x * (<span class="number">1</span> - mask_ratio_train) / (<span class="number">1</span> - mask_ratio_observed)[:, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Structure model initialization</span></span><br><span class="line">structure_hiddens = []</span><br><span class="line">batch_size = graph.batch_size</span><br><span class="line">structure_embedding = <span class="variable language_">self</span>.embedding_batch_norm(<span class="variable language_">self</span>.structure_embed_linear(<span class="built_in">input</span>))</span><br><span class="line">structure_token_batched = <span class="variable language_">self</span>.structure_token.unsqueeze(<span class="number">0</span>).expand(batch_size, -<span class="number">1</span>)</span><br><span class="line">structure_input = torch.cat([structure_embedding.squeeze(<span class="number">1</span>), structure_token_batched], dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the 3D token representation</span></span><br><span class="line">structure_token_expanded = <span class="variable language_">self</span>.structure_token.unsqueeze(<span class="number">0</span>).expand(x.size(<span class="number">0</span>), -<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">x = torch.cat((x[:, :-<span class="number">1</span>], structure_token_expanded, x[:, -<span class="number">1</span>:]), dim=<span class="number">1</span>)</span><br><span class="line">padding_mask = torch.cat([padding_mask[:, :-<span class="number">1</span>],</span><br><span class="line">                          torch.zeros(padding_mask.size(<span class="number">0</span>), <span class="number">1</span>).to(padding_mask), padding_mask[:, -<span class="number">1</span>:]], dim=<span class="number">1</span>)</span><br><span class="line">size_ext += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> padding_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    x = x * (<span class="number">1</span> - padding_mask.unsqueeze(-<span class="number">1</span>).type_as(x))</span><br><span class="line"></span><br><span class="line">repr_layers = <span class="built_in">set</span>(repr_layers)</span><br><span class="line">hidden_representations = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> repr_layers:</span><br><span class="line">    hidden_representations[<span class="number">0</span>] = x</span><br><span class="line"></span><br><span class="line"><span class="comment"># (B, T, E) =&gt; (T, B, E)</span></span><br><span class="line">x = x.transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> padding_mask.<span class="built_in">any</span>():</span><br><span class="line">    padding_mask = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>将 3D 令牌插入序列。</strong>
<ol type="1">
<li>为序列数据生成初始的词嵌入表示 <code>x</code>。</li>
<li>将 <code>self.structure_token</code> 的初始状态插入到序列嵌入
<code>x</code> 中，通常是放在序列结束标记（EOS）之前。</li>
<li>序列模型看到的输入序列变成了
<code>[BOS, 残基1, 残基2, ..., 残基N, **3D令牌**, EOS]</code>
的形式。</li>
</ol></li>
</ul>
<h5 id="融合循环"><strong>融合循环 </strong></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> seq_layer_idx, seq_layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.sequence_model.model.layers):</span><br><span class="line">    x, attn = seq_layer(</span><br><span class="line">        x,</span><br><span class="line">        self_attn_padding_mask=padding_mask,</span><br><span class="line">        need_head_weights=<span class="literal">False</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (seq_layer_idx + <span class="number">1</span>) <span class="keyword">in</span> repr_layers:</span><br><span class="line">        hidden_representations[seq_layer_idx + <span class="number">1</span>] = x.transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>模型开始逐层遍历序列模型的所有层（例如 Transformer
的编码器层）。<code>x</code> 在每一层都会被更新。</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> seq_layer_idx &gt; <span class="number">0</span> <span class="keyword">and</span> seq_layer_idx % <span class="variable language_">self</span>.inject_step == <span class="number">0</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>信息注入点</strong>：每当层数的索引能被
<code>inject_step</code> (即 5) 整除时，就触发一次信息交换。</li>
</ul>
<!-- end list -->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 从序列中提取 3D 令牌的表示</span></span><br><span class="line"><span class="keyword">if</span> structure_layer_index == <span class="number">0</span>:</span><br><span class="line">    structure_input = torch.cat((structure_input[:-<span class="number">1</span> * batch_size],  x[-<span class="number">2</span>, :, :]), dim=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    structure_input = torch.cat((structure_input[:-<span class="number">1</span> * batch_size],</span><br><span class="line">                                 <span class="variable language_">self</span>.seq_linears[structure_layer_index](x[-<span class="number">2</span>, :, :])), dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 用结构模型的一层来处理</span></span><br><span class="line">hidden = <span class="variable language_">self</span>.structure_model.layers[structure_layer_index](new_graph, structure_input)</span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.structure_model.short_cut <span class="keyword">and</span> hidden.shape == structure_input.shape:</span><br><span class="line">    hidden = hidden + structure_input</span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.structure_model.batch_norm:</span><br><span class="line">    hidden = <span class="variable language_">self</span>.structure_model.batch_norms[structure_layer_index](hidden)</span><br><span class="line"></span><br><span class="line">structure_hiddens.append(hidden)</span><br><span class="line">structure_input = hidden</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将更新后的 3D 令牌表示插回序列</span></span><br><span class="line">updated_structure_token = <span class="variable language_">self</span>.structure_linears[...](structure_input[-<span class="number">1</span> * batch_size:])</span><br><span class="line">x = torch.cat((x[:-<span class="number">2</span>, :, :], updated_structure_token.unsqueeze(<span class="number">0</span>), x[-<span class="number">1</span>:, :, :]), dim=<span class="number">0</span>)</span><br><span class="line">structure_layer_index += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>信息流程</strong>：
<ol type="1">
<li><strong>从序列到结构</strong>：模型从序列表示 <code>x</code>
中提取出“3D
令牌”的最新向量。这个向量此时已经吸收了前面几层序列模型的上下文信息。然后，通过（<code>seq_linears</code>）将其转换后，更新到结构模型的输入中。</li>
<li><strong>结构信息处理</strong>：运行一层结构模型（GNN）。GNN
根据图的连接关系更新所有节点的表示，当然也包括“3D
令牌”这个特殊节点。</li>
<li><strong>从结构到序列</strong>：从 GNN 的输出中，再次提取出“3D
令牌”的向量。这个向量包含更新后的结构信息。再通过（<code>structure_linears</code>）转换后，把它<strong>插回</strong>到序列表示
<code>x</code> 中，替换掉旧的版本。</li>
</ol></li>
</ul>
<p>这个循环不断重复。</p>
<h5 id="输出"><strong>输出</strong></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Structural Output</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.structure_model.concat_hidden:</span><br><span class="line">    structure_node_feature = torch.cat(structure_hiddens, dim=-<span class="number">1</span>)[:-<span class="number">1</span> * batch_size]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    structure_node_feature = structure_hiddens[-<span class="number">1</span>][:-<span class="number">1</span> * batch_size]</span><br><span class="line"></span><br><span class="line">structure_graph_feature = <span class="variable language_">self</span>.structure_model.readout(graph, structure_node_feature)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sequence Output</span></span><br><span class="line">x = <span class="variable language_">self</span>.sequence_model.model.emb_layer_norm_after(x)</span><br><span class="line">x = x.transpose(<span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># (T, B, E) =&gt; (B, T, E)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># last hidden representation should have layer norm applied</span></span><br><span class="line"><span class="keyword">if</span> (seq_layer_idx + <span class="number">1</span>) <span class="keyword">in</span> repr_layers:</span><br><span class="line">    hidden_representations[seq_layer_idx + <span class="number">1</span>] = x</span><br><span class="line">x = <span class="variable language_">self</span>.sequence_model.model.lm_head(x)</span><br><span class="line"></span><br><span class="line">output = &#123;<span class="string">&quot;logits&quot;</span>: x, <span class="string">&quot;representations&quot;</span>: hidden_representations&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sequence (ESM) model outputs</span></span><br><span class="line">residue_feature = output[<span class="string">&quot;representations&quot;</span>][<span class="variable language_">self</span>.sequence_model.repr_layer]</span><br><span class="line">residue_feature = functional.padded_to_variadic(residue_feature, size_ext)</span><br><span class="line">starts = size_ext.cumsum(<span class="number">0</span>) - size_ext</span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.sequence_model.alphabet.prepend_bos:</span><br><span class="line">    starts = starts + <span class="number">1</span></span><br><span class="line">ends = starts + size</span><br><span class="line">mask = functional.multi_slice_mask(starts, ends, <span class="built_in">len</span>(residue_feature))</span><br><span class="line">residue_feature = residue_feature[mask]</span><br><span class="line">graph_feature = <span class="variable language_">self</span>.sequence_model.readout(graph, residue_feature)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Combine both models outputs</span></span><br><span class="line">node_feature = torch.cat(...)</span><br><span class="line">graph_feature = torch.cat(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&quot;graph_feature&quot;</span>: graph_feature, <span class="string">&quot;node_feature&quot;</span>: node_feature&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>提取输出</strong>：循环结束后，分别从两个模型中提取最终的特征表示。</li>
<li><strong>读出（Readout）</strong>：使用一个“读出函数”（如求和或平均）将节点级别的特征聚合成一个代表整个蛋白质的图级别特征。</li>
<li><strong>最终组合</strong>：将来自序列模型和结构模型的节点特征（<code>node_feature</code>）和图特征（<code>graph_feature</code>）分别拼接（concatenate）起来。</li>
<li><strong>返回结果</strong>：返回一个包含组合后特征的字典，可用于下游任务（如功能预测、属性回归等）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/26/5120C4-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/26/5120C4-2/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-26 21:00:00 / 修改时间：20:48:45" itemprop="dateCreated datePublished" datetime="2025-09-26T21:00:00+08:00">2025-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-4</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="monte-carlo-mc-method">1 Monte Carlo (MC) Method:</h2>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This whiteboard provides a concise but detailed overview of two
important and related simulation techniques in computational physics and
chemistry: the Metropolis Monte Carlo (MC) method and Hamiltonian (or
Hybrid) Monte Carlo (HMC). Here is a detailed breakdown of the concepts
presented.</p>
<h3 id="metropolis-monte-carlo-mc-method">1. Metropolis Monte Carlo (MC)
Method</h3>
<p>The heading “Metropolis MC method” introduces a foundational
algorithm in statistical mechanics. Metropolis Monte Carlo is a method
used to generate a sequence of states for a system, allowing for the
calculation of average properties. 左上角的这一部分介绍了基础的
<strong>Metropolis Monte Carlo</strong>
算法。它是一种生成状态序列的方法，使得处于任何状态的概率都符合期望的概率分布（在物理学中通常是玻尔兹曼分布）。</p>
<ul>
<li><strong>Conceptual Diagram:</strong> The small box with numbered
sites (0-5) and an arrow showing a move from state 0 to 2, and then to
3, illustrates a “random walk.” In Metropolis MC, the system transitions
from one state to another by making small, random changes.
小方框中标有编号的位点（0-5），箭头表示从状态 0 到状态 2，再到状态 3
的移动，代表“随机游走”。在 Metropolis MC
中，系统通过进行微小的随机变化从一个状态过渡到另一个状态。</li>
<li><strong>Random Number Generation:</strong> The notation
<code>rand t \in (0,1)</code> indicates the use of a random number <span
class="math inline">\(t\)</span> drawn from a uniform distribution
between 0 and 1. This is a core component of the algorithm, used to
decide whether to accept or reject a proposed new state. 符号
<code>rand t \in (0,1)</code> 表示使用从 0 到 1
之间的均匀分布中抽取的随机数 <span
class="math inline">\(t\)</span>。这是算法的核心部分，用于决定是否接受或拒绝提议的新状态。</li>
<li><strong>Detailed Balance Condition:</strong> The equation <span
class="math inline">\(P_o T(o \to n) = P_n T(n \to o)\)</span> is the
principle of detailed balance. It states that in a system at
equilibrium, the probability of being in an old state (<span
class="math inline">\(o\)</span>) and transitioning to a new state
(<span class="math inline">\(n\)</span>) is equal to the probability of
being in the new state and transitioning back to the old one. This
condition is crucial because it ensures that the simulation will
eventually sample states according to their correct thermodynamic
probabilities (the Boltzmann distribution). 方程 <span
class="math inline">\(P_o T(o \to n) = P_n T(n \to o)\)</span>
是详细平衡的原理。它指出，在平衡系统中，处于旧状态 (<span
class="math inline">\(o\)</span>) 并转变为新状态 (<span
class="math inline">\(n\)</span>)
的概率等于处于新状态并转变回旧状态的概率。此条件至关​​重要，因为它确保模拟最终将根据正确的热力学概率（玻尔兹曼分布）对状态进行采样。</li>
<li><strong>Acceptance Rate:</strong> The note <code>\sim 30\%?</code>
likely refers to the target <strong>acceptance rate</strong> for an
efficient Metropolis MC simulation. If new states are accepted too often
or too rarely, the exploration of the system’s possible configurations
is inefficient. While the famous optimal acceptance rate for certain
high-dimensional problems is around 23.4%, a range of 20-50% is often
considered effective. 注释“30%？”指的是高效 Metropolis
蒙特卡罗模拟的目标<strong>接受率</strong>。如果新状态接受过于频繁或过于稀少，系统对可能配置的探索就会变得低效。虽然某些高维问题的最佳接受率约为
23.4%，但通常认为 20-50% 的范围是有效的。</li>
</ul>
<h3 id="hamiltonian-hybrid-monte-carlo-hmc">2. Hamiltonian / Hybrid
Monte Carlo (HMC)</h3>
<p>The second topic, “Hamiltonian/Hybrid MC (HMC),” is a more advanced
Monte Carlo method that uses principles from classical mechanics to
propose new states more intelligently than the simple random-walk
approach of the standard Metropolis method. This often leads to a much
higher acceptance rate and more efficient exploration of the state
space. 第二个主题“哈密顿/混合蒙特卡罗
(HMC)”是一种更先进的蒙特卡罗方法，它利用经典力学原理，比标准 Metropolis
方法中简单的随机游走方法更智能地提出新状态。这通常会带来更高的接受率和更高效的状态空间探索。</p>
<p>The whiteboard outlines a four-step HMC algorithm:</p>
<p><strong>Step 1: Randomize Velocities</strong> The first step is to
randomize the velocities: <span class="math inline">\(\vec{v}_i \sim
\mathcal{N}(0, k_B T)\)</span>. 第一步是随机化速度：<span
class="math inline">\(\vec{v}_i \sim \mathcal{N}(0, k_B T)\)</span>。 *
This step introduces momentum into the system. For each particle <span
class="math inline">\(i\)</span>, a velocity vector <span
class="math inline">\(\vec{v}_i\)</span> is randomly drawn from a normal
(Gaussian) distribution with a mean of 0 and a variance related to the
temperature <span class="math inline">\(T\)</span> and the Boltzmann
constant <span class="math inline">\(k_B\)</span>.
此步骤将动量引入系统。对于每个粒子 <span
class="math inline">\(i\)</span>，速度矢量 <span
class="math inline">\(\vec{v}_i\)</span>
会随机地从正态（高斯）分布中抽取，该分布的均值为 0，方差与温度 <span
class="math inline">\(T\)</span> 和玻尔兹曼常数 <span
class="math inline">\(k_B\)</span> 相关。 * The full formula for this
probability distribution, <span
class="math inline">\(f(\vec{v})\)</span>, is the
<strong>Maxwell-Boltzmann distribution</strong>, which is written out
further down the board. 该概率分布的完整公式 <span
class="math inline">\(f(\vec{v})\)</span>
是<strong>麦克斯韦-玻尔兹曼分布</strong>。</p>
<p><strong>Step 2: Molecular Dynamics (MD) Integration</strong> The
board notes this as <code>t=0 \to h \text&#123; or &#125; mh</code>
<code>MD</code> and mentions the <code>Verlet</code> algorithm.</p>
<ul>
<li>This is the “Hamiltonian dynamics” part of the algorithm. Starting
from the current positions and the newly randomized velocities, the
system’s trajectory is calculated for a short period of time (<span
class="math inline">\(h\)</span> or <span
class="math inline">\(mh\)</span>) using Molecular Dynamics (MD).
这是算法的“哈密顿动力学”部分。从当前位置和新随机化的速度开始，使用分子动力学
(MD) 计算系统在短时间内（<span class="math inline">\(h\)</span> 或 <span
class="math inline">\(mh\)</span>）的轨迹。</li>
<li>The name <strong>Verlet</strong> refers to the Verlet integration
algorithm, a numerical method used to solve Newton’s equations of
motion. It is popular in MD simulations because it is time-reversible
and conserves energy well over long simulations. 指的是 Verlet
积分算法，这是一种用于求解牛顿运动方程的数值方法。它在 MD
模拟中很受欢迎，因为它具有时间可逆性，并且在长时间模拟中能量守恒效果良好。</li>
</ul>
<p><strong>Step 3: Calculate Total Energy</strong> The third step is to
<code>calculate total energy</code>: <span class="math inline">\(E_n =
K_n + V_n\)</span>. 第三步是“计算总能量”：<span
class="math inline">\(E_n = K_n + V_n\)</span>。 * After the MD
trajectory, the system is in a new state <span
class="math inline">\(n\)</span>. The total energy of this new state,
<span class="math inline">\(E_n\)</span>, is calculated as the sum of
its kinetic energy (<span class="math inline">\(K_n\)</span>, from the
velocities) and its potential energy (<span
class="math inline">\(V_n\)</span>, from the positions). MD
轨迹之后，系统处于新状态 <span
class="math inline">\(n\)</span>。新状态的总能量 <span
class="math inline">\(E_n\)</span> 等于其动能 (<span
class="math inline">\(K_n\)</span>，由速度计算得出）和势能 (<span
class="math inline">\(V_n\)</span>，由位置计算得出)之和。</p>
<p><strong>Step 4: Acceptance Test</strong> The final step is the
acceptance criterion: <span class="math inline">\(\text{acc}(o \to n) =
\min(1, e^{-\beta(E_n - E_o)})\)</span>. 最后一步是验收标准：<span
class="math inline">\(\text{acc}(o \to n) = \min(1, e^{-\beta(E_n -
E_o)})\)</span>。 * This is the Metropolis acceptance criterion. The
algorithm decides whether to accept the new state <span
class="math inline">\(n\)</span> or reject it and stay in the old state
<span class="math inline">\(o\)</span>. 这是 Metropolis
验收标准。算法决定是接受新状态 <span class="math inline">\(n\)</span>
还是拒绝它并保持旧状态 <span class="math inline">\(o\)</span>。 * The
probability of acceptance depends on the change in total energy (<span
class="math inline">\(E_n - E_o\)</span>). If the new energy is lower,
the move is always accepted. If the new energy is higher, it might still
be accepted with a probability <span class="math inline">\(e^{-\beta(E_n
- E_o)}\)</span>, where <span class="math inline">\(\beta = 1/(k_B
T)\)</span>. This allows the system to escape from local energy minima.
验收概率取决于总能量的变化 (<span class="math inline">\(E_n -
E_o\)</span>)。如果新能量较低，则始终接受该移动。如果新的能量更高，它仍然可能以概率
<span class="math inline">\(e^{-\beta(E_n - E_o)}\)</span> 被接受，其中
<span class="math inline">\(\beta = 1/(k_B
T)\)</span>。这使得系统能够摆脱局部能量最小值。</p>
<h3 id="key-formulas-and-notations">Key Formulas and Notations</h3>
<ul>
<li><p><strong>Maxwell-Boltzmann
Distribution麦克斯韦-玻尔兹曼分布:</strong> The formula for the velocity
distribution is given as: <span class="math inline">\(f(\vec{v}) =
\left(\frac{m}{2\pi k_B T}\right)^{3/2} \exp\left(-\frac{m v^2}{2 k_B
T}\right)\)</span> This gives the probability density for a particle of
mass <span class="math inline">\(m\)</span> to have a velocity <span
class="math inline">\(\vec{v}\)</span> at a given temperature <span
class="math inline">\(T\)</span>.质量为 <span
class="math inline">\(m\)</span> 的粒子速度为 的概率密度</p></li>
<li><p><strong>Energy Conservation and Acceptance Rate:</strong> The
notes <span class="math inline">\(E_n \approx E_o\)</span> and <span
class="math inline">\(75\%\)</span> highlight a key advantage of HMC.
Because the Verlet integrator approximately conserves energy, the final
energy <span class="math inline">\(E_n\)</span> after the MD trajectory
is usually very close to the initial energy <span
class="math inline">\(E_o\)</span>. This means the term <span
class="math inline">\((E_n - E_o)\)</span> is small, and the acceptance
probability is high. The <span class="math inline">\(75\%\)</span>
indicates a typical or target acceptance rate for HMC, which is
significantly higher than for standard Metropolis MC. 注释 <span
class="math inline">\(E_n \approx E_o\)</span> 和 <span
class="math inline">\(75\%\)</span> 凸显了 HMC 的一个关键优势。由于
Verlet 积分器近似地守恒能量，MD 轨迹后的最终能量 <span
class="math inline">\(E_n\)</span> 通常非常接近初始能量 <span
class="math inline">\(E_o\)</span>。这意味着 <span
class="math inline">\((E_n - E_o)\)</span> 项很小，接受概率很高。<span
class="math inline">\(75\%\)</span> 表示 HMC
的典型或目标接受率，明显高于标准 Metropolis MC。</p></li>
<li><p><strong>Hamiltonian Operator:</strong> The symbol <span
class="math inline">\(\hat{H}\)</span> written on the adjacent board
represents the Hamiltonian operator, which gives the total energy of the
system. The note <code>Δ Adiabatic</code> suggests that the MD evolution
is ideally an adiabatic process (no heat exchange), during which the
total energy (the Hamiltonian) is conserved. 相邻板上的符号 <span
class="math inline">\(\hat{H}\)</span>
代表哈密顿算符，它给出了系统的总能量。注释“Δ Adiabatic”表明 MD
演化在理想情况下是一个绝热过程（无热交换），在此过程中总能量（哈密顿量）守恒。</p></li>
</ul>
<p>This whiteboard displays the fundamental equation of quantum
chemistry: the time-dependent Schrödinger equation, along with the
detailed breakdown of the molecular Hamiltonian operator. This equation
is the starting point for almost all <em>ab initio</em>
(first-principles) quantum mechanical calculations of molecular systems.
这块白板展示了量子化学的基本方程：含时薛定谔方程，以及分子哈密顿算符的详细分解。该方程是几乎所有分子系统<em>从头算</em>（第一性原理）量子力学计算的起点。</p>
<h3 id="the-time-dependent-schrödinger-equation">3. The Time-Dependent
Schrödinger Equation</h3>
<p>At the top of the board, the fundamental equation governing the
evolution of a quantum mechanical system is presented:
白板顶部显示了控制量子力学系统演化的基本方程： <span
class="math inline">\(i\hbar \frac{\partial \Psi}{\partial t} =
\hat{\mathcal{H}} \Psi\)</span></p>
<ul>
<li><p><strong><span class="math inline">\(\Psi\)</span> (Psi)</strong>
is the <strong>wave function</strong> of the system. It contains all the
information that can be known about the system (e.g., the positions and
momenta of all particles).
是系统的<strong>波函数</strong>。它包含了关于系统的所有已知信息（例如，所有粒子的位置和动量）。</p></li>
<li><p><strong><span
class="math inline">\(\hat{\mathcal{H}}\)</span></strong> is the
<strong>Hamiltonian operator</strong>, which represents the total energy
of the system.
是<strong>哈密顿算符</strong>，表示系统的总能量。</p></li>
<li><p><strong><span class="math inline">\(i\)</span></strong>
是虚数单位。</p></li>
<li><p><strong><span class="math inline">\(i\)</span></strong> is the
imaginary unit.</p></li>
<li><p><strong><span class="math inline">\(\hbar\)</span></strong> is
the <strong>reduced Planck
constant</strong>.是<strong>约化普朗克常数</strong>。</p></li>
<li><p><strong><span class="math inline">\(\frac{\partial \Psi}{\partial
t}\)</span></strong> represents how the wave function changes over
time.表示波函数随时间的变化。</p></li>
</ul>
<p>This equation states that the time evolution of the quantum state is
dictated by the system’s total energy operator, the Hamiltonian. The
note “Δ Adiabatic process” likely connects to the context of the
Born-Oppenheimer approximation, where the electronic Schrödinger
equation is solved for fixed nuclear positions, assuming the electrons
adjust adiabatically (instantaneously) to the motion of the nuclei.
该方程表明，量子态的时间演化由系统的总能量算符——哈密顿算符决定。注释“Δ绝热过程”与玻恩-奥本海默近似相关，在该近似中，电子薛定谔方程是针对固定原子核位置求解的，假设电子以绝热方式（瞬时）调整以适应原子核的运动。</p>
<h3 id="the-full-molecular-hamiltonian-hatmathcalh">4. The Full
Molecular Hamiltonian (<span
class="math inline">\(\hat{\mathcal{H}}\)</span>)</h3>
<p>The main part of the whiteboard is the detailed expression for the
non-relativistic, time-independent molecular Hamiltonian. It is the sum
of the kinetic and potential energies of all the nuclei and electrons in
the system. The equation can be broken down into five distinct terms:
白板的主要部分是非相对论性、时间无关的分子哈密顿量的详细表达式。它是系统中所有原子核和电子的动能和势能之和。</p>
<p>该方程可以分解为五个不同的项：</p>
<p><span class="math inline">\(\hat{\mathcal{H}} = -\sum_{I=1}^{P}
\frac{\hbar^2}{2M_I}\nabla_I^2 - \sum_{i=1}^{N}
\frac{\hbar^2}{2m}\nabla_i^2 + \frac{e^2}{2}\sum_{I=1}^{P}\sum_{J \neq
I}^{P} \frac{Z_I Z_J}{|\vec{R}_I - \vec{R}_J|} +
\frac{e^2}{2}\sum_{i=1}^{N}\sum_{j \neq i}^{N} \frac{1}{|\vec{r}_i -
\vec{r}_j|} - e^2\sum_{I=1}^{P}\sum_{i=1}^{N} \frac{Z_I}{|\vec{R}_I -
\vec{r}_i|}\)</span></p>
<p>Let’s analyze each component:</p>
<p><strong>A. Kinetic Energy Terms 动能项</strong></p>
<ol type="1">
<li><strong>Kinetic Energy of the Nuclei 原子核的动能:</strong> <span
class="math inline">\(-\sum_{I=1}^{P}
\frac{\hbar^2}{2M_I}\nabla_I^2\)</span> This term is the sum of the
kinetic energy operators for all the nuclei in the
system.此项是系统中所有原子核的动能算符之和。
<ul>
<li>The sum is over all nuclei, indexed by <span
class="math inline">\(I\)</span> from 1 to <span
class="math inline">\(P\)</span>.该和涵盖所有原子核，索引为 <span
class="math inline">\(I\)</span>，从 1 到 <span
class="math inline">\(P\)</span>。</li>
<li><span class="math inline">\(M_I\)</span> is the mass of nucleus
<span class="math inline">\(I\)</span>.是原子核 <span
class="math inline">\(I\)</span> 的质量。</li>
<li><span class="math inline">\(\nabla_I^2\)</span> is the Laplacian
operator, which involves the second spatial derivatives with respect to
the coordinates of nucleus <span
class="math inline">\(I\)</span>.是拉普拉斯算符，它涉及原子核 <span
class="math inline">\(I\)</span> 坐标的二阶空间导数。</li>
</ul></li>
<li><strong>Kinetic Energy of the Electrons 电子的动能:</strong> <span
class="math inline">\(-\sum_{i=1}^{N}
\frac{\hbar^2}{2m}\nabla_i^2\)</span> This is the corresponding sum of
the kinetic energy operators for all the
electrons.这是所有电子的动能算符的对应和。
<ul>
<li>The sum is over all electrons, indexed by <span
class="math inline">\(i\)</span> from 1 to <span
class="math inline">\(N\)</span>.该和是针对所有电子的，索引为 <span
class="math inline">\(i\)</span>，从 1 到 <span
class="math inline">\(N\)</span>。</li>
<li><span class="math inline">\(m\)</span> is the mass of an
electron.是电子的质量。</li>
<li><span class="math inline">\(\nabla_i^2\)</span> is the Laplacian
operator with respect to the coordinates of electron <span
class="math inline">\(i\)</span>.是关于电子 <span
class="math inline">\(i\)</span> 坐标的拉普拉斯算符。</li>
</ul></li>
</ol>
<p><strong>B. Potential Energy Terms (Electrostatic Interactions)
势能项（静电相互作用）</strong></p>
<ol start="3" type="1">
<li><strong>Nuclear-Nuclear Repulsion 核间排斥力:</strong> <span
class="math inline">\(+\frac{e^2}{2}\sum_{I=1}^{P}\sum_{J \neq I}^{P}
\frac{Z_I Z_J}{|\vec{R}_I - \vec{R}_J|}\)</span> This term represents
the potential energy from the electrostatic (Coulomb) repulsion between
all pairs of positively charged
nuclei.该项表示所有带正电原子核对之间静电（库仑）排斥力产生的势能。
<ul>
<li>The double summation runs over all unique pairs of nuclei (<span
class="math inline">\(I, J\)</span>).对所有唯一的原子核对 (<span
class="math inline">\(I, J\)</span>) 进行双重求和。</li>
<li><span class="math inline">\(Z_I\)</span> is the atomic number (i.e.,
the charge) of nucleus <span class="math inline">\(I\)</span>.是原子核
<span class="math inline">\(I\)</span> 的原子序数（即电荷）。</li>
<li><span class="math inline">\(\vec{R}_I\)</span> is the position
vector of nucleus <span class="math inline">\(I\)</span>.是原子核 <span
class="math inline">\(I\)</span> 的位置矢量。</li>
<li><span class="math inline">\(e\)</span> is the elementary
charge.是基本电荷。</li>
</ul></li>
<li><strong>Electron-Electron Repulsion 电子间排斥力:</strong> <span
class="math inline">\(+\frac{e^2}{2}\sum_{i=1}^{N}\sum_{j \neq i}^{N}
\frac{1}{|\vec{r}_i - \vec{r}_j|}\)</span> This term represents the
potential energy from the electrostatic repulsion between all pairs of
negatively charged
electrons.该项表示所有带负电的电子对之间静电排斥的势能。
<ul>
<li>The double summation runs over all unique pairs of electrons (<span
class="math inline">\(i, j\)</span>).对所有不同的电子对 (<span
class="math inline">\(i, j\)</span>) 进行双重求和。</li>
<li><span class="math inline">\(\vec{r}_i\)</span> is the position
vector of electron <span class="math inline">\(i\)</span>.是电子 <span
class="math inline">\(i\)</span> 的位置矢量。</li>
</ul></li>
<li><strong>Nuclear-Electron Attraction 核-电子引力:</strong> <span
class="math inline">\(-e^2\sum_{I=1}^{P}\sum_{i=1}^{N}
\frac{Z_I}{|\vec{R}_I - \vec{r}_i|}\)</span> This final term represents
the potential energy from the electrostatic attraction between the
nuclei and the electrons.这最后一项表示原子核和电子之间静电引力的势能。
<ul>
<li>The summation runs over all nuclei and all
electrons.该求和适用于所有原子核和所有电子。</li>
</ul></li>
</ol>
<h3 id="notations-and-conventions">5. Notations and Conventions</h3>
<ul>
<li><strong>Atomic Units:</strong> The note <span
class="math inline">\(\frac{1}{4\pi\epsilon_0} = k = 1\)</span> is a key
indicator of the convention being used. This sets the Coulomb constant
to 1, which is a hallmark of <strong>Hartree atomic units</strong>. In
this system, the elementary charge (<span
class="math inline">\(e\)</span>), electron mass (<span
class="math inline">\(m\)</span>), and reduced Planck constant (<span
class="math inline">\(\hbar\)</span>) are also set to 1. This simplifies
the Hamiltonian significantly, removing the physical constants and
making the equations easier to work with computationally.
是所用约定的关键指标。这将库仑常数设置为 1，这是<strong>Hartree
原子单位</strong>的标志。在这个系统中，基本电荷 (<span
class="math inline">\(e\)</span>)、电子质量 (<span
class="math inline">\(m\)</span>) 和​​约化普朗克常数 (<span
class="math inline">\(\hbar\)</span>) 也设为
1。这显著简化了哈密顿量，消除了物理常数，使方程更易于计算。</li>
<li><strong>Interaction Terms:</strong> The notations <span
class="math inline">\(\{i, j\}\)</span>, <span
class="math inline">\(\{i, j, k\}\)</span>, etc., refer to the
“many-body” problem. The Hamiltonian contains two-body terms
(interactions between pairs of particles), and solving the Schrödinger
equation exactly is extremely difficult because the motion of every
particle is correlated with every other particle. Computational methods
are designed to approximate these interactions. 符号 <span
class="math inline">\(\{i, j\}\)</span>、<span
class="math inline">\(\{i, j, k\}\)</span>
等指的是“多体”问题。哈密顿量包含二体项（粒子对之间的相互作用），而精确求解薛定谔方程极其困难，因为每个粒子的运动都与其他粒子相关。计算方法旨在近似这些相互作用。</li>
</ul>
<p>This whiteboard presents the mathematical foundation for
<strong>non-adiabatic molecular dynamics</strong>, a sophisticated
method in theoretical chemistry and physics used to simulate processes
where the Born-Oppenheimer approximation breaks down. This typically
occurs in photochemistry, electron transfer reactions, and when
molecules interact with intense laser fields.
这块白板展示了<strong>非绝热分子动力学</strong>的数学基础，这是理论化学和物理学中一种复杂的方法，用于模拟玻恩-奥本海默近似失效的过程。这通常发生在光化学、电子转移反应以及分子与强激光场相互作用时。</p>
<h3
id="topic-non-adiabatic-molecular-dynamics-md-非绝热分子动力学-md">6.
Topic: Non-Adiabatic Molecular Dynamics (MD) 非绝热分子动力学 (MD)</h3>
<p>The title “Δ non-adiabatic MD” indicates that the topic moves beyond
the standard Born-Oppenheimer approximation. In this approximation, it
is assumed that the light electrons adjust instantaneously to the motion
of the heavy nuclei, allowing the system to be described by a single
potential energy surface. Non-adiabatic methods, by contrast, account
for the quantum mechanical coupling between multiple electronic
states.</p>
<p>标题“Δ 非绝热
MD”表明该主题超越了标准的玻恩-奥本海默近似。在该近似中，假设轻电子会根据重原子核的运动进行瞬时调整，从而使系统可以用单个势能面来描述。相比之下，非绝热方法则考虑了多个电子态之间的量子力学耦合。</p>
<h3 id="the-born-huang-ansatz-玻恩-黄拟设">7. The Born-Huang Ansatz
玻恩-黄拟设</h3>
<p>The starting point for this method is the “ansatz” (an educated guess
for the form of the solution). This is the Born-Huang expansion for the
total molecular wave function, <span
class="math inline">\(\Psi\)</span>.
该方法的起点是“拟设”（对解形式的合理猜测）。这是分子总波函数 <span
class="math inline">\(\Psi\)</span> 的玻恩-黄展开式。</p>
<p><span class="math inline">\(\Psi(\vec{R}, \vec{r}, t) = \sum_{n}
\Theta_n(\vec{R}, t) \Phi_n(\vec{R}, \vec{r})\)</span></p>
<ul>
<li><p><strong><span class="math inline">\(\Psi(\vec{R}, \vec{r},
t)\)</span></strong> is the total wave function for the entire molecule.
It depends on the coordinates of all nuclei (<span
class="math inline">\(\vec{R}\)</span>), all electrons (<span
class="math inline">\(\vec{r}\)</span>), and time (<span
class="math inline">\(t\)</span>).
是整个分子的总波函数。它取决于所有原子核 (<span
class="math inline">\(\vec{R}\)</span>)、所有电子 (<span
class="math inline">\(\vec{r}\)</span>) 和时间 (<span
class="math inline">\(t\)</span>) 的坐标。</p></li>
<li><p><strong><span class="math inline">\(\Phi_n(\vec{R},
\vec{r})\)</span></strong> are the <strong>electronic wave
functions</strong>. They are the solutions to the electronic Schrödinger
equation for a fixed nuclear geometry <span
class="math inline">\(\vec{R}\)</span> and form a complete basis set.
The index <span class="math inline">\(n\)</span> labels the electronic
state (e.g., ground state, first excited state, etc.).
它们是给定原子核几何构型 <span class="math inline">\(\vec{R}\)</span>
的电子薛定谔方程的解，并构成一个完整的基组。下标 <span
class="math inline">\(n\)</span>
标记电子态（例如，基态、第一激发态等）。</p></li>
<li><p><strong><span class="math inline">\(\Theta_n(\vec{R},
t)\)</span></strong> are the <strong>nuclear wave functions</strong>.
Each <span class="math inline">\(\Theta_n\)</span> describes the motion
of the nuclei on the potential energy surface of the corresponding
electronic state, <span class="math inline">\(\Phi_n\)</span>.
Crucially, they depend on time. 是<strong>核波函数</strong>。每个 <span
class="math inline">\(\Theta_n\)</span> 描述原子核在相应电子态 <span
class="math inline">\(\Phi_n\)</span>
势能面上的运动。至关重要的是，它们依赖于时间。</p></li>
</ul>
<p>This ansatz expresses the total molecular state as a superposition of
electronic states, where the coefficients of the superposition are the
nuclear wave functions.
该拟设将总分子态表示为电子态的叠加，其中叠加的系数是核波函数。</p>
<h3 id="the-partitioned-molecular-hamiltonian-分割分子哈密顿量">8. The
Partitioned Molecular Hamiltonian 分割分子哈密顿量</h3>
<p>The total molecular Hamiltonian, <span
class="math inline">\(\hat{\mathcal{H}}\)</span>, is partitioned into
terms that act on the nuclei and electrons separately. 总分子哈密顿量
<span class="math inline">\(\hat{\mathcal{H}}\)</span>
被分割成分别作用于原子核和电子的项。</p>
<p><span class="math inline">\(\hat{\mathcal{H}} = -\sum_{I}
\frac{\hbar^2}{2M_I}\nabla_I^2 + \hat{\mathcal{H}}_e +
\hat{V}_{nn}\)</span></p>
<ul>
<li><p><strong><span class="math inline">\(-\sum_{I}
\frac{\hbar^2}{2M_I}\nabla_I^2\)</span></strong>: This is the kinetic
energy operator for the nuclei, often denoted as <span
class="math inline">\(\hat{T}_n\)</span>.这是原子核的动能算符，通常表示为
<span class="math inline">\(\hat{T}_n\)</span>。</p></li>
<li><p><strong><span
class="math inline">\(\hat{\mathcal{H}}_e\)</span></strong>: This is the
<strong>electronic Hamiltonian</strong>, which includes the kinetic
energy of the electrons and the potential energy of electron-electron
and electron-nuclear interactions.
这是<strong>电子哈密顿量</strong>，包含电子的动能以及电子-电子和电子-核相互作用的势能。</p></li>
<li><p><strong><span
class="math inline">\(\hat{V}_{nn}\)</span></strong>: This is the
potential energy operator for <strong>nuclear-nuclear
repulsion</strong>.这是<strong>核-核排斥</strong>的势能算符。</p></li>
</ul>
<h3 id="the-electronic-schrödinger-equation-电子薛定谔方程">9. The
Electronic Schrödinger Equation 电子薛定谔方程</h3>
<p>The electronic basis functions, <span
class="math inline">\(\Phi_n\)</span>, are defined as the eigenfunctions
of the electronic Hamiltonian (plus the nuclear repulsion term) for a
fixed nuclear configuration <span
class="math inline">\(\vec{R}\)</span>. 电子基函数 <span
class="math inline">\(\Phi_n\)</span> 定义为对于固定的核构型 <span
class="math inline">\(\vec{R}\)</span>，电子哈密顿量（加上核排斥项）的本征函数。</p>
<p><span class="math inline">\((\hat{\mathcal{H}}_e + \hat{V}_{nn})
\Phi_n(\vec{R}, \vec{r}) = E_n(\vec{R}) \Phi_n(\vec{R},
\vec{r})\)</span></p>
<ul>
<li><strong><span class="math inline">\(E_n(\vec{R})\)</span></strong>
are the eigenvalues, which are the <strong>potential energy surfaces
(PES)</strong>. Each electronic state <span
class="math inline">\(n\)</span> has its own PES, which dictates the
forces acting on the nuclei when the molecule is in that electronic
state. 是特征值，即<strong>势能面 (PES)</strong>。每个电子态 <span
class="math inline">\(n\)</span>
都有其自身的势能面，它决定了分子处于该电子态时作用于原子核的力。</li>
</ul>
<h3
id="deriving-the-equations-of-motion-for-the-nuclei-推导原子核运动方程">10.
Deriving the Equations of Motion for the Nuclei 推导原子核运动方程</h3>
<p>The final part of the whiteboard begins the derivation of the
time-dependent Schrödinger equation for the nuclear wave functions,
<span class="math inline">\(\Theta_k\)</span>. The process starts with
the full time-dependent Schrödinger equation, <span
class="math inline">\(i\hbar \frac{\partial \Psi}{\partial t} =
\hat{\mathcal{H}} \Psi\)</span>. To find the equation for a specific
nuclear wave function <span class="math inline">\(\Theta_k\)</span>,
this main equation is projected onto the corresponding electronic basis
state <span class="math inline">\(\Phi_k\)</span>.
白板的最后一部分开始推导原子核波函数 <span
class="math inline">\(\Theta_k\)</span>
的含时薛定谔方程。该过程从完整的含时薛定谔方程 <span
class="math inline">\(i\hbar \frac{\partial \Psi}{\partial t} =
\hat{\mathcal{H}} \Psi\)</span> 开始。为了找到特定原子核波函数 <span
class="math inline">\(\Theta_k\)</span>
的方程，需要将这个主方程投影到相应的电子基态 <span
class="math inline">\(\Phi_k\)</span> 上。</p>
<p>This is done by multiplying from the left by the complex conjugate of
the electronic wave function, <span
class="math inline">\(\Phi_k^*\)</span>, and integrating over all
electronic coordinates, <span class="math inline">\(d\vec{r}\)</span>.
可以通过从左边乘以电子波函数 <span
class="math inline">\(\Phi_k^*\)</span> 的复共轭，然后在所有电子坐标
<span class="math inline">\(d\vec{r}\)</span> 上积分来实现。</p>
<p><span class="math inline">\(\int \Phi_k^* i\hbar
\frac{\partial}{\partial t} \Psi \,d\vec{r} = \int \Phi_k^*
\hat{\mathcal{H}} \Psi \,d\vec{r}\)</span></p>
<p>The board then shows the result of substituting the Born-Huang ansatz
for <span class="math inline">\(\Psi\)</span> and the partitioned
Hamiltonian for <span class="math inline">\(\hat{\mathcal{H}}\)</span>
into this projected equation: 然后，黑板显示将 Born-Huang 拟设式代入
<span
class="math inline">\(\Psi\)</span>，将分块哈密顿量代入以下投影方程的结果：</p>
<p><span class="math inline">\(i\hbar \frac{\partial}{\partial t}
\Theta_k(\vec{R}, t) = \int \Phi_k^* \left( -\sum_{I}
\frac{\hbar^2}{2M_I}\nabla_I^2 + \hat{\mathcal{H}}_e + \hat{V}_{nn}
\right) \sum_n \Theta_n \Phi_n \,d\vec{r}\)</span></p>
<ul>
<li><p><strong>Left Hand Side</strong>: The left side of the projection
has been simplified. Because the electronic basis functions <span
class="math inline">\(\Phi_n\)</span> form an orthonormal set (<span
class="math inline">\(\int \Phi_k^* \Phi_n d\vec{r} =
\delta_{kn}\)</span>), the sum collapses to a single term for <span
class="math inline">\(n=k\)</span>. 投影左侧已简化。由于电子基函数 <span
class="math inline">\(\Phi_n\)</span> 构成一个正交集 (<span
class="math inline">\(\int \Phi_k^* \Phi_n d\vec{r} =
\delta_{kn}\)</span>，因此当 <span class="math inline">\(n=k\)</span>
时，和将折叠为一个项。</p></li>
<li><p><strong>Right Hand Side</strong>: This complex integral is the
core of non-adiabatic dynamics. When the nuclear kinetic energy
operator, <span class="math inline">\(\nabla_I^2\)</span>, acts on the
product <span class="math inline">\(\Theta_n \Phi_n\)</span>, it acts on
both functions (via the product rule). The terms that arise from <span
class="math inline">\(\nabla_I\)</span> acting on the electronic wave
functions <span class="math inline">\(\Phi_n\)</span> are known as
<strong>non-adiabatic coupling terms</strong>. These terms are
responsible for enabling transitions between different electronic
potential energy surfaces, which is the essence of non-adiabatic
dynamics. 这个复积分是非绝热动力学的核心。当核动能算符 <span
class="math inline">\(\nabla_I^2\)</span> 作用于乘积 <span
class="math inline">\(\Theta_n \Phi_n\)</span>
时，它会作用于这两个函数（通过乘积规则）。由 <span
class="math inline">\(\nabla_I\)</span> 作用于电子波函数 <span
class="math inline">\(\Phi_n\)</span>
而产生的项称为<strong>非绝热耦合项</strong>。这些术语负责实现不同电子势能面之间的转变，这是非绝热动力学的本质。</p></li>
</ul>
<p>This whiteboard continues the mathematical derivation for
non-adiabatic molecular dynamics started in the previous image. It
focuses on expanding the nuclear kinetic energy term to reveal the
crucial couplings between different electronic
states.这块白板延续了上一张图片中非绝热分子动力学的数学推导。它着重于扩展核动能项，以揭示不同电子态之间的关键耦合。</p>
<h3
id="starting-point-the-projected-schrödinger-equation-起点投影薛定谔方程">11.
Starting Point: The Projected Schrödinger Equation
起点：投影薛定谔方程</h3>
<p>The derivation picks up from the equation for the time evolution of
the nuclear wave function, <span
class="math inline">\(\Theta_k\)</span>. The right-hand side of this
equation is being evaluated. 推导过程取自核波函数 <span
class="math inline">\(\Theta_k\)</span>
的时间演化方程。该方程的右边正在求值。</p>
<p><span class="math inline">\(= \int \Phi_k^* \left( -\sum_{I}
\frac{\hbar^2}{2M_I}\nabla_I^2 \right) \sum_n \Theta_n \Phi_n \,d\vec{r}
+ E_k \Theta_k\)</span></p>
<p>This equation separates the total energy into two parts
该方程将总能量分为两部分 : * The first term is the contribution from the
<strong>nuclear kinetic energy operator</strong>, <span
class="math inline">\(-\sum_{I} \frac{\hbar^2}{2M_I}\nabla_I^2\)</span>.
第一项是<strong>核动能算符</strong>的贡献 * The second term, <span
class="math inline">\(E_k \Theta_k\)</span>, is the contribution from
the <strong>potential energy</strong>. This term arises from the action
of the electronic Hamiltonian part <span
class="math inline">\((\hat{\mathcal{H}}_e + \hat{V}_{nn})\)</span> on
the basis functions. Due to the orthonormality of the electronic
wavefunctions (<span class="math inline">\(\int \Phi_k^* \Phi_n
\,d\vec{r} = \delta_{kn}\)</span>), the sum over <span
class="math inline">\(n\)</span> collapses to a single term for the
potential energy. 第二项，<span class="math inline">\(E_k
\Theta_k\)</span>，是<strong>势能</strong>的贡献。这一项源于电子哈密顿量部分
<span class="math inline">\((\hat{\mathcal{H}}_e +
\hat{V}_{nn})\)</span> 对基函数的作用。由于电子波函数（<span
class="math inline">\(\int \Phi_k^* \Phi_n \,d\vec{r} =
\delta_{kn}\)</span>）的正交性，<span
class="math inline">\(n\)</span>项的和会坍缩为势能的一项。</p>
<p>The challenge, and the core of the physics, lies in evaluating the
first term, as the nuclear derivative <span
class="math inline">\(\nabla_I\)</span> acts on <em>both</em> the
nuclear wave function <span class="math inline">\(\Theta_n\)</span> and
the electronic wave function <span
class="math inline">\(\Phi_n\)</span>.
难点在于，也是物理的核心在于如何计算第一项，因为核导数 <span
class="math inline">\(\nabla_I\)</span> 同时作用于核波函数 <span
class="math inline">\(\Theta_n\)</span> 和电子波函数 <span
class="math inline">\(\Phi_n\)</span>。</p>
<h3
id="applying-the-product-rule-for-the-laplacian-应用拉普拉斯算子的乘积规则">12.
Applying the Product Rule for the Laplacian
应用拉普拉斯算子的乘积规则</h3>
<p>To expand the kinetic energy term, the product rule for the Laplacian
operator acting on two functions (A and B) is used. The board writes
this rule as: 为了展开动能项，我们利用了拉普拉斯算子作用于两个函数（A 和
B）的乘积规则。棋盘上将这条规则写成： <span
class="math inline">\(\nabla^2(AB) = (\nabla^2 A)B + 2(\nabla
A)\cdot(\nabla B) + A(\nabla^2 B)\)</span></p>
<p>In our case, <span class="math inline">\(A = \Theta_n(\vec{R},
t)\)</span> and <span class="math inline">\(B = \Phi_n(\vec{R},
\vec{r})\)</span>. The derivative <span
class="math inline">\(\nabla_I\)</span> is with respect to the nuclear
coordinates <span class="math inline">\(\vec{R}_I\)</span>.
在我们的例子中，<span class="math inline">\(A = \Theta_n(\vec{R},
t)\)</span>，<span class="math inline">\(B = \Phi_n(\vec{R},
\vec{r})\)</span>。导数 <span class="math inline">\(\nabla_I\)</span>
是关于原子核坐标 <span class="math inline">\(\vec{R}_I\)</span> 的。</p>
<h3 id="expanding-the-kinetic-energy-term-展开动能项">13. Expanding the
Kinetic Energy Term 展开动能项</h3>
<p>Applying this rule, the integral containing the kinetic energy
operator is expanded: 应用此规则，展开包含动能算符的积分： <span
class="math inline">\(= -\sum_I \frac{\hbar^2}{2M_I} \int \Phi_k^*
\sum_n \left( (\nabla_I^2 \Theta_n)\Phi_n + 2(\nabla_I
\Theta_n)\cdot(\nabla_I \Phi_n) + \Theta_n(\nabla_I^2 \Phi_n) \right)
d\vec{r} + E_k \Theta_k\)</span></p>
<p>This step explicitly shows how the nuclear kinetic energy operator
gives rise to three distinct types of
terms.此步骤明确展示了核动能算符如何产生三种不同类型的项。</p>
<h3
id="final-result-and-identification-of-coupling-terms-最终结果及耦合项的识别">14.
Final Result and Identification of Coupling Terms
最终结果及耦合项的识别</h3>
<p>The final step is to take the integral over the electronic
coordinates (<span class="math inline">\(d\vec{r}\)</span>) and
rearrange the terms. The expression is simplified by again using the
orthonormality of the electronic wave functions, <span
class="math inline">\(\int \Phi_k^* \Phi_n \, d\vec{r} =
\delta_{kn}\)</span>. 最后一步是对电子坐标 (<span
class="math inline">\(d\vec{r}\)</span>)
进行积分，并重新排列各项。再次利用电子波函数的正交性简化表达式，<span
class="math inline">\(\int \Phi_k^* \Phi_n \, d\vec{r} =
\delta_{kn}\)</span>。</p>
<p><span class="math inline">\(= -\sum_I \frac{\hbar^2}{2M_I} \left(
\nabla_I^2 \Theta_k + \sum_n 2 \left( \int \Phi_k^* \nabla_I \Phi_n \,
d\vec{r} \right) \cdot \nabla_I \Theta_n + \sum_n \left( \int \Phi_k^*
\nabla_I^2 \Phi_n \, d\vec{r} \right) \Theta_n \right) + E_k
\Theta_k\)</span></p>
<p>This final equation is profound. It represents the time-independent
Schrödinger equation for the nuclear wave function <span
class="math inline">\(\Theta_k\)</span>, but it is coupled to all other
nuclear wave functions <span class="math inline">\(\Theta_n\)</span>.
Let’s break down the key terms within the parentheses:
最后一个方程意义深远。它代表了核波函数 <span
class="math inline">\(\Theta_k\)</span>
的与时间无关的薛定谔方程，但它与所有其他核波函数 <span
class="math inline">\(\Theta_n\)</span>
耦合。让我们分解一下括号内的关键项：</p>
<ul>
<li><p><strong><span class="math inline">\(\nabla_I^2
\Theta_k\)</span></strong>: This is the standard kinetic energy term for
the nuclei moving on the potential energy surface of state <span
class="math inline">\(k\)</span>. This is the only term that would
remain in the simple Born-Oppenheimer (adiabatic) approximation.
这是原子核在势能面 <span class="math inline">\(k\)</span>
上运动的标准动能项。这是在简单的
Born-Oppenheimer（绝热）近似中唯一保留的项。</p></li>
<li><p><strong><span class="math inline">\(\left( \int \Phi_k^* \nabla_I
\Phi_n \, d\vec{r} \right)\)</span></strong>: This is the
<strong>first-derivative non-adiabatic coupling term (NACT)</strong>,
often called the derivative coupling. This vector quantity determines
the strength of the coupling between electronic states <span
class="math inline">\(k\)</span> and <span
class="math inline">\(n\)</span> due to the velocity of the nuclei. It
is the primary term responsible for enabling transitions between
different potential energy surfaces. 这是<strong>一阶导数非绝热耦合项
(NACT)</strong>，通常称为导数耦合。该矢量决定了由于原子核速度而导致的电子态
<span class="math inline">\(k\)</span> 和 <span
class="math inline">\(n\)</span>
之间耦合的强度。它是实现不同势能面之间跃迁的主要项。</p></li>
<li><p><strong><span class="math inline">\(\left( \int \Phi_k^*
\nabla_I^2 \Phi_n \, d\vec{r} \right)\)</span></strong>: This is the
<strong>second-derivative non-adiabatic coupling term</strong>, a scalar
quantity. While often smaller than the first-derivative term, it is also
part of the complete description of non-adiabatic effects.
是<strong>二阶导数非绝热耦合项</strong>，一个标量。虽然它通常小于一阶导数项，但它也是非绝热效应完整描述的一部分。</p></li>
</ul>
<p>In summary, this derivation shows mathematically how the motion of
the nuclei (via the <span class="math inline">\(\nabla_I\)</span>
operator) can induce quantum mechanical transitions between different
electronic states (<span class="math inline">\(\Phi_k \leftrightarrow
\Phi_n\)</span>). The strength of these transitions is governed by the
non-adiabatic coupling terms, which depend on how the electronic wave
functions change as the nuclear geometry changes.
总之，该推导从数学上展示了原子核的运动（通过 <span
class="math inline">\(\nabla_I\)</span>
算符）如何诱导不同电子态之间的量子力学跃迁（<span
class="math inline">\(\Phi_k \leftrightarrow
\Phi_n\)</span>）。这些跃迁的强度由非绝热耦合项控制，而非绝热耦合项又取决于电子波函数如何随原子核几何结构的变化而变化。</p>
<p>This whiteboard concludes the derivation of the equations for
non-adiabatic molecular dynamics by defining the coupling operator and
then showing how different levels of approximation—specifically the
Born-Huang and the more restrictive Born-Oppenheimer
approximations—arise from neglecting certain coupling terms.
这块白板通过定义耦合算符，并展示不同程度的近似——特别是 Born-Huang
近似和更严格的 Born-Oppenheimer
近似——是如何通过忽略某些耦合项而产生的，从而推导出非绝热分子动力学方程的。</p>
<h3
id="definition-of-the-non-adiabatic-coupling-operator-非绝热耦合算符的定义">15.
Definition of the Non-Adiabatic Coupling Operator
非绝热耦合算符的定义</h3>
<p>The whiteboard begins by collecting all the non-adiabatic coupling
terms derived previously into a single operator, <span
class="math inline">\(C_{kn}\)</span>.
白板首先将之前推导的所有非绝热耦合项合并为一个算符 <span
class="math inline">\(C_{kn}\)</span>。</p>
<p>Let <span class="math inline">\(C_{kn} = -\sum_{I}
\frac{\hbar^2}{2M_I} \left( 2 \left( \int \Phi_k^* \nabla_I \Phi_n \,
d\vec{r} \right) \cdot \nabla_I + \left( \int \Phi_k^* \nabla_I^2 \Phi_n
\, d\vec{r} \right) \right)\)</span></p>
<ul>
<li>This operator, <span class="math inline">\(C_{kn}\)</span>,
represents the total effect of the coupling between electronic state
<span class="math inline">\(k\)</span> and electronic state <span
class="math inline">\(n\)</span>, which is induced by the kinetic energy
of the nuclei. 此算符 <span class="math inline">\(C_{kn}\)</span>
表示由原子核动能引起的电子态 <span class="math inline">\(k\)</span>
和电子态 <span class="math inline">\(n\)</span> 之间耦合的总效应。</li>
<li>The operator acts on the nuclear wave function that follows it in
the full equation. The <span class="math inline">\(\nabla_I\)</span>
term acts as a derivative on that wave function.
该算符作用于完整方程中跟随它的核波函数。<span
class="math inline">\(\nabla_I\)</span> 项充当该波函数的导数。</li>
</ul>
<h3 id="the-coupled-equations-of-motion-耦合运动方程">16. The Coupled
Equations of Motion 耦合运动方程</h3>
<p>Using this compact definition, the full set of coupled time-dependent
Schrödinger equations for the nuclear wave functions can be written as:
基于此简洁定义，核波函数的完整耦合含时薛定谔方程组可以写成：</p>
<p><span class="math inline">\(i\hbar \frac{\partial}{\partial t}
\Theta_k = \left( -\sum_{I} \frac{\hbar^2}{2M_I}\nabla_I^2 + E_k \right)
\Theta_k + \sum_n C_{kn} \Theta_n\)</span></p>
<p>This is the central result. It shows that the time evolution of the
nuclear wave function on a given potential energy surface <span
class="math inline">\(k\)</span> (described by <span
class="math inline">\(\Theta_k\)</span>) depends on two things:
这是核心结论。它表明，核波函数在给定势能面 <span
class="math inline">\(k\)</span>（用 <span
class="math inline">\(\Theta_k\)</span>
描述）上的时间演化取决于两个因素： 1. The motion on its own surface,
governed by its kinetic energy and the potential <span
class="math inline">\(E_k\)</span>. 其自身表面上的运动，由其动能和势能
<span class="math inline">\(E_k\)</span> 控制。 2. The influence of the
nuclear wave functions on <em>all other</em> electronic surfaces (<span
class="math inline">\(\Theta_n\)</span>), mediated by the coupling
operators <span class="math inline">\(C_{kn}\)</span>.
核波函数对<em>所有其他</em>电子表面（<span
class="math inline">\(\Theta_n\)</span>）的影响，由耦合算符 <span
class="math inline">\(C_{kn}\)</span> 介导。</p>
<h3 id="the-born-huang-approximation-玻恩-黄近似">17. The Born-Huang
Approximation 玻恩-黄近似</h3>
<p>The first and most crucial approximation is introduced to simplify
this complex set of coupled equations.
为了简化这组复杂的耦合方程，引入了第一个也是最重要的近似。</p>
<p><strong>If <span class="math inline">\(C_{kn} = 0\)</span> for <span
class="math inline">\(k \neq n\)</span> (Born-Huang
approximation)</strong></p>
<p>This approximation assumes that the <strong>off-diagonal</strong>
coupling terms, which are responsible for transitions between different
electronic states, are negligible. However, it retains the
<strong>diagonal</strong> coupling term (<span
class="math inline">\(C_{kk}\)</span>). This leads to a simplified,
uncoupled equation:
该近似假设导致不同电子态之间跃迁的<strong>非对角</strong>耦合项可以忽略不计。然而，它保留了<strong>对角</strong>耦合项（<span
class="math inline">\(C_{kk}\)</span>）。这可以得到一个简化的非耦合方程：</p>
<p><span class="math inline">\(i\hbar \frac{\partial}{\partial t}
\Theta_k = \left( -\sum_{I} \frac{\hbar^2}{2M_I}\nabla_I^2 + E_k +
C_{kk} \right) \Theta_k\)</span></p>
<p>Substituting the definition of <span
class="math inline">\(C_{kk}\)</span>: 代入 <span
class="math inline">\(C_{kk}\)</span> 的定义：</p>
<p><span class="math inline">\(i\hbar \frac{\partial}{\partial t}
\Theta_k = \left( -\sum_{I} \frac{\hbar^2}{2M_I}\nabla_I^2 + E_k -
\sum_I \frac{\hbar^2}{2M_I} \left( 2 \left( \int \Phi_k^* \nabla_I
\Phi_k \, d\vec{r} \right) \cdot \nabla_I + \int \Phi_k^* \nabla_I^2
\Phi_k \, d\vec{r} \right) \right) \Theta_k\)</span></p>
<p>The term <span class="math inline">\(C_{kk}\)</span> is known as the
<strong>diagonal Born-Oppenheimer correction (DBOC)</strong>. It
represents a small correction to the potential energy surface <span
class="math inline">\(E_k\)</span> that arises from the fact that the
electrons do not adjust perfectly and instantaneously to the nuclear
motion, even within the same electronic state. <span
class="math inline">\(C_{kk}\)</span>
项被称为<strong>对角玻恩-奥本海默修正 (DBOC)</strong>。它表示对势能面
<span class="math inline">\(E_k\)</span>
的微小修正，其原因是即使在相同的电子态下，电子也无法完美且即时地适应核运动。</p>
<ul>
<li><strong>Note on Real Wavefunctions 关于实波函数的注释</strong>: The
board shows that for real wavefunctions, the first-derivative part of
the diagonal correction vanishes: <span class="math inline">\(\int
\Phi_k \nabla_I \Phi_k \, d\vec{r} = 0\)</span>. This is because the
integral is related to the gradient of the normalization condition,
<span class="math inline">\(\nabla_I \int \Phi_k^2 \, d\vec{r} =
\nabla_I(1) = 0\)</span>, which expands to <span
class="math inline">\(2\int \Phi_k \nabla_I \Phi_k \, d\vec{r} =
0\)</span>. 黑板显示，对于实波函数，对角修正的一阶导数部分为零：<span
class="math inline">\(\int \Phi_k \nabla_I \Phi_k \, d\vec{r} =
0\)</span>。这是因为积分与归一化条件的梯度有关，<span
class="math inline">\(\nabla_I \int \Phi_k^2 \, d\vec{r} = \nabla_I(1) =
0\)</span>，其展开为 <span class="math inline">\(2\int \Phi_k \nabla_I
\Phi_k \, d\vec{r} = 0\)</span>。</li>
</ul>
<h3 id="the-born-oppenheimer-approximation-玻恩-奥本海默近似">18. The
Born-Oppenheimer Approximation 玻恩-奥本海默近似</h3>
<p>The final and most widely used approximation is the Born-Oppenheimer
approximation. It is more restrictive than the Born-Huang approximation.
最后一种也是最广泛使用的近似方法是玻恩-奥本海默近似。它比玻恩-黄近似更具限制性。</p>
<p><strong>If <span class="math inline">\(C_{kk} = 0\)</span>
(Born-Oppenheimer approximation) 若<span class="math inline">\(C_{kk} =
0\)</span>（玻恩-奥本海默近似）</strong></p>
<p>This assumes that the diagonal correction term is also negligible. By
setting all <span class="math inline">\(C_{kn}=0\)</span> (both diagonal
and off-diagonal), the equations become completely decoupled, and the
nuclear motion evolves independently on each potential energy surface.
这假设对角修正项也可忽略不计。通过令所有<span
class="math inline">\(C_{kn}=0\)</span>（包括对角和非对角），方程组完全解耦，原子核运动在每个势能面上独立演化。</p>
<p>The result is the standard <strong>time-dependent Schrödinger
equation for the nuclei</strong>:
由此可得标准的<strong>原子核的含时薛定谔方程</strong>：</p>
<p><span class="math inline">\(i\hbar \frac{\partial}{\partial t}
\Theta_k = \left( -\sum_{I} \frac{\hbar^2}{2M_I}\nabla_I^2 + E_k \right)
\Theta_k\)</span></p>
<p>This equation is the foundation of most of quantum chemistry. It
states that the nuclei move on a static potential energy surface <span
class="math inline">\(E_k(\vec{R})\)</span> provided by the electrons,
without any possibility of transitioning to other electronic states or
having the surface be corrected by their own motion.</p>
<p>该方程是大多数量子化学的基础。原子核在由电子提供的静态势能面 <span
class="math inline">\(E_k(\vec{R})\)</span>
上运动，不存在跃迁到其他电子态或因自身运动而修正势能面的可能性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/18/img_assert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/18/img_assert/" class="post-title-link" itemprop="url">BLOGS - IMG Assert</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-18 10:00:00" itemprop="dateCreated datePublished" datetime="2025-09-18T10:00:00+08:00">2025-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:51" itemprop="dateModified" datetime="2025-09-19T19:24:51+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题主要为了图像不显示问题">【问题】主要为了图像不显示问题</h2>
<h3 id="step1根目录中的配置文件">Step1:根目录中的配置文件</h3>
<h3 id="step2将-markdown-行替换为html-代码">Step2:将 Markdown
行替换为HTML 代码</h3>
<h3 id="step3设置下方添加root">Step3:设置下方添加ROOT</h3>
<h3
id="step4不需要此插件终端中运行以下命令来卸载插件">Step4:不需要此插件终端中运行以下命令来卸载插件：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">$ url: https://TianyaoBlogs.github.io/</span><br><span class="line"></span><br><span class="line">$ root: /</span><br><span class="line"></span><br><span class="line">$ permalink: :year/:month/:day/:title/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;img src=<span class="string">&quot;/imgs/5054C3/General_linear_regression_model.png&quot;</span> alt=<span class="string">&quot;A diagram of the general linear regression model&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-asset-image</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/17/5120C3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/17/5120C3/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W3-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-17 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-17T21:00:00+08:00">2025-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 20:28:09" itemprop="dateModified" datetime="2025-09-19T20:28:09+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="radial-distribution-function">1 radial distribution
function:</h2>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This whiteboard explains the process of calculating the
<strong>radial distribution function</strong>, often denoted as <span
class="math inline">\(g(r)\)</span>, to analyze the atomic structure of
a material, which is referred to here as a “film”.
本白板解释了计算<strong>径向分布函数</strong>（通常表示为 <span
class="math inline">\(g(r)\)</span>）的过程，用于分析材料（本文中称为“薄膜”）的原子结构。</p>
<p>In simple terms, the radial distribution function tells you the
probability of finding an atom at a certain distance from another
reference atom. It’s a powerful way to see the local structure in a
disordered system like a liquid or an amorphous solid.</p>
<p>简单来说，径向分布函数表示在距离另一个参考原子一定距离处找到一个原子的概率。它是观察无序系统（例如液体或非晶态固体）局部结构的有效方法。</p>
<h3 id="core-concept-radial-distribution-function-径向分布函数">## Core
Concept: Radial Distribution Function 径向分布函数</h3>
<p>The main goal is to compute the radial distribution function, <span
class="math inline">\(g(r)\)</span>, which is defined as the ratio of
the actual number of atoms found in a thin shell at a distance <span
class="math inline">\(r\)</span> to the number of atoms you’d expect to
find if the material were an ideal gas (completely random).
主要目标是计算径向分布函数 <span
class="math inline">\(g(r)\)</span>，其定义为在距离 <span
class="math inline">\(r\)</span>
的薄壳层中实际发现的原子数与材料为理想气体（完全随机）时预期发现的原子数之比。</p>
<p>The formula is expressed as: <span class="math display">\[g(r)dr =
\frac{n(r)}{\text{ideal gas}}\]</span></p>
<ul>
<li><strong><span class="math inline">\(n(r)\)</span></strong>:
Represents the average number of atoms found in a thin spherical shell
between a distance <span class="math inline">\(r\)</span> and <span
class="math inline">\(r+dr\)</span> from a central atom.
表示距离中心原子 <span class="math inline">\(r\)</span> 到 <span
class="math inline">\(r+dr\)</span> 之间的薄球壳中原子的平均数量。</li>
<li><strong>ideal gas</strong>: Represents the number of atoms you would
expect in that same shell if the atoms were distributed completely
randomly with the same average density (<span
class="math inline">\(\rho\)</span>). The volume of this shell is
approximately <span class="math inline">\(4\pi r^2
dr\)</span>.表示如果原子完全随机分布且平均密度 (<span
class="math inline">\(\rho\)</span>)
相同，则该球壳中原子的数量。该球壳的体积约为 <span
class="math inline">\(4\pi r^2 dr\)</span>。</li>
</ul>
<p>A peak in the <span class="math inline">\(g(r)\)</span> plot
indicates a high probability of finding neighboring atoms at that
specific distance, revealing the material’s structural shells (e.g.,
nearest neighbors, second-nearest neighbors, etc.).<span
class="math inline">\(g(r)\)</span>
图中的峰值表示在该特定距离处找到相邻原子的概率很高，从而揭示了材料的结构壳（例如，最近邻、次近邻等）。</p>
<h3 id="calculation-method">## Calculation Method</h3>
<p>The board outlines a two-step averaging process to get a
statistically meaningful result from simulation data (a “film” at 20
frames per second).</p>
<ol type="1">
<li><p><strong>Average over atoms:</strong> In a single frame (a
snapshot in time), you pick one atom as the center. Then, you count how
many other atoms (<span class="math inline">\(n(r)\)</span>) are in
concentric spherical shells around it. This process is repeated,
treating each atom in the frame as the center, and the results are
averaged.</p></li>
<li><p><strong>Average over frames:</strong> The entire process
described above is repeated for multiple frames from the simulation or
video. This time-averaging ensures that the final result represents the
typical structure of the material over time, smoothing out random
fluctuations.</p></li>
</ol>
<p>The board notes “dx = bin width 0.01Å”, which is a practical detail
for the calculation. To create a histogram, the distance <code>r</code>
is divided into small segments (bins) of 0.01 angstroms.</p>
<h3 id="connection-to-experiments">## Connection to Experiments</h3>
<p>Finally, the whiteboard mentions <strong>“frame X-ray
scattering”</strong>. This is a crucial point because it connects this
computational analysis to real-world experiments. Experimental
techniques like X-ray or neutron scattering can be used to measure a
quantity called the structure factor, <span
class="math inline">\(S(q)\)</span>, which is directly related to the
radial distribution function <span class="math inline">\(g(r)\)</span>
through a mathematical operation called a Fourier transform. This allows
scientists to directly compare the structure produced in their
simulations with the structure of a real material measured in a lab.
最后，白板上提到了<strong>“帧 X
射线散射”</strong>。这一点至关重要，因为它将计算分析与实际实验联系起来。X射线或中子散射等实验技术可以用来测量一个称为结构因子<span
class="math inline">\(S(q)\)</span>的量，该量通过傅里叶变换的数学运算与径向分布函数<span
class="math inline">\(g(r)\)</span>直接相关。这使得科学家能够直接将模拟中产生的结构与实验室测量的真实材料结构进行比较。</p>
<p>The board correctly links <span class="math inline">\(g(r)\)</span>
to X-ray scattering experiments. The quantity measured in these
experiments is the <strong>static structure factor</strong>, <span
class="math inline">\(S(q)\)</span>, which describes how the material
scatters radiation. The relationship between the two is a Fourier
transform: 该板正确地将<span
class="math inline">\(g(r)\)</span>与X射线散射实验联系起来。这些实验中测量的量是<strong>静态结构因子</strong><span
class="math inline">\(S(q)\)</span>，它描述了材料如何散射辐射。两者之间的关系是傅里叶变换：
<span class="math display">\[S(q) = 1 + 4 \pi \rho \int_0^\infty [g(r) -
1] r^2 \frac{\sin(qr)}{qr} dr\]</span> This equation is crucial because
it bridges the gap between computer simulations (which calculate <span
class="math inline">\(g(r)\)</span>) and physical experiments (which
measure <span class="math inline">\(S(q)\)</span>).
这个方程至关重要，因为它弥合了计算机模拟（计算 <span
class="math inline">\(g(r)\)</span>）和物理实验（测量 <span
class="math inline">\(S(q)\)</span>）之间的差距。</p>
<h3
id="the-gaussian-distribution-probability-of-particle-position-高斯分布粒子位置的概率">##
2. The Gaussian Distribution: Probability of Particle Position
高斯分布：粒子位置的概率</h3>
<p>The board starts with the formula for a one-dimensional
<strong>Gaussian (or normal) distribution</strong>:
白板首先展示的是一维<strong>高斯（或正态）分布</strong>的公式：</p>
<p><span class="math display">\[f(x | \mu, \sigma^2) =
\frac{1}{\sqrt{2\pi\sigma^2}}
\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\]</span></p>
<p>This equation describes the probability of finding a particle at a
specific position <code>x</code> after a certain amount of time has
passed. * <strong><span class="math inline">\(\mu\)</span> (mu)</strong>
is the <strong>mean</strong> or average position. For a simple diffusion
process starting at the origin, the particles spread out symmetrically,
so the average position remains at the origin (<span
class="math inline">\(\mu = 0\)</span>). * <strong><span
class="math inline">\(\sigma^2\)</span> (sigma squared)</strong> is the
<strong>variance</strong>, which measures how spread out the particles
are from the mean position. A larger variance means the particles have,
on average, traveled farther from the starting point.
这个方程描述了经过一定时间后，在特定位置“x”找到粒子的概率。 *
<strong><span class="math inline">\(\mu\)</span> (mu)</strong>
是<strong>平均值</strong>或平均位置。对于从原点开始的简单扩散过程，粒子对称扩散，因此平均位置保持在原点（<span
class="math inline">\(\mu = 0\)</span>）。 * <strong><span
class="math inline">\(\sigma^2\)</span>（sigma 平方）</strong>
是<strong>方差</strong>，用​​于衡量粒子与平均位置的扩散程度。方差越大，意味着粒子平均距离起点越远。</p>
<p>The note “Black-Scholes” is a side reference. The Black-Scholes
model, famous in financial mathematics for pricing options, uses similar
mathematical principles based on Brownian motion to model the random
fluctuations of stock prices. “Black-Scholes”注释仅供参考。Black-Scholes
模型在金融数学中以期权定价而闻名，它使用基于布朗运动的类似数学原理来模拟股票价格的随机波动。</p>
<h3
id="mean-squared-displacement-msd-quantifying-the-spread-均方位移-msd量化扩散">##
3. Mean Squared Displacement (MSD): Quantifying the Spread 均方位移
(MSD)：量化扩散</h3>
<p>The core of the board is dedicated to the <strong>Mean Squared
Displacement (MSD)</strong>. This is the primary tool used to measure
how far, on average, particles have moved over a time interval
<code>t</code>. 本版块的核心内容是<strong>均方位移
(MSD)</strong>。这是用于测量粒子在时间间隔“t”内平均移动距离的主要工具。</p>
<p>The variance <span class="math inline">\(\sigma^2\)</span> is
formally defined as the average of the squared deviations from the mean:
<span class="math display">\[\sigma^2 = \langle x^2(t) \rangle - \langle
x(t) \rangle^2\]</span> * <span class="math inline">\(\langle x(t)
\rangle\)</span> is the average displacement. As mentioned, for simple
diffusion, <span class="math inline">\(\langle x(t) \rangle =
0\)</span>. * <span class="math inline">\(\langle x^2(t)
\rangle\)</span> is the average of the <em>square</em> of the
displacement. 方差<span
class="math inline">\(\sigma^2\)</span>的正式定义为与平均值偏差平方的平均值：
<span class="math display">\[\sigma^2 = \langle x^2(t) \rangle - \langle
x(t) \rangle^2\]</span> * <span class="math inline">\(\langle x(t)
\rangle\)</span>是平均位移。如上所述，对于简单扩散，<span
class="math inline">\(\langle x(t) \rangle = 0\)</span>。 * <span
class="math inline">\(\langle x^2(t)
\rangle\)</span>是位移<em>平方</em>的平均值。</p>
<p>Since <span class="math inline">\(\langle x(t) \rangle = 0\)</span>,
the variance is simply equal to the MSD: <span
class="math display">\[\sigma^2 = \langle x^2(t) \rangle\]</span> 由于
<span class="math inline">\(\langle x(t) \rangle =
0\)</span>，方差等于均方差 (MSD)： <span class="math display">\[\sigma^2
= \langle x^2(t) \rangle\]</span></p>
<p>The crucial insight for a diffusive process is that the <strong>MSD
grows linearly with time</strong>. The rate of this growth is determined
by the <strong>diffusion coefficient, D</strong>. The board shows this
relationship for different dimensions: 扩散过程的关键在于<strong>MSD
随时间线性增长</strong>。其增长率由<strong>扩散系数
D</strong>决定。棋盘显示了不同维度下的这种关系：</p>
<ul>
<li><strong>1D:</strong> <span class="math inline">\(\langle x^2(t)
\rangle = 2Dt\)</span> (Movement along a line) （沿直线运动）</li>
<li><strong>2D:</strong> The board has a slight typo or ambiguity with
<span class="math inline">\(\langle z^2(t) \rangle = 2Dt\)</span>. For
2D motion in the x-y plane, the total MSD would be <span
class="math inline">\(\langle r^2(t) \rangle = \langle x^2(t) \rangle +
\langle y^2(t) \rangle = 4Dt\)</span>. The note on the board might be
referring to just one component of motion. **棋盘上的 <span
class="math inline">\(\langle z^2(t) \rangle = 2Dt\)</span>
存在轻微拼写错误或歧义。对于 x-y 平面上的二维运动，总平均散射差 (MSD) 为
<span class="math inline">\(\langle r^2(t) \rangle = \langle x^2(t)
\rangle + \langle y^2(t) \rangle =
4Dt\)</span>。黑板上的注释可能仅指运动的一个分量。</li>
<li><strong>3D:</strong> <span class="math inline">\(\langle r^2(t)
\rangle = \langle |\vec{r}(t) - \vec{r}(0)|^2 \rangle = 6Dt\)</span>
(Movement in 3D space, which is the most common case in molecular
simulations) （三维空间中的运动，这是分子模拟中最常见的情况） Here,
<span class="math inline">\(\vec{r}(t)\)</span> is the position vector
of a particle at time <code>t</code>. The quantity <span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span> is the average of the squared distance a particle has
traveled from its initial position <span
class="math inline">\(\vec{r}(0)\)</span>. 这里，<span
class="math inline">\(\vec{r}(t)\)</span> 是粒子在时间 <code>t</code>
的位置矢量。 <span class="math inline">\(\langle |\vec{r}(t) -
\vec{r}(0)|^2 \rangle\)</span> 是粒子从其初始位置 <span
class="math inline">\(\vec{r}(0)\)</span> 行进距离的平方平均值。</li>
</ul>
<h3
id="the-einstein-relation-connecting-microscopic-motion-to-a-macroscopic-property-爱因斯坦关系将微观运动与宏观特性联系起来">##
4. The Einstein Relation: Connecting Microscopic Motion to a Macroscopic
Property 爱因斯坦关系：将微观运动与宏观特性联系起来</h3>
<p>Finally, the board presents the famous <strong>Einstein
relation</strong>, which rearranges the 3D MSD equation to solve for the
diffusion coefficient <code>D</code>:</p>
<p><span class="math display">\[D = \lim_{t \to \infty} \frac{\langle
|\vec{r}(t) - \vec{r}(0)|^2 \rangle}{6t}\]</span></p>
<p>This is a cornerstone equation in statistical mechanics. It provides
a practical way to calculate a macroscopic property—the
<strong>diffusion coefficient <code>D</code></strong>—from the
microscopic movements of individual particles observed in a computer
simulation.
这是统计力学中的一个基石方程。它提供了一种实用的方法，可以通过计算机模拟中观察到的单个粒子的微观运动来计算宏观属性——扩散系数“D”。</p>
<p>In practice, one would: 1. Run a simulation of particles.
运行粒子模拟。 2. Track the position of each particle over time.
跟踪每个粒子随时间的位置。 3. Calculate the squared displacement <span
class="math inline">\(|\vec{r}(t) - \vec{r}(0)|^2\)</span> for each
particle at various time intervals <code>t</code>.
计算每个粒子在不同时间间隔“t”的位移平方<span
class="math inline">\(|\vec{r}(t) - \vec{r}(0)|^2\)</span>。 4. Average
this value over all particles to get the MSD, <span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span>. 对所有粒子取平均值，得到均方差（MSD），即<span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span>。 5. Plot the MSD as a function of time.
将MSD绘制成时间函数。 6. The slope of this line, divided by 6, gives the
diffusion coefficient <code>D</code>. The <code>lim t→∞</code> indicates
that this linear relationship is most accurate for long time scales,
after initial transient effects have died down.
这条直线的斜率除以6，即扩散系数“D”。“lim
t→∞”表明，在初始瞬态效应消退后，这种线性关系在长时间尺度上最为准确。</p>
<h3 id="right-board-green-kubo-relations">## 5. Right Board: Green-Kubo
Relations</h3>
<p>This board introduces a more advanced and powerful method to
calculate transport coefficients like the diffusion coefficient, known
as the <strong>Green-Kubo relations</strong>.
本面板介绍了一种更先进、更强大的方法来计算扩散系数等传输系数，即<strong>Green-Kubo
关系</strong>。</p>
<h4 id="velocity-autocorrelation-function-vacf-速度自相关函数-vacf">###
<strong>Velocity Autocorrelation Function (VACF)</strong> 速度自相关函数
(VACF)</h4>
<p>The key idea is to look at how a particle’s velocity at one point in
time is related to its velocity at a later time. This is measured by the
<strong>Velocity Autocorrelation Function (VACF)</strong>: <span
class="math display">\[C_{vv}(t) = \langle \vec{v}(t&#39;) \cdot
\vec{v}(t&#39; + t) \rangle\]</span> This function tells us how long a
particle “remembers” its velocity. For a typical liquid, the velocity is
quickly randomized by collisions, so the VACF decays to zero rapidly.
其核心思想是考察粒子在某一时间点的速度与其在之后时间点的速度之间的关系。这可以通过<strong>速度自相关函数
(VACF)</strong>来测量： <span class="math display">\[C_{vv}(t) = \langle
\vec{v}(t&#39;) \cdot \vec{v}(t&#39; + t) \rangle\]</span>
此函数告诉我们粒子“记住”其速度的时间。对于典型的液体，速度会因碰撞而迅速随机化，因此
VACF 会迅速衰减为零。</p>
<h4 id="connecting-msd-and-vacf">### <strong>Connecting MSD and
VACF</strong></h4>
<p>The board shows the mathematical link between the MSD and the VACF.
Starting with the definition of position as the integral of velocity,
<span class="math inline">\(\vec{r}(t) = \int_0^t \vec{v}(t&#39;)
dt&#39;\)</span>, one can show that the MSD is a double integral of the
VACF. The board writes this as: <span class="math display">\[\langle
x^2(t) \rangle = \left\langle \left( \int_0^t v(t&#39;) dt&#39; \right)
\left( \int_0^t v(t&#39;&#39;) dt&#39;&#39; \right) \right\rangle =
\int_0^t dt&#39; \int_0^t dt&#39;&#39; \langle v(t&#39;) v(t&#39;&#39;)
\rangle\]</span> This shows that the two pictures of motion—the
particle’s displacement (MSD) and its velocity fluctuations (VACF)—are
deeply connected. 该面板展示了 MSD 和 VACF
之间的数学联系。从位置定义为速度的积分开始，<span
class="math inline">\(\vec{r}(t) = \int_0^t \vec{v}(t&#39;)
dt&#39;\)</span>，可以证明 MSD 是 VACF 的二重积分。黑板上写着： <span
class="math display">\[\langle x^2(t) \rangle = \left\langle \left(
\int_0^t v(t&#39;) dt&#39; \right) \left( \int_0^t v(t&#39;&#39;)
dt&#39;&#39; \right) \right\rangle = \int_0^t dt&#39; \int_0^t
dt&#39;&#39; \langle v(t&#39;) v(t&#39;&#39;) \rangle\]</span>
这表明，粒子运动的两幅图像——粒子的位移（MSD）和速度涨落（VACF）——之间存在着深刻的联系。</p>
<h4 id="the-green-kubo-formula-for-diffusion-扩散的格林-久保公式">###
<strong>The Green-Kubo Formula for Diffusion
扩散的格林-久保公式</strong></h4>
<p>By combining the Einstein relation with the integral of the VACF, one
arrives at the Green-Kubo formula for the diffusion coefficient: <span
class="math display">\[D = \frac{1}{3} \int_0^\infty \langle \vec{v}(0)
\cdot \vec{v}(t) \rangle dt\]</span> This incredible result states that
the <strong>macroscopic</strong> property of diffusion (<span
class="math inline">\(D\)</span>) is determined by the integral of the
<strong>microscopic</strong> velocity correlations. It’s often a more
efficient way to compute <span class="math inline">\(D\)</span> in
simulations than calculating the long-time limit of the MSD.
将爱因斯坦关系与VACF积分相结合，可以得到扩散系数的格林-久保公式： <span
class="math display">\[D = \frac{1}{3} \int_0^\infty \langle \vec{v}(0)
\cdot \vec{v}(t) \rangle dt\]</span>
这个令人难以置信的结果表明，扩散的<strong>宏观</strong>特性（<span
class="math inline">\(D\)</span>）由<strong>微观</strong>速度关联的积分决定。在模拟中，这通常是计算<span
class="math inline">\(D\)</span>比计算MSD的长期极限更有效的方法。</p>
<h3 id="the-grand-narrative-from-micro-to-macro-宏大叙事从微观到宏观">##
6. The Grand Narrative: From Micro to Macro 宏大叙事：从微观到宏观</h3>
<p>The previous whiteboards gave us two ways to calculate the
<strong>diffusion constant, D</strong>, from the microscopic random walk
of individual atoms:
之前的白板提供了两种从单个原子的微观随机游动计算<strong>扩散常数
D</strong>的方法： 1. <strong>Einstein Relation:</strong> From the
long-term slope of the Mean Squared Displacement (MSD). 根据均方位移
(MSD) 的长期斜率。 2. <strong>Green-Kubo Relation:</strong> From the
integral of the Velocity Autocorrelation Function (VACF).
根据速度自相关函数 (VACF) 的积分。</p>
<p>This new whiteboard shows how that single microscopic parameter,
<code>D</code>, governs the large-scale, observable process of diffusion
described by <strong>Fick’s Laws</strong> and the <strong>Diffusion
Equation</strong>. 这块新的白板展示了单个微观参数 <code>D</code>
如何控制<strong>菲克定律</strong>和<strong>扩散方程</strong>所描述的大规模可观测扩散过程。</p>
<h3 id="the-starting-point-a-liquids-structure-起点液体的结构">## 1. The
Starting Point: A Liquid’s Structure 起点：液体的结构</h3>
<p>The plot on the top left is the <strong>Radial Distribution Function,
<span class="math inline">\(g(r)\)</span></strong>, which we discussed
in detail from the first whiteboard. 左上角的图是<strong>径向分布函数
<span
class="math inline">\(g(r)\)</span></strong>，我们在第一个白板上详细讨论过它。</p>
<ul>
<li><strong>The Plot:</strong> It shows the characteristic structure of
a liquid. The peaks are labeled “1st”, “2nd”, and “3rd”, corresponding
to the first, second, and third <strong>solvation shells</strong>
(layers of neighboring atoms).
它显示了液体的特征结构。峰分别标记为“第一”、“第二”和“第三”，分别对应于第一、第二和第三<strong>溶剂化壳层</strong>（相邻原子层）。</li>
<li><strong>The Limit:</strong> The note <code>lim r→∞ g(r) = 1</code>
confirms that at large distances, the liquid has no long-range order, as
expected.注释“lim r→∞ g(r) =
1”证实了在远距离下，液体没有长程有序，这与预期一致。</li>
<li><strong>System Parameters:</strong> The values <code>T = 0.71</code>
and <code>ρ = 0.844</code> are the temperature and density of the
simulated system (likely in reduced or “Lennard-Jones” units) for which
this <span class="math inline">\(g(r)\)</span> was calculated. 值“T =
0.71”和“ρ =
0.844”分别是模拟系统的温度和密度（可能采用约化或“Lennard-Jones”单位），用于计算此
<span class="math inline">\(g(r)\)</span>。</li>
</ul>
<p>This section sets the stage: we are looking at the dynamics within a
system that has this specific liquid-like structure.
本节奠定了基础：我们将研究具有特定类液体结构的系统内的动力学。</p>
<h3 id="the-macroscopic-laws-of-diffusion-宏观扩散定律">## 2. The
Macroscopic Laws of Diffusion 宏观扩散定律</h3>
<p>The bottom-left and top-right sections introduce the continuum
equations that describe how concentration changes in space and time.
左下角和右上角部分介绍了描述浓度随空间和时间变化的连续方程。左下角和右上角部分介绍了描述浓度随空间和时间变化的连续方程。</p>
<h4 id="ficks-first-law-菲克第一定律">### <strong>Fick’s First Law
菲克第一定律</strong></h4>
<p><span class="math display">\[\vec{J} = -D \nabla C\]</span> This is
Fick’s first law of diffusion. It states that there is a
<strong>flux</strong> of particles (<span
class="math inline">\(\vec{J}\)</span>), meaning a net flow. This flow
is directed from high concentration to low concentration (hence the
minus sign) and its magnitude is proportional to the
<strong>concentration gradient</strong> (<span
class="math inline">\(\nabla C\)</span>).
这是菲克第一扩散定律。它指出存在粒子的<strong>通量</strong> (<span
class="math inline">\(\vec{J}\)</span>)，即净流量。该流量从高浓度流向低浓度（因此带有负号），其大小与<strong>浓度梯度</strong>
(<span class="math inline">\(\nabla C\)</span>) 成正比。</p>
<p><strong>The Crucial Link:</strong> The proportionality constant is
<strong>D</strong>, the very same <strong>diffusion constant</strong> we
calculated from the microscopic random walk (MSD/VACF). This is the key
connection: the collective result of countless individual random walks
is a predictable net flow of particles.
比例常数是<strong>D</strong>，与我们根据微观随机游走 (MSD/VACF)
计算出的<strong>扩散常数</strong>完全相同。这是关键的联系：无数个体随机游动的集合结果是可预测的粒子净流。</p>
<h4
id="the-diffusion-equation-ficks-second-law-扩散方程菲克第二定律">###
<strong>The Diffusion Equation (Fick’s Second Law)
扩散方程（菲克第二定律）</strong></h4>
<p><span class="math display">\[\frac{\partial C(\vec{r},t)}{\partial t}
= D \nabla^2 C(\vec{r},t)\]</span> This is the <strong>diffusion
equation</strong>, one of the most important equations in physics and
chemistry (also called the heat equation, as noted). It’s derived from
Fick’s first law and the principle of mass conservation (<span
class="math inline">\(\frac{\partial C}{\partial t} + \nabla \cdot
\vec{J} = 0\)</span>). It’s a differential equation that tells you
exactly how the concentration at any point, <span
class="math inline">\(C(\vec{r},t)\)</span>, will change over time.
这就是<strong>扩散方程</strong>，它是物理学和化学中最重要的方程之一（也称为热方程）。它源于菲克第一定律和质量守恒定律（<span
class="math inline">\(\frac{\partial C}{\partial t} + \nabla \cdot
\vec{J} = 0\)</span>）。它是一个微分方程，可以精确地告诉你任意一点的浓度
<span class="math inline">\(C(\vec{r},t)\)</span> 随时间的变化。</p>
<h3
id="the-solution-connecting-back-to-the-random-walk-与随机游动联系起来">##
3. The Solution: Connecting Back to the Random Walk
与随机游动联系起来</h3>
<p>This is the most beautiful part. The board shows the solution to the
diffusion equation for a very specific scenario, linking the macroscopic
equation directly back to the microscopic random walk.
黑板上展示了一个非常具体场景下扩散方程的解，将宏观方程直接与微观随机游动联系起来。</p>
<h4 id="the-initial-condition-初始条件">### <strong>The Initial
Condition 初始条件</strong></h4>
<p>The problem is set up by assuming all particles start at a single
point at time zero: <span class="math display">\[C(\vec{r}, 0) =
\delta(\vec{r})\]</span> This is a <strong>Dirac delta
function</strong>, representing an infinitely concentrated point source
at the origin. 问题假设所有粒子在时间零点处从一个点开始： <span
class="math display">\[C(\vec{r}, 0) = \delta(\vec{r})\]</span>
这是一个<strong>狄拉克函数</strong>，表示一个在原点处无限集中的点源。</p>
<h4 id="the-fundamental-solution-greens-function-基本解格林函数">###
<strong>The Fundamental Solution (Green’s Function)
基本解（格林函数）</strong></h4>
<p>The solution to the diffusion equation with this starting condition
is called the <strong>fundamental solution</strong> or <strong>Green’s
function</strong>. For one dimension, it is: <span
class="math display">\[C(x,t) = \frac{1}{\sqrt{4\pi Dt}}
\exp\left(-\frac{x^2}{4Dt}\right)\]</span></p>
<p><strong>The “Aha!” Moment:</strong> This is a <strong>Gaussian
distribution</strong>. Let’s compare it to the formula from the second
whiteboard: * The mean is <span class="math inline">\(\mu=0\)</span>.
均值为 <span class="math inline">\(\mu=0\)</span>。 * The variance is
<span class="math inline">\(\sigma^2 = 2Dt\)</span>. 方差为 <span
class="math inline">\(\sigma^2 = 2Dt\)</span>。</p>
<p>This is an incredible result. The macroscopic diffusion equation
predicts that a concentration pulse will spread out over time, and the
shape of the concentration profile will be a Gaussian curve. The width
of this curve, measured by its variance <span
class="math inline">\(\sigma^2\)</span>, is <strong>exactly the Mean
Squared Displacement, <span class="math inline">\(\langle x^2(t)
\rangle\)</span>, of the individual random-walking particles.</strong>
宏观扩散方程预测浓度脉冲会随时间扩散，浓度分布的形状将是高斯曲线。这条曲线的宽度，用其方差
<span class="math inline">\(\sigma^2\)</span>
来衡量，<strong>恰好是单个随机游动粒子的均方位移 <span
class="math inline">\(\langle x^2(t) \rangle\)</span>。</strong></p>
<p>This perfectly unites the two perspectives: * <strong>Microscopic微观
(Board 2):</strong> Particles undergo a random walk, and their average
squared displacement from the origin grows as <span
class="math inline">\(\langle x^2(t) \rangle = 2Dt\)</span>.
粒子进行随机游动，它们相对于原点的平均平方位移随着 <span
class="math inline">\(\langle x^2(t) \rangle = 2Dt\)</span>
的增长而增长。 * <strong>Macroscopic宏观 (This Board):</strong> A
collection of these particles, described by a continuum concentration
<code>C</code>, spreads out in a Gaussian profile whose variance is
<span class="math inline">\(\sigma^2 = 2Dt\)</span>.
这些粒子的集合，用连续浓度“C”来描述，呈方差为 <span
class="math inline">\(\sigma^2 = 2Dt\)</span> 的高斯分布。</p>
<p>The two pictures are mathematically identical.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/17/5120C3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/17/5120C3-2/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W3-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-17 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-17T21:00:00+08:00">2025-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-21 05:21:00" itemprop="dateModified" datetime="2025-09-21T05:21:00+08:00">2025-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="radial-distribution-function-rdf静态结构">1 radial distribution
function RDF静态结构:</h2>
<ul>
<li><strong>内容</strong>: This whiteboard serves as an excellent
summary, pulling together all the key concepts we’ve discussed into a
single, cohesive picture. Let’s connect everything on this slide to our
detailed conversation.</li>
</ul>
<h3 id="rdf-the-static-structure-rdf静态结构">1. RDF: The Static
Structure RDF静态结构</h3>
<p>On the top left, you see <strong>RDF (Radial Distribution
Function)</strong>.</p>
<ul>
<li><strong>The Plots:</strong> The board shows the familiar <span
class="math inline">\(g(r)\)</span> plot with its characteristic peaks
for a liquid. Below it is a plot of the interatomic potential energy,
<span class="math inline">\(V(r)\)</span>. This addition is very
insightful! It shows <em>why</em> the first peak in <span
class="math inline">\(g(r)\)</span> exists: it corresponds to the
minimum energy distance (<span class="math inline">\(\sigma\)</span>)
where particles are most stable and likely to be found.
白板展示了我们熟悉的<span
class="math inline">\(g(r)\)</span>图，它带有液体的特征峰。下方是原子间势能<span
class="math inline">\(V(r)\)</span>的图。这个补充非常有见地！它解释了为什么
<span class="math inline">\(g(r)\)</span>
中的第一个峰值存在：它对应于粒子最稳定且最有可能被发现的最小能量距离
(<span class="math inline">\(\sigma\)</span>)。</li>
<li><strong>Connection:</strong> This section summarizes our first
discussion. It’s the starting point for our analysis—a static snapshot
of the material’s average atomic arrangement before we consider how the
atoms move.
本节总结了我们的第一个讨论。这是我们分析的起点——在我们考虑原子如何运动之前，它是材料平均原子排列的静态快照。</li>
</ul>
<h3
id="msd-and-the-einstein-relation-the-displacement-picture-均方位移-msd-和爱因斯坦关系位移图像">2.
MSD and The Einstein Relation: The Displacement Picture 均方位移 (MSD)
和爱因斯坦关系：位移图像</h3>
<p>The board then moves to dynamics, presenting two methods to calculate
the <strong>diffusion constant, D</strong>. The first is the
<strong>Einstein relation</strong>. 两种计算<strong>扩散常数
D</strong>的方法。第一种是<strong>爱因斯坦关系</strong>。</p>
<ul>
<li><strong>The Formula:</strong> It correctly states that the Mean
Squared Displacement (MSD), <span class="math inline">\(\langle r^2
\rangle\)</span>, is equal to <span class="math inline">\(6Dt\)</span>
in three dimensions. It then rearranges this to solve for <span
class="math inline">\(D\)</span>: 它正确地指出了均方位移 (MSD)，<span
class="math inline">\(\langle r^2 \rangle\)</span>，在三维空间中等于
<span class="math inline">\(6Dt\)</span>。然后重新排列该公式以求解 <span
class="math inline">\(D\)</span>： <span class="math display">\[D =
\lim_{t\to\infty} \frac{\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle}{6t}\]</span></li>
<li><strong>The Diagram:</strong> The central diagram beautifully
illustrates the concept. It shows a particle in a simulation box (with
“N=108” likely being the number of particles simulated) moving from an
initial position <span class="math inline">\(\vec{r}_i(0)\)</span> to a
final position <span class="math inline">\(\vec{r}_i(t_j)\)</span>. The
MSD is the average of the square of this displacement over all particles
and many time origins. The graph labeled “MSD” shows how you would plot
this data and find the slope (“fitting”) to calculate <span
class="math inline">\(D\)</span>.
中间的图表完美地阐释了这个概念。它展示了一个粒子在模拟框中（“N=108”
可能是模拟粒子的数量）从初始位置 <span
class="math inline">\(\vec{r}_i(0)\)</span> 移动到最终位置 <span
class="math inline">\(\vec{r}_i(t_j)\)</span>。MSD
是该位移平方在所有粒子和多个时间原点上的平均值。标有“MSD”的图表显示了如何绘制这些数据并找到斜率（“拟合”）来计算
<span class="math inline">\(D\)</span>。</li>
<li><strong>Connection:</strong> This is a perfect summary of the
“Displacement Picture” we analyzed on the second whiteboard. It’s the
most intuitive way to think about diffusion: how far particles spread
out over
time.这完美地总结了我们在第二个白板上分析的“位移图”。这是思考扩散最直观的方式：粒子随时间扩散的距离。</li>
</ul>
<h3
id="the-green-kubo-relation-the-fluctuation-picture-格林-久保关系涨落图">3.
The Green-Kubo Relation: The Fluctuation Picture
格林-久保关系：涨落图</h3>
<p>Finally, the board presents the more advanced but often more
practical method: the <strong>Green-Kubo relation</strong>.</p>
<ul>
<li><strong>The Equations:</strong> This section displays the two key
equations from our last discussion:
<ol type="1">
<li>The MSD as the double integral of the Velocity Autocorrelation
Function (VACF). 速度自相关函数 (VACF) 的二重积分的均方差 (MSD)。</li>
<li>The crucial derivative step: <span
class="math inline">\(\frac{d\langle x^2(t)\rangle}{dt} = 2 \int_0^t
dt&#39;&#39; \langle V_x(t) V_x(t&#39;&#39;) \rangle\)</span>.
关键的导数步骤：<span class="math inline">\(\frac{d\langle
x^2(t)\rangle}{dt} = 2 \int_0^t dt&#39;&#39; \langle V_x(t)
V_x(t&#39;&#39;) \rangle\)</span>。</li>
</ol></li>
<li><strong>The Diagram:</strong> The small diagram of a square with
axes <span class="math inline">\(t&#39;\)</span> and <span
class="math inline">\(t&#39;&#39;\)</span> visually represents the
two-dimensional domain of integration for the double integral.
一个带有轴 <span class="math inline">\(t&#39;\)</span> 和 <span
class="math inline">\(t&#39;&#39;\)</span>
的小正方形图直观地表示了二重积分的二维积分域。</li>
<li><strong>Connection:</strong> This summarizes the “Fluctuation
Picture.” It shows the mathematical heart of the derivation that proves
the Einstein and Green-Kubo methods are equivalent. As we concluded,
this method is often numerically superior because it involves
integrating a rapidly decaying function (the VACF) rather than finding
the slope of a noisy, unbounded function (the MSD).
这概括了“涨落图”。它展示了证明爱因斯坦方法和格林-久保方法等价的推导过程的数学核心。正如我们总结的那样，这种方法通常在数值上更胜一筹，因为它涉及对快速衰减函数（VACF）进行积分，而不是求噪声无界函数（MSD）的斜率。</li>
</ul>
<p>In essence, this single whiteboard is a complete roadmap for
analyzing diffusion in a molecular simulation. It shows how to first
characterize the material’s <strong>structure</strong> (<span
class="math inline">\(g(r)\)</span>) and then how to compute its key
dynamic property—the <strong>diffusion constant
<code>D</code></strong>—using two powerful, interconnected methods.
本质上，这块白板就是分子模拟中分析扩散的完整路线图。它展示了如何首先表征材料的<strong>结构</strong>（<span
class="math inline">\(g(r)\)</span>），然后如何使用两种强大且相互关联的方法计算其关键的动态特性——<strong>扩散常数
<code>D</code></strong>。</p>
<p>This whiteboard beautifully concludes the derivation of the
Green-Kubo relation, showing the final formulas and how they are used in
practice. It provides the punchline to the mathematical story we’ve been
following.</p>
<p>Let’s break down the details.</p>
<h3 id="finalizing-the-derivation">4. Finalizing the Derivation</h3>
<p>The top lines of the board show the final step in connecting the Mean
Squared Displacement (MSD) to the Velocity Autocorrelation Function
(VACF).</p>
<p><span class="math display">\[\lim_{t\to\infty} \frac{d\langle x^2
\rangle}{dt} = 2 \int_0^\infty d\tau \langle V_x(0) V_x(\tau)
\rangle\]</span></p>
<ul>
<li><strong>The Left Side:</strong> As we know from the <strong>Einstein
relation</strong>, the long-time limit of the derivative of the 1D MSD,
<span class="math inline">\(\lim_{t\to\infty} \frac{d\langle x^2
\rangle}{dt}\)</span>, is simply equal to <strong><span
class="math inline">\(2D\)</span></strong>.</li>
<li><strong>The Right Side:</strong> This is the result of the
mathematical derivation from the previous slide. It shows that this same
quantity is also equal to twice the total integral of the VACF.</li>
</ul>
<p>By equating these two, we can solve for the diffusion coefficient,
<code>D</code>.</p>
<h3 id="the-velocity-autocorrelation-function-vacf">5. The Velocity
Autocorrelation Function (VACF)</h3>
<p>The board explicitly names the key quantity here:</p>
<p><span class="math display">\[\Phi(\tau) = \langle V_x(0) V_x(\tau)
\rangle\]</span></p>
<p>This is the <strong>“Velocity autocorrelation function”</strong>
(abbreviated as VAF on the board), which we’ve denoted as VACF. The
variable has been changed from <code>t</code> to <code>τ</code> (tau) to
represent a “time lag” or interval, which is common notation.</p>
<ul>
<li><strong>The Plot:</strong> The graph on the board shows a typical
plot of the VACF, <span class="math inline">\(\Phi(\tau)\)</span>,
versus the time lag <span class="math inline">\(\tau\)</span>.
<ul>
<li>It starts at a maximum positive value at <span
class="math inline">\(\tau=0\)</span> (when the velocity is perfectly
correlated with itself).</li>
<li>It rapidly decays towards zero as the particle undergoes collisions
that randomize its velocity.</li>
</ul></li>
<li><strong>The Integral:</strong> The shaded area under this curve
represents the value of the integral <span
class="math inline">\(\int_0^\infty \Phi(\tau) d\tau\)</span>. The
Green-Kubo formula states that the diffusion coefficient is directly
proportional to this area.</li>
</ul>
<h3 id="the-green-kubo-formulas-for-the-diffusion-coefficient">6. The
Green-Kubo Formulas for the Diffusion Coefficient</h3>
<p>After canceling the factor of 2, the board presents the final,
practical formulas for <code>D</code>.</p>
<ul>
<li><strong>In 1 Dimension:</strong> <span class="math display">\[D =
\int_0^\infty d\tau \langle V_x(0) V_x(\tau) \rangle\]</span></li>
<li><strong>In 3 Dimensions:</strong> This is the more general and
useful formula. <span class="math display">\[D = \frac{1}{3}
\int_0^\infty d\tau \langle \vec{v}(0) \cdot \vec{v}(\tau)
\rangle\]</span> There are two important changes for 3D:
<ol type="1">
<li>We use the full <strong>velocity vectors</strong> and their dot
product, <span class="math inline">\(\vec{v}(0) \cdot
\vec{v}(\tau)\)</span>, to capture motion in all directions.</li>
<li>We divide by <strong>3</strong> to get the average contribution to
diffusion in any one direction (x, y, or z).</li>
</ol></li>
</ul>
<h3 id="practical-calculation-in-a-simulation">7. Practical Calculation
in a Simulation</h3>
<p>The last formula on the board shows how this is implemented in a
computer simulation with a finite number of atoms.</p>
<p><span class="math display">\[D = \frac{1}{3N} \int_0^\infty d\tau
\sum_{i=1}^{N} \langle \vec{v}_i(0) \cdot \vec{v}_i(\tau)
\rangle\]</span></p>
<ul>
<li><strong><span
class="math inline">\(\sum_{i=1}^{N}\)</span></strong>: This
<strong>summation</strong> symbol indicates that you must compute the
VACF for <em>each individual atom</em> (from atom <code>i=1</code> to
atom <code>N</code>).</li>
<li><strong><span class="math inline">\(\frac{1}{N}\)</span></strong>:
You then <strong>average</strong> the results over all <code>N</code>
atoms in your simulation box.</li>
<li><strong><span class="math inline">\(\langle \dots
\rangle\)</span></strong>: The angle brackets here still imply an
additional average over multiple different starting times
(<code>t=0</code>) to get good statistics.</li>
</ul>
<p>This formula is the practical recipe: to get the diffusion
coefficient, you track the velocity of every atom, calculate each one’s
VACF, average them together, and then integrate the result over
time.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/16/5054C3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/16/5054C3/" class="post-title-link" itemprop="url">MSDM 5054 - Statistical Machine Learning-L3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-16 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-16T21:00:00+08:00">2025-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:11" itemprop="dateModified" datetime="2025-09-19T19:24:11+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计机器学习Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://www.math.hkust.edu.hk/~madxia/">Lecturer: Prof.XIA
DONG</a></p>
<h1 id="general-linear-regression-model.">1. General linear regression
model.</h1>
<p><img src="/imgs/5054C3/General_linear_regression_model.png" alt="Diagram of a linear regression model">
## 1.1 general linear regression model - <strong>内容</strong>:
<strong>general linear regression model</strong>.</p>
<p>the fundamental equation:</p>
<p><span class="math display">\[y_i = \beta_0 + \beta_1x_{i1} + \dots +
\beta_px_{ip} + \epsilon_i\]</span></p>
<p>And it correctly identifies the main goal: to <strong>estimate the
parameters</strong> (the coefficients <span
class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span>) from
data so we can make predictions on new data.</p>
<p>核心目标：通过数据<strong>估计参数</strong>（即系数 <span
class="math inline">\(\beta_0, \beta_1, \dots,
\beta_p\)</span>），从而对新数据进行预测。</p>
<h2
id="how-we-actually-find-the-best-values-for-the-β-coefficients-parameter-estimation">1.2
How we actually find the best values for the <span
class="math inline">\(β\)</span> coefficients (parameter
estimation)?:</h2>
<ul>
<li><strong>内容</strong>: We find the best values for the <span
class="math inline">\(\beta\)</span> coefficients by finding the values
that <strong>minimize the overall error</strong> of the model. The most
common and fundamental method for this is called <strong>Ordinary Least
Squares (OLS)</strong>.</li>
</ul>
<h3
id="the-main-method-ordinary-least-squares-ols-普通最小二乘法-ols">##
The Main Method: Ordinary Least Squares (OLS) 普通最小二乘法 (OLS)</h3>
<p>The core idea of OLS is to find the line (or hyperplane in multiple
dimensions) that is as close as possible to all the data points
simultaneously. OLS
的核心思想是找到一条尽可能同时接近所有数据点的直线（或多维超平面）。</p>
<h4 id="define-the-error-residuals-误差">1. Define the Error (Residuals)
误差</h4>
<p>First, we need to define what “error” means. For any single data
point, the error is the difference between the actual value (<span
class="math inline">\(y_i\)</span>) and the value predicted by our model
(<span class="math inline">\(\hat{y}_i\)</span>). This difference is
called the <strong>residual</strong>.
首先，需要定义“误差”的含义。对于任何单个数据点，误差是实际值 (<span
class="math inline">\(y_i\)</span>) 与模型预测值 (<span
class="math inline">\(\hat{y}_i\)</span>)
之间的差值。这个差值称为<strong>残差</strong>。</p>
<p><strong>Residual</strong> = Actual Value - Predicted Value
<strong>残差</strong> = 实际值 - 预测值 <span class="math display">\[e_i
= y_i - \hat{y}_i\]</span></p>
<p>You can visualize residuals as the vertical distance from each data
point to the regression line.
可以将残差可视化为每个数据点到回归线的垂直距离。</p>
<h4
id="the-cost-function-sum-of-squared-residuals-成本函数残差平方和">2.
The Cost Function: Sum of Squared Residuals 成本函数：残差平方和</h4>
<p>We want to make all these residuals as small as possible. We can’t
just add them up, because some are positive and some are negative, and
they would cancel each other out.
所有残差尽可能小。不能简单地将它们相加，因为有些是正数，有些是负数，它们会相互抵消。</p>
<p>So, we square each residual (which makes them all positive) and then
sum them up. This gives us the <strong>Sum of Squared Residuals
(SSR)</strong>, which is our “cost function.”
因此，将每个残差求平方（使它们都为正数），然后将它们相加。这就得到了<strong>残差平方和
(SSR)</strong>，也就是“成本函数”。</p>
<p><span class="math display">\[SSR = \sum_{i=1}^{n} e_i^2 =
\sum_{i=1}^{n} (y_i - \hat{y}_i)^2\]</span></p>
<p>The goal of OLS is simple: <strong>find the values of <span
class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span> that
make this SSR value as small as possible.</strong></p>
<h4
id="solving-for-the-coefficients-the-normal-equation-求解系数正态方程">3.
Solving for the Coefficients: The Normal Equation
求解系数：正态方程</h4>
<p>For linear regression, calculus provides a direct, exact solution to
this minimization problem. By taking the derivative of the SSR function
with respect to each <span class="math inline">\(\beta\)</span>
coefficient and setting it to zero, we can solve for the optimal values.
对于线性回归，微积分为这个最小化问题提供了直接、精确的解。通过对 SSR
函数的每个 <span class="math inline">\(\beta\)</span>
系数求导并将其设为零，就可以求解出最优值。</p>
<p>This process results in a formula known as the <strong>Normal
Equation</strong>, which can be expressed cleanly using matrix algebra:
这个过程会得到一个称为<strong>正态方程</strong>的公式，它可以用矩阵代数清晰地表示出来：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is the
vector of our estimated coefficients.估计系数的向量。</li>
<li><span class="math inline">\(\mathbf{X}\)</span> is a matrix where
each row is an observation and each column is a feature (with an added
column of 1s for the intercept <span
class="math inline">\(\beta_0\)</span>).其中每一行代表一个观测值，每一列代表一个特征（截距
<span class="math inline">\(\beta_0\)</span> 增加了一列全为 1
的值）。</li>
<li><span class="math inline">\(\mathbf{y}\)</span> is the vector of the
actual response values.实际响应值的向量。</li>
</ul>
<p>Statistical software and programming libraries (like Scikit-learn in
Python) use this equation (or more computationally stable versions of
it) to find the best coefficients for you instantly.</p>
<h3 id="an-alternative-method-gradient-descent-梯度下降">## An
Alternative Method: Gradient Descent 梯度下降</h3>
<p>While the Normal Equation gives a direct answer, it can be very slow
if you have a massive number of features (e.g., hundreds of thousands).
An alternative, iterative method used across machine learning is
<strong>Gradient Descent</strong>.</p>
<p><strong>The Intuition:</strong> Imagine the SSR cost function is a
big valley. Your initial (random) <span
class="math inline">\(\beta\)</span> coefficients place you somewhere on
the slope of this valley.</p>
<ol type="1">
<li><strong>Check the slope</strong> (the gradient) at your current
position. <strong>检查您当前位置的斜率</strong>（梯度）。</li>
<li><strong>Take a small step</strong> in the steepest <em>downhill</em>
direction. <strong>朝最陡的<em>下坡</em>方向</strong>迈出一小步**。</li>
<li><strong>Repeat.</strong> You keep taking steps downhill until you
reach the bottom of the valley. The bottom of the valley represents the
minimum SSR, and your coordinates at that point are the optimal <span
class="math inline">\(\beta\)</span> coefficients.
<strong>重复</strong>。您继续向下走，直到到达山谷底部。谷底代表最小SSR，该点的坐标即为最优<span
class="math inline">\(\beta\)</span>系数。</li>
</ol>
<p>The size of each “step” you take is controlled by a parameter called
the <strong>learning rate</strong>. Gradient Descent is the foundational
optimization algorithm for many complex models, including neural
networks.
每次“步进”的大小由一个称为<strong>学习率</strong>的参数控制。梯度下降是许多复杂模型（包括神经网络）的基础优化算法。</p>
<h3 id="summary-ols-vs.-gradient-descent">## Summary: OLS vs. Gradient
Descent</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Ordinary Least Squares (OLS)</th>
<th style="text-align: left;">Gradient Descent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>How it works</strong></td>
<td style="text-align: left;">Direct calculation using the Normal
Equation.</td>
<td style="text-align: left;">Iterative; takes steps to minimize
error.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Pros</strong></td>
<td style="text-align: left;">Provides an exact, optimal solution. No
parameters to tune.</td>
<td style="text-align: left;">More efficient for very large datasets.
Very versatile.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Cons</strong></td>
<td style="text-align: left;">Can be computationally expensive with many
features.</td>
<td style="text-align: left;">Requires choosing a learning rate. May not
find the exact minimum.</td>
</tr>
</tbody>
</table>
<h1 id="simple-linear-regression">2. Simple Linear Regression</h1>
<p><img src="/imgs/5054C3/Simple_Linear_Regression.png" alt="Simple_Linear_Regression"></p>
<h2 id="simple-linear-regression-1">2.1 Simple Linear Regression</h2>
<ul>
<li><strong>内容</strong>: <strong>Simple Linear Regression:</strong> a
special case of the general model you showed earlier where you only have
<strong>one</strong> predictor variable (<span
class="math inline">\(p=1\)</span>).</li>
</ul>
<h3 id="the-model-and-the-goal-模型和目标">## The Model and the Goal
模型和目标</h3>
<p>Sets up the simplified equation for a line: <span
class="math display">\[y_i = \beta_0 + \beta_1x_i + \epsilon_i\]</span>
* <span class="math inline">\(y_i\)</span> is the outcome you want to
predict.要预测的结果。 * <span class="math inline">\(x_i\)</span> is
your single input feature or covariate.单个输入特征或协变量。 * <span
class="math inline">\(\beta_1\)</span> is the <strong>slope</strong> of
the line. It tells you how much <span class="math inline">\(y\)</span>
is expected to increase for a one-unit increase in <span
class="math inline">\(x\)</span>.表示 <span
class="math inline">\(x\)</span> 每增加一个单位，<span
class="math inline">\(y\)</span> 预计会增加多少。 * <span
class="math inline">\(\beta_0\)</span> is the
<strong>intercept</strong>. It’s the predicted value of <span
class="math inline">\(y\)</span> when <span
class="math inline">\(x\)</span> is zero.当 <span
class="math inline">\(x\)</span> 为零时 <span
class="math inline">\(y\)</span> 的预测值。 * <span
class="math inline">\(\epsilon_i\)</span> is the random error
term.是随机误差项。</p>
<p>The goal, stated as “Minimize the sum of squares of err,” is exactly
the <strong>Ordinary Least Squares (OLS)</strong> method we just
discussed. It’s written here as: <span class="math display">\[\min_{a,b}
\sum_{i=1}^{n} (y_i - a - bx_i)^2\]</span> This is just a different way
of writing the same thing, where they use <code>a</code> for the
intercept (<span class="math inline">\(\beta_0\)</span>) and
<code>b</code> for the slope (<span
class="math inline">\(\beta_1\)</span>). You’re trying to find the
specific values of the slope and intercept that make the sum of all the
squared errors as small as possible.
目标，即“最小化误差平方和”，正是<strong>普通最小二乘法
(OLS)</strong>。： <span class="math display">\[\min_{a,b}
\sum_{i=1}^{n} (y_i - a - bx_i)^2\]</span> 这是另一种写法，其中用
<code>a</code> 表示截距 (<span
class="math inline">\(\beta_0\)</span>)，<code>b</code> 表示斜率 (<span
class="math inline">\(\beta_1\)</span>)。尝试找到斜率和截距的具体值，使得所有平方误差之和尽可能小。</p>
<h3 id="the-solution-the-estimator-formulas-解决方案估计公式">## The
Solution: The Estimator Formulas 解决方案：估计公式</h3>
<p>The most important part of this slide is the
<strong>solution</strong>. For the simple case with only one variable,
you don’t need complex matrix algebra (the Normal Equation). Instead,
the minimization problem can be solved with these two straightforward
formulas:
对于只有一个变量的简单情况，不需要复杂的矩阵代数（正态方程）。相反，最小化问题可以用以下两个简单的公式来解决：</p>
<h4 id="the-slope-hatbeta_1">1. The Slope: <span
class="math inline">\(\hat{\beta}_1\)</span></h4>
<p><span class="math display">\[\hat{\beta}_1 = \frac{\sum_{i=1}^{n}
(x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^{n} (x_i -
\bar{x})^2}\]</span> * <strong>Intuition:</strong> This formula might
look complex, but it’s actually very intuitive. * The numerator, <span
class="math inline">\(\sum(x_i - \bar{x})(y_i - \bar{y})\)</span>, is
closely related to the <strong>covariance</strong> between X and Y. It
measures whether X and Y tend to move in the same direction (positive
slope) or in opposite directions (negative slope). 与 X 和 Y
之间的<strong>协方差</strong>密切相关。它衡量 X 和 Y
是倾向于朝相同方向（正斜率）还是朝相反方向（负斜率）移动。 * The
denominator, <span class="math inline">\(\sum(x_i - \bar{x})^2\)</span>,
is related to the <strong>variance</strong> of X. It measures how much X
varies on its own. 它衡量 X 自身的变化量。 * <strong>In short, the slope
is a measure of how X and Y vary together, scaled by how much X varies
by itself.</strong> 斜率衡量的是 X 和 Y 共同变化的程度，并以 X
自身的变化量为标度。</p>
<h4 id="the-intercept-hatbeta_0-截距">2. The Intercept: <span
class="math inline">\(\hat{\beta}_0\)</span> 截距</h4>
<p><span class="math display">\[\hat{\beta}_0 = \bar{y} -
\hat{\beta}_1\bar{x}\]</span> * <strong>Intuition:</strong> This formula
is even simpler and has a wonderful geometric meaning. It ensures that
the <strong>line of best fit always passes through the “center of mass”
of the data</strong>, which is the point of averages <span
class="math inline">\((\bar{x}, \bar{y})\)</span>.
它确保<strong>最佳拟合线始终穿过数据的“质心”</strong>，即平均值 <span
class="math inline">\((\bar{x}, \bar{y})\)</span> 的点。计算出最佳斜率
(<span class="math inline">\(\hat{\beta}_1\)</span>)
后，就可以将其代入此公式。然后，可以调整截距 (<span
class="math inline">\(\hat{\beta}_0\)</span>)，使直线完美地围绕数据云的中心点旋转。
* Once you’ve calculated the best slope (<span
class="math inline">\(\hat{\beta}_1\)</span>), you can plug it into this
formula. You then adjust the intercept (<span
class="math inline">\(\hat{\beta}_0\)</span>) so that the line pivots
perfectly around the central point of your data cloud.</p>
<p>In summary, this slide provides the precise, closed-form formulas to
calculate the slope and intercept for the line of best fit in a simple
linear regression model.</p>
<h1 id="statistical-inference">3. Statistical Inference</h1>
<p><img src="/imgs/5054C3/Statistical_Inference1.png" alt="Statistical_Inference1">
<img src="/imgs/5054C3/Statistical_Inference2.png" alt="Statistical_Inference2">
## 3.1 Statistical Inference - <strong>内容</strong>:
<strong>Statistical Inference:</strong> These two slides are deeply
connected and explain how we go from just <em>calculating</em> the
coefficients to understanding how <em>accurate</em> and
<em>reliable</em> they are.
解释了我们如何从仅仅<em>计算</em>系数到理解它们的<em>准确性</em>和<em>可靠性</em>。</p>
<h3 id="the-core-problem-quantifying-uncertainty-量化不确定性">## The
Core Problem: Quantifying Uncertainty 量化不确定性</h3>
<p>The second slide poses the fundamental questions: * “How accurate are
<span class="math inline">\(\hat{\beta}_0\)</span> and <span
class="math inline">\(\hat{\beta}_1\)</span>?”准确性如何？ * “What are
the distributions of <span class="math inline">\(\hat{\beta}_0\)</span>
and <span class="math inline">\(\hat{\beta}_1\)</span>?”分布是什么？</p>
<p>The reason we ask this is that our estimated coefficients (<span
class="math inline">\(\hat{\beta}_0, \hat{\beta}_1\)</span>) were
calculated from a <strong>specific sample of data</strong>. If we
collected a different random sample from the same population, we would
get slightly different estimates.估计的系数 (<span
class="math inline">\(\hat{\beta}_0, \hat{\beta}_1\)</span>)
是根据<strong>特定的数据样本</strong>计算出来的。如果我们从同一总体中随机抽取不同的样本，我们得到的估计值会略有不同。</p>
<p>The goal of statistical inference is to use the estimates from our
single sample to make conclusions about the <strong>true, unknown
population parameters</strong> (<span class="math inline">\(\beta_0,
\beta_1\)</span>) and to quantify our uncertainty about
them.统计推断的目标是利用单个样本的估计值得出关于<strong>真实、未知的总体参数</strong>（<span
class="math inline">\(\beta_0,
\beta_1\)</span>）的结论，并量化对这些参数的不确定性。</p>
<h3
id="the-key-assumption-that-makes-it-possible-实现这一目标的关键假设">##
The Key Assumption That Makes It Possible 实现这一目标的关键假设</h3>
<p>To figure out the distribution of our estimates, we must make an
assumption about the distribution of the errors. This is the most
important assumption in linear regression for inference:
为了确定估计值的分布，必须对误差的分布做出假设。这是线性回归推断中最重要的假设：
<strong>Assumption:</strong> <span class="math inline">\(\epsilon_i
\stackrel{\text{i.i.d.}}{\sim} N(0, \sigma^2)\)</span></p>
<p>This means we assume the random error terms are: * <strong>Normally
distributed</strong> (<span class="math inline">\(N\)</span>).*
<strong>正态分布</strong>（<span class="math inline">\(N\)</span>）。 *
Have a mean of <strong>zero</strong> (our model is correct on average).*
均值为<strong>零</strong>（模型平均而言是正确的）。 * Have a constant
variance <strong><span class="math inline">\(\sigma^2\)</span></strong>
(homoscedasticity).* 方差为常数<strong><span
class="math inline">\(\sigma^2\)</span></strong>（方差齐性）。 * Are
<strong>independent and identically distributed</strong> (i.i.d.),
meaning each error is independent of the others.*
是<strong>独立同分布</strong>（i.i.d.）的，这意味着每个误差都独立于其他误差。</p>
<p><strong>Why is this important?</strong> Because our coefficients
<span class="math inline">\(\hat{\beta}_0\)</span> and <span
class="math inline">\(\hat{\beta}_1\)</span> are calculated as weighted
sums of the <span class="math inline">\(y_i\)</span> values, and the
<span class="math inline">\(y_i\)</span> values depend on the errors
<span class="math inline">\(\epsilon_i\)</span>. This assumption about
the errors allows us to prove that our estimated coefficients themselves
are also normally distributed. 系数 <span
class="math inline">\(\hat{\beta}_0\)</span> 和 <span
class="math inline">\(\hat{\beta}_1\)</span> 是通过 <span
class="math inline">\(y_i\)</span> 值的加权和计算的，而 <span
class="math inline">\(y_i\)</span> 值取决于误差 <span
class="math inline">\(\epsilon_i\)</span>。这个关于误差的假设使能够证明估计的系数本身也服从正态分布。</p>
<h3
id="the-solution-the-theorem-and-the-t-distribution-定理和-t-分布">##
The Solution: The Theorem and the t-distribution 定理和 t 分布</h3>
<p>The first slide provides the central theorem that allows us to
perform inference. It tells us exactly how to standardize our estimated
coefficients so they follow a known distribution.
第一张幻灯片提供了进行推断的核心定理。它准确地告诉我们如何对估计的系数进行标准化，使其服从已知的分布。</p>
<h4 id="the-standard-error-s.e.-标准误差-s.e.">1. The Standard Error
(s.e.) 标准误差 (s.e.)</h4>
<p>First, look at the denominators in the red dotted boxes. These are
the <strong>standard errors</strong> of the coefficients,
<code>s.e.($\hat&#123;\beta&#125;_1$)</code> and
<code>s.e.($\hat&#123;\beta&#125;_0$)</code>.
第一张幻灯片提供了进行推断的核心定理。它准确地告诉我们如何对估计的系数进行标准化，使其服从已知的分布。</p>
<ul>
<li><strong>What it is:</strong> The standard error is the estimated
<strong>standard deviation of the coefficient’s sampling
distribution</strong>. In simpler terms, it’s a measure of the average
amount by which our estimate <span
class="math inline">\(\hat{\beta}_1\)</span> would differ from the true
<span class="math inline">\(\beta_1\)</span> if we were to repeat the
experiment many times.
标准误差是系数抽样分布的<strong>标准差</strong>估计值。简单来说，它衡量的是如果我们重复实验多次，我们估计的
<span class="math inline">\(\hat{\beta}_1\)</span> 与真实的 <span
class="math inline">\(\beta_1\)</span> 之间的平均差异。</li>
<li><strong>A smaller standard error means a more precise and reliable
estimate.</strong>
<strong>标准误差越小，估计值越精确可靠。</strong></li>
</ul>
<h4 id="the-t-statistic-t-统计量">2. The t-statistic t 统计量</h4>
<p>The theorem shows two fractions that form a
<strong>t-statistic</strong>. The general structure for this is:
该定理展示了两个构成<strong>t 统计量</strong>的分数。其一般结构如下：
<span class="math display">\[t = \frac{\text{ (Sample Estimate - True
Value) }}{\text{ Standard Error of the Estimate }}\]</span></p>
<p>For <span class="math inline">\(\beta_1\)</span>, this is: <span
class="math inline">\(\frac{\hat{\beta}_1 -
\beta_1}{\text{s.e.}(\hat{\beta}_1)}\)</span>.</p>
<p>The key insight is that this specific quantity follows a
<strong>Student’s t-distribution</strong> with <strong><span
class="math inline">\(n-2\)</span> degrees of freedom</strong>.
关键在于，这个特定量服从<strong>学生 t
分布</strong>，其自由度为<strong><span
class="math inline">\(n-2\)</span>。 * </strong>Student’s
t-distribution:** This is a probability distribution that looks very
similar to the normal distribution but has slightly “heavier” tails. We
use it instead of the normal distribution because we had to
<em>estimate</em> the standard deviation of the errors (<code>s</code>
in the formula), which adds extra uncertainty.
这是一种概率分布，与正态分布非常相似，但尾部略重。使用它来代替正态分布，是因为必须<em>估计</em>误差的标准差（公式中的
<code>s</code>），这会增加额外的不确定性。 * <strong>Degrees of Freedom
(n-2):</strong> We start with <code>n</code> data points, but we lose
two degrees of freedom because we used the data to estimate two
parameters: <span class="math inline">\(\beta_0\)</span> and <span
class="math inline">\(\beta_1\)</span>. 从 <code>n</code>
个数据点开始，但由于用这些数据估计了两个参数：<span
class="math inline">\(\beta_0\)</span> 和 <span
class="math inline">\(\beta_1\)</span>，因此损失了两个自由度。 #### 3.
Estimating the Error Variance (<span
class="math inline">\(s^2\)</span>)估计误差方差 (<span
class="math inline">\(s^2\)</span>) To calculate the standard errors, we
need a value for <code>s</code>, which is our estimate of the true error
standard deviation <span class="math inline">\(\sigma\)</span>. This is
calculated from the <strong>Residual Sum of Squares (RSS)</strong>.
为了计算标准误差，我们需要一个 <code>s</code> 的值，它是对真实误差标准差
<span class="math inline">\(\sigma\)</span>
的估计值。该值由<strong>残差平方和 (RSS)</strong> 计算得出。 *
<strong>RSS:</strong> First, we calculate the RSS = <span
class="math inline">\(\sum(y_i - \hat{y}_i)^2\)</span>, which is the sum
of all the squared errors.* <strong>RSS</strong>：首先，计算 RSS = <span
class="math inline">\(\sum(y_i -
\hat{y}_i)^2\)</span>，即所有平方误差之和。 * <strong><span
class="math inline">\(s^2\)</span>:</strong> Then, we find the estimate
of the error variance: <span class="math inline">\(s^2 = \text{RSS} /
(n-2)\)</span>. We divide by <span class="math inline">\(n-2\)</span> to
get an unbiased estimate. * <strong><span
class="math inline">\(s^2\)</span></strong>：然后，计算误差方差的估计值：<span
class="math inline">\(s^2 = \text{RSS} / (n-2)\)</span>。我们将其除以
<span class="math inline">\(n-2\)</span> 即可得到无偏估计值。 *
<code>s</code> is simply the square root of <span
class="math inline">\(s^2\)</span>. This <code>s</code> is the value
used in the standard error formulas.* <code>s</code> 就是 <span
class="math inline">\(s^2\)</span> 的平方根。这个 <code>s</code>
是标准误差公式中使用的值。</p>
<h3 id="what-this-allows-us-to-do-the-practical-use">## What This Allows
Us To Do (The Practical Use)</h3>
<p>Because we know the exact distribution of our t-statistic, we can now
achieve our goal of quantifying uncertainty: 因为知道 t
统计量的精确分布，所以现在可以实现量化不确定性的目标：</p>
<ol type="1">
<li><strong>Hypothesis Testing:</strong> We can test if a predictor is
actually useful. The most common test is for the null hypothesis <span
class="math inline">\(H_0: \beta_1 = 0\)</span>. If we can prove the
observed <span class="math inline">\(\hat{\beta}_1\)</span> is very
unlikely to occur if the true <span
class="math inline">\(\beta_1\)</span> were zero, we can conclude there
is a statistically significant relationship between <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>.
可以检验一个预测变量是否真的有用。最常见的检验是零假设 <span
class="math inline">\(H_0: \beta_1 = 0\)</span>。如果能证明，当真实的
<span class="math inline">\(\beta_1\)</span> 为零时，观测到的 <span
class="math inline">\(\hat{\beta}_1\)</span>
不太可能发生，那么就可以得出结论，<span class="math inline">\(x\)</span>
和 <span class="math inline">\(y\)</span>
之间存在统计学上的显著关系。</li>
<li><strong>Confidence Intervals:</strong> We can construct a range of
plausible values for the true coefficient. For example, we can calculate
a 95% confidence interval for <span
class="math inline">\(\beta_1\)</span>. This gives us a range where we
are 95% confident the true value of <span
class="math inline">\(\beta_1\)</span> lies.
可以为真实系数构建一系列合理的值。</li>
</ol>
<h1 id="multiple-linear-regression">4. Multiple Linear Regression</h1>
<p><img src="/imgs/5054C3/Multiple_Linear Regression1.png" alt="Multiple_Linear Regression1">
<img src="/imgs/5054C3/Multiple_Linear Regression2.png" alt="Multiple_Linear Regression2">
## 4.1 Multiple Linear Regression - <strong>内容</strong>:
<strong>Multiple Linear Regression:</strong></p>
<p>Here’s a detailed breakdown that connects both slides.</p>
<h3
id="the-model-from-one-to-many-predictors-从单预测变量到多预测变量">##
The Model: From One to Many Predictors 从单预测变量到多预测变量</h3>
<p>The first slide introduces the <strong>Multiple Linear Regression
model</strong>. This is a direct extension of the simple model, but
instead of using just one predictor variable, we use multiple (<span
class="math inline">\(p\)</span>) predictors to explain our response
variable.
多元线性回归模型是简单模型的直接扩展，但不是只使用一个预测变量，而是使用多个（<span
class="math inline">\(p\)</span>）预测变量来解释响应变量。</p>
<p>The general formula is: <span class="math display">\[y_i = \beta_0 +
\beta_1x_{i1} + \beta_2x_{i2} + \dots + \beta_px_{ip} +
\epsilon_i\]</span></p>
<h4 id="key-change-in-interpretation">Key Change in Interpretation</h4>
<p>This is the most important new concept. In simple regression, <span
class="math inline">\(\beta_1\)</span> was just the slope. In multiple
regression, each coefficient has a more nuanced meaning:
在简单回归中，<span class="math inline">\(\beta_1\)</span>
只是斜率。在多元回归中，每个系数都有更微妙的含义：</p>
<p><strong><span class="math inline">\(\beta_j\)</span> is the average
change in <span class="math inline">\(y\)</span> for a one-unit increase
in <span class="math inline">\(x_j\)</span>, while holding all other
predictors constant.</strong></p>
<p>This is incredibly powerful. Using the advertising example from your
slide: * <span class="math inline">\(y_i = \beta_0 +
\beta_1(\text{TV}_i) + \beta_2(\text{Radio}_i) +
\beta_3(\text{Newspaper}_i) + \epsilon_i\)</span> * <span
class="math inline">\(\beta_1\)</span> represents the effect of TV
advertising on sales, <strong>after controlling for</strong> the amount
spent on Radio and Newspaper ads. This allows you to isolate the unique
contribution of each advertising
channel.表示在<strong>控制</strong>广播和报纸广告支出后，电视广告对销售额的影响。这可以让您区分每个广告渠道的独特贡献。</p>
<h3 id="the-solution-deriving-the-normal-equation-推导正态方程">## The
Solution: Deriving the Normal Equation 推导正态方程</h3>
<p>The second slide shows the mathematical process for finding the best
coefficients (<span class="math inline">\(\beta_0, \beta_1, \dots,
\beta_p\)</span>) using the <strong>Ordinary Least Squares
(OLS)</strong> method. It’s essentially a condensed derivation of the
<strong>Normal Equation</strong>. 使用<strong>普通最小二乘法
(OLS)</strong> 寻找最佳系数 (<span class="math inline">\(\beta_0,
\beta_1, \dots, \beta_p\)</span>)
的数学过程。它本质上是<strong>正态方程</strong>的简化推导。</p>
<h4 id="the-goal-minimizing-the-sum-of-squares-最小化平方和">1. The
Goal: Minimizing the Sum of Squares 最小化平方和</h4>
<p>Just like before, our goal is to minimize the sum of the squared
errors (or residuals): 目标是最小化平方误差（或残差）之和。</p>
<ul>
<li><strong>Scalar Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1x_{i1} -
\beta_2x_{i2} - \beta_3x_{i3})^2\)</span>
<ul>
<li>This is easy to read but gets very long with more variables.
代码易于阅读，但变量越多，代码越长。</li>
</ul></li>
<li><strong>Vector Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \boldsymbol{\beta}^T
\mathbf{x}_i)^2\)</span>
<ul>
<li>This is a more compact and powerful way to write the same thing
using linear algebra, where <span
class="math inline">\(\boldsymbol{\beta}^T \mathbf{x}_i\)</span> is the
dot product that calculates the entire predicted value <span
class="math inline">\(\hat{y}_i\)</span>.
这是一种更简洁、更强大的线性代数表示方法，其中 <span
class="math inline">\(\boldsymbol{\beta}^T \mathbf{x}_i\)</span>
是计算整个预测值 <span class="math inline">\(\hat{y}_i\)</span>
的点积。</li>
</ul></li>
</ul>
<h4
id="the-method-using-calculus-to-find-the-minimum-使用微积分求最小值">2.
The Method: Using Calculus to Find the Minimum 使用微积分求最小值</h4>
<p>To find the set of <span class="math inline">\(\beta\)</span> values
that results in the lowest possible error, we use calculus.</p>
<ul>
<li><p><strong>The Derivative (Gradient):</strong> Since our error
function depends on multiple <span class="math inline">\(\beta\)</span>
coefficients, we can’t take a simple derivative. Instead, we take the
<strong>gradient</strong>, which is a vector of partial derivatives (one
for each coefficient). This tells us the “slope” of the error function
in every direction. 导数（梯度） 误差函数依赖于多个 <span
class="math inline">\(\beta\)</span>
系数，因此我们不能简单地求导数。相反，采用<strong>梯度</strong>，它是一个由偏导数组成的向量（每个系数对应一个偏导数）。这告诉误差函数在各个方向上的“斜率”。</p></li>
<li><p><strong>Setting the Gradient to Zero:</strong> The minimum of a
function occurs where its slope is zero (the very bottom of the error
“valley”). The slide shows the result of taking this gradient and
setting it to
zero.函数的最小值出现在其斜率为零的地方（即误差“谷底”的最低点）。幻灯片展示了取此梯度并将其设为零的结果。</p></li>
</ul>
<p>The equation shown on the slide: <span class="math display">\[2
\sum_{i=1}^{n} (\boldsymbol{\beta}^T \mathbf{x}_i - y_i)\mathbf{x}_i^T =
0\]</span> …is the result of this calculus step. The goal is now to
algebraically rearrange this equation to solve for <span
class="math inline">\(\boldsymbol{\beta}\)</span>.
是这一微积分步骤的结果。现在的目标是用代数方法重新排列这个方程，以求解
<span class="math inline">\(\boldsymbol{\beta}\)</span>。</p>
<h4 id="the-result-the-normal-equation-正则方程">3. The Result: The
Normal Equation 正则方程</h4>
<p>After rearranging the equation from the previous step and expressing
the sums in their full matrix form, we arrive at a clean and beautiful
solution. While the slide doesn’t show the final step, the result of
“Setting the gradient zero and solve <span
class="math inline">\(\beta\)</span>” is the <strong>Normal
Equation</strong>:
重新排列上一步中的方程，并将和表示为完整的矩阵形式后，得到了一个简洁美观的解。虽然幻灯片没有展示最后一步，“设置梯度零点并求解
<span class="math inline">\(\beta\)</span>”
的结果就是<strong>正态方程</strong>：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is the
vector of our optimal coefficient estimates.</li>
<li><span class="math inline">\(\mathbf{X}\)</span> is the “design
matrix” where each row is an observation and each column is a predictor
variable. <span class="math inline">\(\mathbf{X}\)</span>
是“设计矩阵”，其中每一行代表一个观测值，每一列代表一个预测变量。</li>
<li><span class="math inline">\(\mathbf{y}\)</span> is the vector of our
response variable. <span class="math inline">\(\mathbf{y}\)</span>
是我们的响应变量的向量。</li>
</ul>
<p>This single equation is the general solution for finding the OLS
coefficients for <strong>any</strong> linear regression model, no matter
how many predictors you have. This is what statistical software
calculates for you under the hood.
无论有多少个预测变量，这个简单的方程都是<strong>任何</strong>线性回归模型中
OLS 系数的通解。</p>
<h1 id="matrix-notatio">5. matrix notatio</h1>
<p><img src="/imgs/5054C3/matrix_notatio.png"></p>
<ul>
<li><strong>内容</strong>: This slide introduces the <strong>matrix
notation</strong> for multiple linear regression, which is a powerful
way to represent the entire system of equations in a compact form. This
notation isn’t just for tidiness—it’s the foundation for how the
solutions are derived and calculated in software.</li>
</ul>
<p>多元线性回归的<strong>矩阵符号</strong>，这是一种以紧凑形式表示整个方程组的有效方法。这种符号不仅仅是为了简洁，它还是软件中推导和计算解的基础。
Here is a more detailed breakdown.</p>
<h3 id="why-use-matrix-notation">## Why Use Matrix Notation?</h3>
<p>Imagine you have 10,000 observations (<span
class="math inline">\(n=10,000\)</span>) and 5 predictor variables
(<span class="math inline">\(p=5\)</span>). Writing out the model
equation for each observation would be impossible: <span
class="math inline">\(y_1 = \beta_0 + \beta_1x_{11} + \dots +
\beta_5x_{15} + \epsilon_1\)</span> <span class="math inline">\(y_2 =
\beta_0 + \beta_1x_{21} + \dots + \beta_5x_{25} + \epsilon_2\)</span>
…and so on for 10,000 lines.</p>
<p>假设你有 10,000 个观测值（n=10,000）和 5
个预测变量（p=5）。为每个观测值写出模型方程是不可能的： <span
class="math inline">\(y_1 = \beta_0 + \beta_1x_{11} + \dots +
\beta_5x_{15} + \epsilon_1\)</span> <span class="math inline">\(y_2 =
\beta_0 + \beta_1x_{21} + \dots + \beta_5x_{25} + \epsilon_2\)</span>
……以此类推，直到 10,000 行。 Matrix notation allows us to consolidate
this entire system into a single, elegant
equation:矩阵符号使我们能够将整个系统合并成一个简洁的方程： <span
class="math display">\[\mathbf{y} = \mathbf{X}\boldsymbol{\beta} +
\boldsymbol{\epsilon}\]</span> Let’s break down each component shown on
your slide.</p>
<h3 id="the-components-explained">## The Components Explained</h3>
<h4 id="the-design-matrix-mathbfx-设计矩阵">1. The Design Matrix: <span
class="math inline">\(\mathbf{X}\)</span> 设计矩阵</h4>
<p><span class="math display">\[\mathbf{X} = \begin{pmatrix} 1 &amp;
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\ 1 &amp; x_{21} &amp;
x_{22} &amp; \cdots &amp; x_{2p} \\ \vdots &amp; \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots
&amp; x_{np} \end{pmatrix}\]</span> This is the most important matrix.
It contains all of your predictor variable
data.这是最重要的矩阵。它包含所有预测变量数据。 * <strong>Rows:</strong>
Each row represents a single observation (e.g., a person, a company, a
day). There are <strong>n</strong>
rows.每一行代表一个观察值（例如，一个人、一家公司、一天）。共有
<strong>n</strong> 行。 * <strong>Columns:</strong> Each column
represents a predictor variable. There are <strong>p</strong> predictor
columns, plus one special column.每列代表一个预测变量。共有
<strong>p</strong> 个预测列，外加一个特殊列。 * <strong>The Column of
Ones:</strong> This is a crucial detail. This first column of all ones
is a placeholder for the <strong>intercept term (<span
class="math inline">\(\beta_0\)</span>)</strong>. When you perform
matrix multiplication, this <code>1</code> gets multiplied by <span
class="math inline">\(\beta_0\)</span>, ensuring the intercept is
included in the model for every single observation.
这是一个至关重要的细节。第一列（全 1）是<strong>截距项 (<span
class="math inline">\(\beta_0\)</span>)</strong>
的占位符。执行矩阵乘法时，这个 <code>1</code> 会乘以 <span
class="math inline">\(\beta_0\)</span>，以确保截距包含在模型中，适用于每个观测值。</p>
<h4 id="the-coefficient-vector-boldsymbolbeta-系数向量">2. The
Coefficient Vector: <span
class="math inline">\(\boldsymbol{\beta}\)</span> 系数向量</h4>
<p><span class="math display">\[\boldsymbol{\beta} = \begin{pmatrix}
\beta_0 \\ \beta_1 \\ \vdots \\ \beta_p \end{pmatrix}\]</span> This is a
column vector that contains all the model parameters—the unknown values
we want to estimate. The goal of linear regression is to find the
numerical values for this vector.</p>
<h4 id="the-response-vector-mathbfy-响应向量">3. The Response Vector:
<span class="math inline">\(\mathbf{y}\)</span> 响应向量</h4>
<p><span class="math display">\[\mathbf{y} = \begin{pmatrix} y_1 \\
\vdots \\ y_n \end{pmatrix}\]</span> This is a column vector containing
all the observed outcomes you are trying to predict (e.g., sales, test
scores, stock prices).</p>
<h4 id="the-error-vector-boldsymbolepsilon-误差向量">4. The Error
Vector: <span class="math inline">\(\boldsymbol{\epsilon}\)</span>
误差向量</h4>
<p><span class="math display">\[\boldsymbol{\epsilon} = \begin{pmatrix}
\epsilon_1 \\ \vdots \\ \epsilon_n \end{pmatrix}\]</span> This column
vector bundles together all the individual, unobserved random errors. It
represents the portion of <strong>y</strong> that our model cannot
explain with <strong>X</strong>.</p>
<h3 id="putting-it-all-together">## Putting It All Together</h3>
<p>When you write the equation <span class="math inline">\(\mathbf{y} =
\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\epsilon}\)</span>, you are
actually representing the entire system of individual equations.</p>
<p>Let’s look at the multiplication <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>: <span
class="math display">\[\begin{pmatrix} 1 &amp; x_{11} &amp; \dots &amp;
x_{1p} \\ 1 &amp; x_{21} &amp; \dots &amp; x_{2p} \\ \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 1 &amp; x_{n1} &amp; \dots &amp; x_{np}
\end{pmatrix} \begin{pmatrix} \beta_0 \\ \beta_1 \\ \vdots \\ \beta_p
\end{pmatrix} = \begin{pmatrix} 1\cdot\beta_0 + x_{11}\cdot\beta_1 +
\dots + x_{1p}\cdot\beta_p \\ 1\cdot\beta_0 + x_{21}\cdot\beta_1 + \dots
+ x_{2p}\cdot\beta_p \\ \vdots \\ 1\cdot\beta_0 + x_{n1}\cdot\beta_1 +
\dots + x_{np}\cdot\beta_p \end{pmatrix}\]</span> As you can see, the
result of this multiplication is a single column vector where each row
is the “predictor” part of the regression equation for that observation.
此乘法的结果是一个单列向量，其中每一行都是该观测值的回归方程的“预测变量”部分。</p>
<p>By setting this equal to <span class="math inline">\(\mathbf{y} -
\boldsymbol{\epsilon}\)</span>, you perfectly recreate the entire set of
<code>n</code> equations in one clean statement. This compact form is
what allows us to easily derive and compute the <strong>Normal
Equation</strong> solution: <span
class="math inline">\(\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\)</span>.这种紧凑形式使我们能够轻松推导和计算<strong>正态方程</strong>的解</p>
<h1
id="the-core-mathematical-conclusion-of-ordinary-least-squares-ols">6.
the core mathematical conclusion of Ordinary Least Squares (OLS)</h1>
<p><img src="/imgs/5054C3/OLS1.png">
<img src="/imgs/5054C3/OLS2.png"></p>
<ul>
<li><strong>内容</strong>: Of course. These slides present the core
mathematical conclusion of Ordinary Least Squares (OLS) and a key
geometric property that explains <em>why</em> this solution works.
展示了普通最小二乘法 (OLS)
的核心数学结论，以及一个关键的几何性质，解释了该解决方案<em>为何</em>有效。
Let’s break down the concepts and the calculation processes in
detail.</li>
</ul>
<hr />
<h3 id="part-1-the-objective-and-the-solution-slide-1-最小化几何距离">##
Part 1: The Objective and the Solution (Slide 1) 最小化几何距离</h3>
<p>This slide summarizes the entire OLS problem and its solution in the
language of matrix algebra.</p>
<h4 id="the-concept-minimizing-geometric-distance"><strong>The Concept:
Minimizing Geometric Distance</strong></h4>
<p>“最小二乘准则”是我们模型的目标。 The “least squares criterion” is the
objective of our model. The slide shows it in two equivalent forms:</p>
<ol type="1">
<li><strong>Summation Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1x_{i1} -
\dots - \beta_px_{ip})^2\)</span> This is the sum of the squared
differences between the actual values (<span
class="math inline">\(y_i\)</span>) and the predicted values. 这是实际值
(<span class="math inline">\(y_i\)</span>) 与预测值之差的平方和。</li>
<li><strong>Matrix Form:</strong> <span
class="math inline">\(||\mathbf{y} - \mathbf{X}\boldsymbol{\beta}||^2 =
(\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^T(\mathbf{y} -
\mathbf{X}\boldsymbol{\beta})\)</span> This is the more powerful way to
view the problem. Think of <span
class="math inline">\(\mathbf{y}\)</span> (the vector of all actual
outcomes) and <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span> (the vector
of all predicted outcomes) as two points in an n-dimensional space. The
expression <span class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{\beta}||^2\)</span> represents the <strong>squared
Euclidean distance</strong> between these two points. 将 <span
class="math inline">\(\mathbf{y}\)</span>（所有实际结果的向量）和 <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>（所有预测结果的向量）视为
n 维空间中的两个点。表达式 <span class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{\beta}||^2\)</span>
表示这两点之间的<strong>平方欧氏距离</strong>。 Therefore, the OLS
problem is a geometric one: <strong>Find the coefficient vector <span
class="math inline">\(\boldsymbol{\beta}\)</span> that makes the
predicted values vector <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span> as close as
possible to the actual values vector <span
class="math inline">\(\mathbf{y}\)</span>.</strong> 因此，OLS
问题是一个几何问题：<strong>找到一个系数向量 <span
class="math inline">\(\boldsymbol{\beta}\)</span>，使预测值向量 <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>
尽可能接近实际值向量 <span
class="math inline">\(\mathbf{y}\)</span>。</strong></li>
</ol>
<h4
id="the-solution-the-least-squares-estimator-lse最小二乘估计器-lse"><strong>The
Solution: The Least Squares Estimator (LSE)</strong>最小二乘估计器
(LSE)</h4>
<p>The slide provides the direct solution to this minimization problem,
which is the <strong>Normal
Equation</strong>:此最小化问题的直接解，即<strong>正态方程</strong>：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<p>This formula gives you the exact vector of coefficients <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> that minimizes
the squared distance. We get this formula by taking the gradient (the
multidimensional version of a derivative) of the distance function with
respect to <span class="math inline">\(\boldsymbol{\beta}\)</span>,
setting it to zero, and solving, as hinted at in your previous slides.
给出了使平方距离最小化的精确系数向量 通过取距离函数关于 <span
class="math inline">\(\boldsymbol{\beta}\)</span>
的梯度（导数的多维版本），将其设为零，然后求解，即可得到此公式。
Finally, the slide defines: * <strong>Fitted values:</strong> <span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span> (The vector of predictions
using our optimal coefficients). 拟合值 * <strong>Residuals:</strong>
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span> (The vector of errors, representing the
difference between actuals and
predictions).误差向量，表示实际值与预测值之间的差异</p>
<h3
id="part-2-the-geometric-property-and-proofs-slide-2几何性质及证明">##
Part 2: The Geometric Property and Proofs (Slide 2)几何性质及证明</h3>
<p>This slide explains a beautiful and fundamental property of the least
squares solution:
<strong>orthogonality</strong>.解释了最小二乘解的一个美妙而基本的性质：<strong>正交性</strong>。</p>
<h4 id="the-concept-orthogonality-of-residuals残差的正交性"><strong>The
Concept: Orthogonality of Residuals</strong>残差的正交性</h4>
<p>The main idea is that the residual vector <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> is
<strong>orthogonal</strong> (perpendicular) to every predictor variable
in your model. 主要思想是残差向量 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>
与模型中的每个预测变量<strong>正交</strong>（垂直）。</p>
<ul>
<li><p><strong>Geometric Intuition:</strong> Think of the columns of
your matrix <span class="math inline">\(\mathbf{X}\)</span> (i.e., your
predictors and the intercept) as defining a flat surface, or a
“hyperplane,” in a high-dimensional space. Your actual data vector <span
class="math inline">\(\mathbf{y}\)</span> exists somewhere in this
space, likely not on the hyperplane. The OLS process finds the point on
that hyperplane, <span class="math inline">\(\hat{\mathbf{y}}\)</span>,
that is closest to <span class="math inline">\(\mathbf{y}\)</span>. The
shortest line from a point to a plane is always one that is
<strong>perpendicular</strong> to the plane. The residual vector, <span
class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>, <em>is</em> that line. 将矩阵 <span
class="math inline">\(\mathbf{X}\)</span>
的列（即预测变量和截距）想象成在高维空间中定义一个平面或“超平面”。实际数据向量
<span class="math inline">\(\mathbf{y}\)</span>
存在于该空间的某个位置，可能不在超平面上。OLS 过程会在该超平面 <span
class="math inline">\(\hat{\mathbf{y}}\)</span> 上找到与 <span
class="math inline">\(\mathbf{y}\)</span>
最接近的点。从一个点到一个平面的最短线始终是与该平面<strong>垂直</strong>的线。残差向量
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span> 就是这条直线。</p></li>
<li><p><strong>Mathematical Statement:</strong> This geometric property
is stated as <span class="math inline">\(\mathbf{X}^T
\hat{\boldsymbol{\epsilon}} = \mathbf{0}\)</span>. This equation means
that the dot product of the residual vector with every column of <span
class="math inline">\(\mathbf{X}\)</span> is zero, which is the
mathematical definition of orthogonality. 该等式意味着残差向量与 <span
class="math inline">\(\mathbf{X}\)</span>
每一列的点积都为零，这正是正交性的数学定义。</p></li>
</ul>
<h4 id="the-calculation-process-the-proofs"><strong>The Calculation
Process (The Proofs)</strong></h4>
<p><strong>1. Proof of Orthogonality:</strong> The slide shows a
step-by-step calculation to prove that <span
class="math inline">\(\mathbf{X}^T \hat{\boldsymbol{\epsilon}}\)</span>
is indeed zero. * <strong>Step 1:</strong> Start with the expression to
be proven: <span class="math inline">\(\mathbf{X}^T
\hat{\boldsymbol{\epsilon}}\)</span> 从待证明的表达式开始： *
<strong>Step 2:</strong> Substitute the definition of the residual,
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\mathbf{X}^T (\mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}})\]</span> 代入残差的定义 *
<strong>Step 3:</strong> Distribute the <span
class="math inline">\(\mathbf{X}^T\)</span>: <span
class="math display">\[\mathbf{X}^T \mathbf{y} -
\mathbf{X}^T\mathbf{X}\hat{\boldsymbol{\beta}}\]</span><em>分配 </em>
<strong>Step 4:</strong> Substitute the Normal Equation for <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\mathbf{X}^T \mathbf{y} - \mathbf{X}^T\mathbf{X}
[(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}]\]</span> *
<strong>Step 5:</strong> The key step is the cancellation. A matrix
<span class="math inline">\((\mathbf{X}^T\mathbf{X})\)</span> multiplied
by its inverse <span
class="math inline">\((\mathbf{X}^T\mathbf{X})^{-1}\)</span> equals the
identity matrix <span class="math inline">\(\mathbf{I}\)</span>, which
acts like the number 1 in multiplication. <span
class="math display">\[\mathbf{X}^T \mathbf{y} - \mathbf{I}
\mathbf{X}^T\mathbf{y} = \mathbf{X}^T \mathbf{y} -
\mathbf{X}^T\mathbf{y} = \mathbf{0}\]</span> 关键步骤是消去。 This
completes the proof, showing that the orthogonality property is a direct
consequence of the Normal Equation solution.</p>
<p><strong>2. Proof of LSE:</strong> This is a more abstract proof
showing that our <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> truly gives the
minimum possible error. It uses the orthogonality property and the
Pythagorean theorem for vectors. It essentially shows that for any other
possible coefficient vector <span
class="math inline">\(\boldsymbol{v}\)</span>, the error <span
class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{v}||^2\)</span> will always be greater than or
equal to the error from our LSE, <span
class="math inline">\(||\mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}}||^2\)</span>.</p>
<h1 id="geometric-interpretation">7.geometric interpretation</h1>
<p><img src="/imgs/5054C3/geometric_interpretation1.png">
<img src="/imgs/5054C3/geometric_interpretation2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These two slides together provide a powerful geometric interpretation
of how Ordinary Least Squares (OLS) works, centered on the concepts of
<strong>orthogonality</strong> and <strong>projection</strong>.
以<strong>正交性</strong>和<strong>投影</strong>的概念为中心，从几何角度有力地诠释了普通最小二乘法
(OLS) 的工作原理。</p>
<p>Here’s a detailed summary of the concepts and the processes they
describe.</p>
<h3 id="summary">## Summary</h3>
<p>These slides explain that the process of finding the “best fit” line
in regression is geometrically equivalent to <strong>projecting</strong>
the actual data vector (<span class="math inline">\(\mathbf{y}\)</span>)
onto a hyperplane defined by the predictor variables (<span
class="math inline">\(\mathbf{X}\)</span>). This projection splits the
actual data into two perpendicular components:
解释了回归分析中寻找“最佳拟合”直线的过程，其几何意义等同于将实际数据向量
(<span class="math inline">\(\mathbf{y}\)</span>)
<strong>投影</strong>到由预测变量 (<span
class="math inline">\(\mathbf{X}\)</span>)
定义的超平面上。此投影将实际数据拆分为两个垂直分量：</p>
<ol type="1">
<li><strong>The Fitted Values (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>):</strong> The part of
the data that is perfectly explained by the model (the projection).
数据中能够被模型完美解释的部分（投影）。</li>
<li><strong>The Residuals (<span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>):</strong>
The part of the data that is unexplained (the error), which is
perpendicular to the explained part.
数据中无法解释的部分（误差），它与被解释部分垂直。 A special tool called
the <strong>projection matrix (H)</strong>, or “hat matrix,” is
introduced as the operator that performs this projection.
引入一个称为<strong>投影矩阵
(H)</strong>（或称“帽子矩阵”）的特殊工具，作为执行此投影的运算符。</li>
</ol>
<h3 id="concepts-and-process-explained-in-detail">## Concepts and
Process Explained in Detail</h3>
<h4 id="the-fitted-values-as-a-linear-combination-拟合值作为线性组合">1.
The Fitted Values as a Linear Combination 拟合值作为线性组合</h4>
<p>The first slide starts by stating that the fitted value vector <span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span> is a <strong>linear
combination</strong> of the columns of <span
class="math inline">\(\mathbf{X}\)</span> (your predictors).</p>
<ul>
<li><p><strong>Concept:</strong> This means that the vector of fitted
values, <span class="math inline">\(\hat{\mathbf{y}}\)</span>, must lie
within the geometric space (a line, plane, or hyperplane) spanned by
your predictor variables. The model is incapable of producing a
prediction that does not live in this space. 这意味着拟合值向量 <span
class="math inline">\(\hat{\mathbf{y}}\)</span>
必须位于预测变量所构成的几何空间（直线、平面或超平面）内。模型无法生成不存在于此空间的预测。
#### 2. The Projection Matrix (The “Hat Matrix”) 投影矩阵（“帽子矩阵”）
The second slide introduces the tool that makes this projection happen:
the <strong>projection matrix</strong>, also called the <strong>hat
matrix</strong>, <strong>H</strong>.</p></li>
<li><p><strong>Definition:</strong> <span
class="math inline">\(\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span></p></li>
<li><p><strong>Process:</strong> This matrix has a special job. When you
multiply it by any vector (like our data vector <span
class="math inline">\(\mathbf{y}\)</span>), it projects that vector onto
the space spanned by the columns of <span
class="math inline">\(\mathbf{X}\)</span>. We can see this by starting
with our definition of fitted values and substituting the normal
equation solution for <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}} =
\mathbf{X}[(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}] =
[\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T]\mathbf{y}\]</span>
This shows that: <span class="math display">\[\hat{\mathbf{y}} =
\mathbf{H}\mathbf{y}\]</span> This is why <strong>H</strong> is
nicknamed the <strong>hat matrix</strong>—it “puts the hat” on <span
class="math inline">\(\mathbf{y}\)</span>.
这个矩阵有其特殊的用途。当你将它乘以任何向量（例如我们的数据向量 <span
class="math inline">\(\mathbf{y}\)</span>）时，它会将该向量投影到由
<span class="math inline">\(\mathbf{X}\)</span> 的列所跨越的空间上。
#### 3. The Orthogonality of Fitted Values and Residuals
拟合值和残差的正交性 This is the central concept of the first slide and
a fundamental property of least squares.</p></li>
<li><p><strong>Concept:</strong> The fitted value vector (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) and the residual vector
(<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>) are <strong>orthogonal</strong>
(perpendicular) to each other.</p></li>
<li><p><strong>Mathematical Statement:</strong> Their dot product is
zero: <span class="math inline">\(\hat{\mathbf{y}}^T(\mathbf{y} -
\hat{\mathbf{y}}) = 0\)</span>.</p></li>
<li><p><strong>Geometric Intuition:</strong> This means the vectors
<span class="math inline">\(\mathbf{y}\)</span>, <span
class="math inline">\(\hat{\mathbf{y}}\)</span>, and <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> form a
<strong>right-angled triangle</strong> in n-dimensional space. The
actual data vector <span class="math inline">\(\mathbf{y}\)</span> is
the hypotenuse, while the model’s prediction <span
class="math inline">\(\hat{\mathbf{y}}\)</span> and the error <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> are the two
perpendicular legs. 这意味着向量 <span
class="math inline">\(\mathbf{y}\)</span>、<span
class="math inline">\(\hat{\mathbf{y}}\)</span> 和 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> 在 n
维空间中构成一个<strong>直角三角形</strong>。实际数据向量 <span
class="math inline">\(\mathbf{y}\)</span> 是斜边，而模型的预测值 <span
class="math inline">\(\hat{\mathbf{y}}\)</span> 和误差值 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>
是两条垂直边。</p></li>
</ul>
<h4 id="the-pythagorean-theorem-of-least-squares">4. The Pythagorean
Theorem of Least Squares</h4>
<p>The orthogonality relationship directly implies the Pythagorean
theorem.</p>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(||\mathbf{y}||^2 = ||\hat{\mathbf{y}}||^2 +
||\mathbf{y} - \hat{\mathbf{y}}||^2\)</span></li>
<li><strong>Concept:</strong> This is one of the most important
equations in statistics, as it partitions the total variance in the
data. 这是统计学中最重要的方程之一，因为它可以分割数据中的总方差。
<ul>
<li><span class="math inline">\(||\mathbf{y}||^2\)</span> is
proportional to the <strong>Total Sum of Squares (TSS):</strong> The
total variation of the response variable around its
mean.响应变量围绕其均值的总变异。</li>
<li><span class="math inline">\(||\hat{\mathbf{y}}||^2\)</span> is
proportional to the <strong>Explained Sum of Squares (ESS):</strong> The
portion of the total variation that is explained by your regression
model.回归模型可以解释的总变异部分。</li>
<li><span class="math inline">\(||\mathbf{y} -
\hat{\mathbf{y}}||^2\)</span> is the <strong>Residual Sum of Squares
(RSS):</strong> The portion of the total variation that is left
unexplained (the error).总变异中未解释的部分（即误差）。</li>
</ul></li>
</ul>
<p>This relationship, <strong>Total Variation = Explained Variation +
Unexplained Variation</strong>, is the foundation for calculating
metrics like <strong>R-squared (<span
class="math inline">\(R^2\)</span>)</strong>, which measures the
goodness of fit of your model. <strong>总变异 = 解释变异 +
未解释变异</strong>，是计算<strong>R 平方 (<span
class="math inline">\(R^2\)</span>)</strong>
等指标的基础，该指标用于衡量模型的拟合优度。</p>
<h4 id="residuals-and-the-identity-matrix-残差和单位矩阵">5. Residuals
and the Identity Matrix 残差和单位矩阵</h4>
<p>Finally, the second slide shows that just as <strong>H</strong>
projects onto the “model space,” a related matrix projects onto the
“error space.” 最后，第二张幻灯片显示，正如<strong>H</strong>
投影到“模型空间”一样，相关矩阵也会投影到“误差空间”。 *
<strong>Process:</strong> We can express the residuals using the hat
matrix: <span class="math display">\[\hat{\boldsymbol{\epsilon}} =
\mathbf{y} - \hat{\mathbf{y}} = \mathbf{y} - \mathbf{H}\mathbf{y} =
(\mathbf{I} - \mathbf{H})\mathbf{y}\]</span> The matrix <span
class="math inline">\((\mathbf{I} - \mathbf{H})\)</span> is also a
projection matrix. It takes the original data vector <span
class="math inline">\(\mathbf{y}\)</span> and projects it onto the space
that is orthogonal to all of your predictors, giving you the residual
vector directly.</p>
<h1
id="visualization-of-ordinary-least-squares-ols-regression">8.visualization
of Ordinary Least Squares (OLS) regression</h1>
<p><img src="/imgs/5054C3/visualization_of_Ordinary_Least_Squares_(OLS)_regression.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This slide provides an excellent geometric visualization of what’s
happening “under the hood” in Ordinary Least Squares (OLS) regression.
It translates the algebraic formulas into a more intuitive spatial
concept. 这张幻灯片以出色的几何可视化方式展现了普通最小二乘 (OLS)
回归的“幕后”机制。它将代数公式转化为更直观的空间概念。</p>
<h3 id="summary-1">## Summary</h3>
<p>The image shows that the process of finding the least squares
estimates is geometrically equivalent to taking the <strong>actual
outcome vector</strong> (<span
class="math inline">\(\mathbf{y}\)</span>) and finding its
<strong>orthogonal projection</strong> (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) onto a
<strong>hyperplane</strong> formed by the predictor variables (<span
class="math inline">\(\mathbf{x}_1\)</span> and <span
class="math inline">\(\mathbf{x}_2\)</span>). The projection <span
class="math inline">\(\hat{\mathbf{y}}\)</span> is the vector of fitted
values, representing the closest possible approximation of the real data
that the model can achieve.</p>
<p>该图显示，寻找最小二乘估计值的过程在几何上等同于将<strong>实际结果向量</strong>
(<span class="math inline">\(\mathbf{y}\)</span>)
求出其<strong>正交投影</strong> (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) 到由预测变量 (<span
class="math inline">\(\mathbf{x}_1\)</span> 和 <span
class="math inline">\(\mathbf{x}_2\)</span>
构成的<strong>超平面</strong>上。投影 <span
class="math inline">\(\hat{\mathbf{y}}\)</span>
是拟合值的向量，表示模型能够达到的与真实数据最接近的近似值。</p>
<h3 id="the-concepts-explained-spatially空间概念解释">## The Concepts
Explained Spatially空间概念解释</h3>
<p>Let’s break down each element of the diagram and its meaning:</p>
<h4 id="the-space-itself-空间本身">1. The Space Itself 空间本身</h4>
<ul>
<li><strong>Concept:</strong> We are not in a simple 2D or 3D graph
where axes are X and Y. Instead, we are in an <strong>n-dimensional
space</strong>, where <strong>n is the number of observations</strong>
in your dataset. Each axis in this space corresponds to one observation
(e.g., one person, one day).
我们并非身处一个简单的二维或三维图形中，其中坐标轴为 X 和
Y。相反，我们身处一个 <strong>n 维空间</strong>，其中 <strong>n
是数据集中的观测值数量</strong>。此空间中的每个轴对应一个观测值（例如，一个人，一天）。</li>
<li><strong>Meaning:</strong> A vector like <strong>y</strong> or
<strong>x₁</strong> is a single point in this high-dimensional space.
For example, if you have 50 data points, <strong>y</strong> is a vector
pointing to a specific location in a 50-dimensional space. 像
<strong>y</strong> 或 <strong>x₁</strong>
这样的向量是这个高维空间中的单个点。例如，如果您有 50
个数据点，<strong>y</strong> 就是指向 50 维空间中特定位置的向量。</li>
</ul>
<h4
id="the-predictor-hyperplane-the-yellow-surface预测变量超平面黄色表面">2.
The Predictor Hyperplane (The Yellow
Surface)预测变量超平面（黄色表面）</h4>
<ul>
<li><strong>Concept:</strong> The vectors for your predictor variables,
<strong>x₁</strong> and <strong>x₂</strong>, define a flat surface. If
you had only one predictor, this would be a line. With two, it’s a
plane. With more, it’s a <strong>hyperplane</strong>.预测变量的向量
<strong>x₁</strong> 和 <strong>x₂</strong>
定义了一个平面。如果只有一个预测变量，它就是一条线。如果有两个，它就是一个平面。如果有更多的预测变量，它就是一个<strong>超平面</strong>。</li>
<li><strong>Meaning:</strong> This yellow plane represents the
<strong>“world of possible predictions”</strong> that your model is
allowed to make. Any linear combination of your predictors—which is what
a linear regression model calculates—will result in a vector that lies
<em>somewhere</em> on this surface.
这个黄色平面代表你的模型可以做出的<strong>“可能预测的世界”</strong>。任何预测变量的线性组合（也就是线性回归模型计算的结果）都会产生一个位于这个平面<em>某处</em>的向量。
#### 3. The Actual Outcome Vector (y)实际结果向量 (y)</li>
<li><strong>Concept:</strong> The red vector <strong>y</strong>
represents your actual, observed data. It’s a single point in the
n-dimensional space. 红色向量 <strong>y</strong>
代表你实际观察到的数据。它是 n 维空间中的一个点。</li>
<li><strong>Meaning:</strong> Critically, this vector usually does
<strong>not</strong> lie on the predictor hyperplane. If it did, your
model would be a perfect fit with zero error. The fact that it’s “off
the plane” represents the real-world noise and variation that the model
cannot fully capture.
至关重要的是，这个向量通常<strong>不</strong>位于预测变量超平面上。如果它位于超平面上，你的模型将完美拟合，误差为零。它“偏离平面”代表了模型无法完全捕捉到的真实世界的噪声和变化。</li>
</ul>
<h4 id="the-fitted-value-vector-ŷ拟合值向量-ŷ">4. The Fitted Value
Vector (ŷ)拟合值向量 (ŷ)</h4>
<ul>
<li><strong>Concept:</strong> Since <strong>y</strong> is not on the
plane, we find the point on the plane that is <strong>geometrically
closest</strong> to <strong>y</strong>. This closest point is found by
dropping a perpendicular line from <strong>y</strong> to the plane. The
point where it lands is the <strong>orthogonal projection</strong>,
labeled <strong>ŷ</strong> (y-hat). 由于 <strong>y</strong>
不在平面上，因此我们在平面上找到与 <strong>y</strong>
<strong>几何上最接近的点。这个最接近点是通过从 </strong>y**
到平面做一条垂直线找到的。垂直线所在的点就是<strong>正交投影</strong>，标记为
<strong>ŷ</strong> (y-hat)。</li>
<li><strong>Meaning:</strong> <strong>ŷ is the vector of your model’s
fitted values.</strong> It is the “best” possible approximation of the
real data that can be created using the given predictors because it
minimizes the distance (and therefore the squared error) between the
actual data (<strong>y</strong>) and the model’s prediction. <strong>ŷ
是模型拟合值的向量。</strong>它是使用给定预测变量可以创建的对真实数据的“最佳”近似值，因为它最小化了实际数据
(<strong>y</strong>)
与模型预测值之间的距离（从而最小化了平方误差）。</li>
</ul>
<h4 id="the-residual-vector-the-dashed-line残差向量虚线">5. The Residual
Vector (The Dashed Line)残差向量（虚线）</h4>
<ul>
<li><strong>Concept:</strong> The dashed line connecting the tip of
<strong>y</strong> to the tip of <strong>ŷ</strong> is the
<strong>residual vector</strong> (<span
class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>). Its length is the shortest possible distance
from <strong>y</strong> to the hyperplane.
连接<strong>y</strong>顶点和<strong>ŷ</strong>顶点的虚线是<strong>残差向量</strong>
(<span class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>)。其长度是从<strong>y</strong>到超平面的最短可能距离。</li>
<li><strong>Meaning:</strong> This vector represents the
<strong>error</strong> of the model—the part of the actual data that is
left over after accounting for the predictors. The right-angle symbol
(└) is the most important part of the diagram, as it shows this error is
<strong>orthogonal</strong> (perpendicular) to the prediction and to all
the predictors. This visualizes the core property that the model’s
errors are uncorrelated with the predictors.
连接<strong>y</strong>顶点和<strong>ŷ</strong>顶点的虚线是<strong>残差向量</strong>
(<span class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>)。其长度是从<strong>y</strong>到超平面的最短可能距离。</li>
</ul>
<h1 id="singular-value-decomposition-svd-奇异值分解-svd">9.Singular
Value Decomposition (SVD) 奇异值分解 (SVD)</h1>
<p><img src="/imgs/5054C3/SVD1.png">
<img src="/imgs/5054C3/SVD2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides delve into the more advanced linear algebra behind the
projection matrix (<strong>H</strong>), explaining its fundamental
properties and offering a new way to construct it using <strong>Singular
Value Decomposition (SVD)</strong>. 探讨了投影矩阵 (<strong>H</strong>)
背后更高级的线性代数，解释了它的基本性质，并提供了一种使用<strong>奇异值分解
(SVD)</strong> 构造它的新方法。</p>
<h3 id="summary-2">## Summary</h3>
<p>These slides show that the <strong>projection matrix (H)</strong>,
which is central to least squares, has two key mathematical properties:
it’s <strong>symmetric</strong> and <strong>idempotent</strong>
(projecting twice is the same as projecting once). These properties
dictate that its eigenvalues must be either 1 or 0. Singular Value
Decomposition (SVD) of the data matrix <strong>X</strong> provides an
elegant and numerically stable way to express <strong>H</strong> as
<strong>UUᵀ</strong>, which makes these fundamental properties easier to
understand and prove. 这些幻灯片展示了<strong>投影矩阵
(H)</strong>（最小二乘法的核心）的两个关键数学性质：<strong>对称</strong>和<strong>幂等</strong>（投影两次等于投影一次）。这些性质决定了它的特征值必须为
1 或 0。数据矩阵 <strong>X</strong> 的奇异值分解 (SVD)
提供了一种优雅且数值稳定的方式，将<strong>H</strong> 表示为
<strong>UUᵀ</strong>，这使得这些基本性质更容易理解和证明。</p>
<h3 id="concepts-and-process-explained-in-detail-1">## Concepts and
Process Explained in Detail</h3>
<h4 id="singular-value-decomposition-svd">1. Singular Value
Decomposition (SVD)</h4>
<p>The first slide introduces SVD, a powerful method for factoring any
matrix.</p>
<ul>
<li><strong>Concept:</strong> SVD breaks down your data matrix
<strong>X</strong> into three simpler matrices: <strong>X =
UDVᵀ</strong>. Think of this as revealing the fundamental structure of
your data.SVD 将数据矩阵 <strong>X</strong>
分解为三个更简单的矩阵：<strong>X =
UDVᵀ</strong>。这可以理解为揭示数据的基本结构。
<ul>
<li><strong>U:</strong> An <strong>orthogonal matrix</strong> whose
columns form a perfect, orthonormal basis for the space spanned by your
predictors (the column space of <strong>X</strong>). These columns
represent the principal directions of your data’s
space.一个<strong>正交矩阵</strong>，其列构成预测变量所占空间（<strong>X</strong>
的列空间）的完美正交基。这些列代表数据空间的主方向。</li>
<li><strong>D:</strong> A <strong>diagonal matrix</strong> containing
the “singular values,” which measure the importance or magnitude of each
of these principal
directions.一个<strong>对角矩阵</strong>，包含“奇异值”，用于衡量每个主方向的重要性或大小。</li>
<li><strong>V:</strong> Another <strong>orthogonal
matrix</strong>.另一个<strong>正交矩阵</strong>。</li>
</ul></li>
<li><strong>Process (How SVD simplifies the Projection Matrix) SVD
如何简化投影矩阵:</strong> The main takeaway from this slide is the new,
simpler formula for the hat matrix: <span
class="math display">\[\mathbf{H} = \mathbf{UU}^T\]</span> This result
is derived by substituting <strong>X = UDVᵀ</strong> into the original,
more complex formula for <strong>H</strong>: <span
class="math display">\[\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\]</span> When you
perform this substitution and use the fact that for orthogonal matrices
<strong>U</strong> and <strong>V</strong>, we have <strong>UᵀU =
I</strong> and <strong>VᵀV = I</strong>, the <strong>D</strong> and
<strong>V</strong> matrices completely cancel out, leaving the
beautifully simple form <strong>H = UUᵀ</strong>. This tells us that
projection is fundamentally about the basis vectors (<strong>U</strong>)
of the predictor space. 执行此代入并利用正交矩阵 <strong>U</strong> 和
<strong>V</strong> 的公式，即 <strong>UᵀU = I</strong> 和 <strong>VᵀV =
I</strong>，<strong>D</strong> 和 <strong>V</strong>
矩阵完全抵消，剩下简洁的形式 <strong>H =
UUᵀ</strong>。这告诉我们，投影本质上是关于预测空间的基向量（<strong>U</strong>）的。</li>
</ul>
<h4 id="the-properties-of-the-projection-matrix-h-投影矩阵-h-的性质">2.
The Properties of the Projection Matrix (H) 投影矩阵 (H) 的性质</h4>
<p>The second slide describes the essential nature of any projection
matrix.</p>
<ul>
<li><p><strong>Symmetric (H = Hᵀ):</strong> This property ensures that
the projection is orthogonal (i.e., it finds the closest point by moving
perpendicularly).
此性质确保投影是正交的（即，它通过垂直移动找到最近的点）。</p></li>
<li><p><strong>Idempotent (H² = H):</strong> This is the most intuitive
property of a projection. 这是投影最直观的性质。</p>
<ul>
<li><strong>Concept:</strong> “Doing it twice is the same as doing it
once.” “两次和一次相同。”</li>
<li><strong>Geometric Meaning:</strong> Imagine you project a point onto
a flat tabletop. That projected point is now <em>on the table</em>. If
you try to project it onto the table <em>again</em>, it doesn’t move.
The projection of a projection is just the projection itself.
Mathematically, this is <strong>H(Hv) = Hv</strong>, which simplifies to
<strong>H² = H</strong>.
想象一下，你将一个点投影到平坦的桌面上。这个投影点现在<em>在桌子上</em>。如果你尝试<em>再次</em>将它投影到桌子上，它不会移动。投影的投影就是投影本身。从数学上讲，这是<strong>H(Hv)
= Hv</strong>，简化为<strong>H² = H</strong>。</li>
</ul></li>
</ul>
<h4 id="eigenvalues-and-eigenspaces-特征值和特征空间">3. Eigenvalues and
Eigenspaces 特征值和特征空间</h4>
<p>The idempotency property has a profound consequence for the matrix’s
eigenvalues.</p>
<ul>
<li><strong>Concept:</strong> The eigenvalues of <strong>H</strong> can
only be <strong>1 or 0</strong>.
<strong>H</strong>的特征值只能是<strong>1</strong>或0**。</li>
<li><strong>Process (The Proof):</strong>
<ol type="1">
<li>Let <strong>v</strong> be an eigenvector of <strong>H</strong> with
eigenvalue <span class="math inline">\(\lambda\)</span>. By definition,
<strong>Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>.
设<strong>v</strong>是<strong>H</strong>的特征向量，其特征值为<span
class="math inline">\(\lambda\)</span>。根据定义，<strong>Hv</strong> =
<span class="math inline">\(\lambda\)</span><strong>v</strong>。</li>
<li>If we apply <strong>H</strong> again, we get <strong>H(Hv)</strong>
= <strong>H</strong>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda\)</span>(<strong>Hv</strong>) = <span
class="math inline">\(\lambda\)</span>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>.
如果我们再次应用<strong>H</strong>，我们得到<strong>H(Hv)</strong> =
<strong>H</strong>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda\)</span>(<strong>Hv</strong>) = <span
class="math inline">\(\lambda\)</span>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>。</li>
<li>So, we have <strong>H²v</strong> = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>.
因此，我们有<strong>H²v</strong> = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>。</li>
<li>But since <strong>H</strong> is idempotent, <strong>H² = H</strong>,
which means <strong>H²v = Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>.
但由于<strong>H</strong>是幂等的，<strong>H² =
H</strong>，这意味着<strong>H²v = Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>。</li>
<li>Therefore, we must have <span
class="math inline">\(\lambda^2\)</span><strong>v</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>, which means
<span class="math inline">\(\lambda^2 = \lambda\)</span>. The only two
numbers in existence that satisfy this equation are <strong>0 and
1</strong>. 因此，我们必须有<span
class="math inline">\(\lambda^2\)</span><strong>v</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>，这意味着<span
class="math inline">\(\lambda^2 =
\lambda\)</span>。满足此等式的仅有两个数字是<strong>0</strong>和<strong>1</strong>。</li>
</ol></li>
<li><strong>Connecting Eigenvalues to the Model
将特征值连接到模型:</strong>
<ul>
<li><p><strong>Eigenvalue = 1:</strong> The eigenvectors associated with
an eigenvalue of 1 are the vectors that <strong>do not change</strong>
when projected. This is only possible if they were already in the space
being projected onto. Therefore, the space <code>L₁</code> is the
<strong>column space of X</strong>—the “model space.” <strong>H</strong>
is the projection onto this space. <strong>与特征值为 1
相关联的特征向量是投影时</strong>不会改变<strong>的向量。只有当它们已经存在于投影到的空间中时，这种情况才有可能发生。因此，空间
<code>L₁</code> 是 X 的</strong>列空间<strong>——“模型空间”。</strong>H**
是到该空间的投影。</p></li>
<li><p><strong>Eigenvalue = 0:</strong> The eigenvectors associated with
an eigenvalue of 0 are the vectors that get sent to the zero vector when
projected. This happens to vectors that are <strong>orthogonal</strong>
to the projection space. Therefore, the space <code>L₀</code> is the
<strong>orthogonal “error” space</strong>. The matrix <strong>I -
H</strong> is the projection onto this space.</p></li>
</ul>
<strong>与特征值为 0
相关联的特征向量是投影时被发送到零向量的向量。这种情况发生在与投影空间</strong>正交<strong>的向量上。因此，空间
<code>L₀</code> 是</strong>正交“误差”空间<strong>。矩阵 </strong>I - H**
是到该空间的投影。</li>
</ul>
<h1 id="statistical-inference-1">10.statistical inference</h1>
<p><img src="/imgs/5054C3/statistical_inference_in_linear_regression1.png">
<img src="/imgs/5054C3/statistical_inference_in_linear_regression2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides cover the theoretical backbone of statistical inference
in linear regression. They explain the necessary assumptions and the
resulting probability distributions of our estimates, which is what
allows us to perform hypothesis tests and create confidence
intervals.</p>
<p>这些幻灯片涵盖了线性回归中统计推断的理论基础。它们解释了必要的假设以及由此得出的估计概率分布，这使我们能够进行假设检验并创建置信区间。</p>
<h3 id="summary-3">## Summary</h3>
<p>These slides lay out the statistical assumptions required for the
Least Squares Estimator (LSE). The core idea is that if we assume the
errors are independent and normally distributed, we can then prove that:
这些幻灯片列出了最小二乘估计量 (LSE)
所需的统计假设。其核心思想是，如果我们假设误差是独立的且服从正态分布，那么我们可以证明：</p>
<ol type="1">
<li><p>Our estimated coefficients (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) also follow a
<strong>Normal distribution</strong> (or a
<strong>t-distribution</strong> when standardized). 我们的估计系数
(<span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>)
也服从<strong>正态分布</strong>（标准化后服从<strong>t
分布</strong>）。</p></li>
<li><p>Our summed-up squared errors (RSS) follow a <strong>Chi-squared
distribution</strong>. 我们的平方误差总和 (RSS)
服从<strong>卡方分布</strong>。</p></li>
<li><p>A specific ratio of the explained variance to the unexplained
variance follows an <strong>F-distribution</strong>, which is used to
test the overall significance of the model.
解释方差与未解释方差的特定比率服从<strong>F
分布</strong>，该分布用于检验模型的整体显著性。</p></li>
</ol>
<p>These known distributions are the foundation for all statistical
inference in linear
models.这些已知的分布是线性模型中所有统计推断的基础。</p>
<h3 id="deeper-dive-into-concepts-and-processes">## Deeper Dive into
Concepts and Processes</h3>
<h4 id="the-model-assumptions-the-foundation-模型假设基础">1. The Model
Assumptions (The Foundation) 模型假设（基础）</h4>
<p>The first slide states the two assumptions that are critical for
everything that follows. Without them, we can’t make claims about the
statistical properties of our estimates.
第一张幻灯片阐述了对后续所有内容都至关重要的两个假设。没有它们，我们就无法断言估计值的统计特性。</p>
<ul>
<li><strong>Assumption 1: <span class="math inline">\(\epsilon_i \sim
N(0, \sigma^2)\)</span></strong>
<ul>
<li><strong>Concept:</strong> This assumes that the error terms (the
part of <code>y</code> that the model can’t explain) are drawn from a
normal (bell-curve) distribution with a mean of zero and a constant
variance <span class="math inline">\(\sigma^2\)</span>.
**假设误差项（模型无法解释的 y
值部分）服从正态（钟形曲线）分布，该分布的均值为零，方差为常数 <span
class="math inline">\(\sigma^2\)</span>。</li>
<li><strong>Meaning in Plain English:</strong>
<ul>
<li><strong>Mean of 0:</strong> The model is “correct on average.” The
errors are not systematically positive or negative.
**模型“平均正确”。误差并非系统地为正或负。</li>
<li><strong>Normal Distribution:</strong> Small errors are more likely
than large errors. This is a common assumption for random noise.
**小误差比大误差更有可能出现。这是随机噪声的常见假设。</li>
<li><strong>Constant Variance (<span
class="math inline">\(\sigma^2\)</span>):</strong> The amount of random
scatter around the regression line is the same at all levels of the
predictor variables. This is called <strong>homoscedasticity</strong>.
回归线周围的随机散度在预测变量的各个水平上都是相同的。这被称为<strong>同方差性</strong>。</li>
</ul></li>
</ul></li>
<li><strong>Assumption 2: Observations are independent</strong>
观测值是独立的**
<ul>
<li><strong>Concept:</strong> Each data point <span
class="math inline">\((x_i, y_i)\)</span> is an independent piece of
information. The value of the error for one observation gives no
information about the error for another observation. 每个数据点 <span
class="math inline">\((x_i, y_i)\)</span>
都是一条独立的信息。一个观测值的误差值并不能反映另一个观测值的误差。</li>
<li><strong>Meaning:</strong> This is often true for cross-sectional
data (e.g., a random sample of people) but can be violated in
time-series data where today’s error might be correlated with
yesterday’s.
这通常适用于横截面数据（例如，随机抽样的人群），但在时间序列数据中可能不成立，因为今天的误差可能与昨天的误差相关。</li>
</ul></li>
</ul>
<h4
id="the-distribution-of-the-coefficients-theorem-of-lse-系数分布最小二乘法定理">2.
The Distribution of the Coefficients (Theorem of LSE)
系数分布（最小二乘法定理）</h4>
<p>This is the most important result for understanding the accuracy of
our individual predictors.</p>
<ul>
<li><strong>Concept 1: The Sampling Distribution of <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span></strong>
<ul>
<li><p><strong>Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}} \sim
N(\boldsymbol{\beta},
\sigma^2(\mathbf{X}^T\mathbf{X})^{-1})\)</span></p></li>
<li><p><strong>Meaning:</strong> If you were to take many different
random samples from the population and calculate the coefficients <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> for each sample,
the distribution of those coefficients would be a multivariate normal
distribution. **如果从总体中随机抽取许多不同的样本，并计算每个样本的系数
<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>，则这些系数的分布将服从多元正态分布。</p>
<ul>
<li>The center of this distribution is the <strong>true population
coefficient vector <span
class="math inline">\(\boldsymbol{\beta}\)</span></strong>. This means
our estimator is <strong>unbiased</strong>—on average, it finds the
right answer. 该分布的中心是<strong>真实的总体系数向量 <span
class="math inline">\(\boldsymbol{\beta}\)</span></strong>。这意味着我们的估计器是<strong>无偏的</strong>——平均而言，它能够找到正确的答案。</li>
<li>The “spread” of this distribution is its variance-covariance matrix,
<span
class="math inline">\(\sigma^2(\mathbf{X}^T\mathbf{X})^{-1}\)</span>.
This tells us the uncertainty in our estimates.
该分布的“散度”是其方差-协方差矩阵</li>
</ul></li>
</ul></li>
<li><strong>Concept 2: The t-statistic</strong> t 统计量
<ul>
<li><strong>Formula:</strong> The standardized coefficient, <span
class="math inline">\(\frac{\hat{\beta}_j -
\beta_j}{\text{s.e.}(\hat{\beta}_j)}\)</span>, follows a
<strong>t-distribution</strong> with <strong><span
class="math inline">\(n-p-1\)</span> degrees of freedom</strong>.</li>
<li><strong>Process &amp; Meaning:</strong> In the real world, we don’t
know the true error variance <span
class="math inline">\(\sigma^2\)</span>. We have to estimate it using
our sample data, which gives us <span
class="math inline">\(s^2\)</span>. Because we are using an
<em>estimate</em> of the variance, we introduce extra uncertainty. The
t-distribution is like a normal distribution but with slightly “fatter”
tails to account for this additional uncertainty. The degrees of
freedom, <span class="math inline">\(n-p-1\)</span>, reflect the number
of data points (<code>n</code>) minus the number of parameters we had to
estimate (<code>p</code> slopes + 1 intercept). This is the basis for
t-tests and confidence intervals for each coefficient.
在现实世界中，我们不知道真实的误差方差 <span
class="math inline">\(\sigma^2\)</span>。我们必须使用样本数据来估计它，从而得到
<span
class="math inline">\(s^2\)</span>。由于我们使用的是方差的<em>估计值</em>，因此引入了额外的不确定性。
t 分布类似于正态分布，但尾部略微“丰满”，以解释这种额外的不确定性。自由度
<span class="math inline">\(n-p-1\)</span>
表示数据点的数量（<code>n</code>）减去我们需要估计的参数数量（<code>p</code>
个斜率 + 1 个截距）。这是 t 检验和每个系数置信区间的基础。</li>
</ul></li>
</ul>
<h4
id="the-distribution-of-the-error-theorem-of-residual-误差分布残差定理">3.
The Distribution of the Error (Theorem of Residual)
误差分布（残差定理）</h4>
<p>This theorem helps us understand the properties of our model’s
overall error.</p>
<ul>
<li><p><strong>Concept:</strong> The <strong>Residual Sum of Squares
(RSS)</strong>, when scaled by the true variance, follows a
<strong>Chi-squared (<span class="math inline">\(\chi^2\)</span>)
distribution</strong> with <span class="math inline">\(n-p-1\)</span>
degrees of freedom. <strong>残差平方和 (RSS)</strong>
经真实方差缩放后，服从自由度为 <span
class="math inline">\(n-p-1\)</span> 的<strong>卡方 (<span
class="math inline">\(\chi^2\)</span>) 分布</strong>。</p></li>
<li><p><strong>Process &amp; Meaning:</strong> The Chi-squared
distribution often arises when dealing with sums of squared normal
variables. This theorem provides a formal probability distribution for
our total model error. Its most important consequence is that it allows
us to prove that:
**卡方分布通常用于处理正态变量的平方和。该定理为我们模型的总体误差提供了一个正式的概率分布。它最重要的推论是，它使我们能够证明：</p>
<p><span class="math display">\[s^2 = \text{RSS}/(n - p - 1)\]</span> is
an <strong>unbiased estimate</strong> of the true error variance <span
class="math inline">\(\sigma^2\)</span>. This <span
class="math inline">\(s^2\)</span> is a critical ingredient for
calculating the standard errors of our coefficients. <span
class="math display">\[s^2 = \text{RSS}/(n - p - 1)\]</span>
是真实误差方差 <span class="math inline">\(\sigma^2\)</span>
的<strong>无偏估计</strong>。这个 <span
class="math inline">\(s^2\)</span>
是计算系数标准误差的关键因素。</p></li>
</ul>
<h4 id="the-f-distribution-and-the-overall-model-test">4. The
F-Distribution and the Overall Model Test</h4>
<p>This final theorem combines our findings about the coefficients and
the residuals.</p>
<ul>
<li><p><strong>Concept:</strong> The F-statistic, which is essentially a
ratio of the variance explained by the model to the variance left
unexplained, follows an <strong>F-distribution</strong>. F
统计量本质上是模型解释的方差与未解释方差的比率，服从 F 分布。</p></li>
<li><p><strong>Process &amp; Meaning:</strong> This result relies on the
fact that our coefficient estimates (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) are independent
of our total error (RSS). The F-distribution is used for the
<strong>F-test of overall significance</strong>. This test checks the
null hypothesis that <em>all</em> of your slope coefficients are
simultaneously zero (<span class="math inline">\(\beta_1 = \beta_2 =
\dots = \beta_p = 0\)</span>). If the F-test gives a small p-value, you
can conclude that your model, as a whole, is statistically significant
and provides a better fit than a model with no predictors. 如果 F
检验得出的 p
值较小，则可以得出结论，您的模型整体上具有统计显著性，并且比没有预测因子的模型拟合效果更好。</p></li>
</ul>
<h1 id="construct-different-types-of-intervals">11.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/construct_different_types_of_intervals1.png">
<img src="/imgs/5054C3/construct_different_types_of_intervals2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides explain how to use the statistical properties of the
least squares estimates to construct different types of intervals, which
are essential for quantifying the uncertainty in your model’s
predictions and parameters.
这些幻灯片解释了如何利用最小二乘估计的统计特性来构建不同类型的区间，这对于量化模型预测和参数中的不确定性至关重要。</p>
<h3 id="summary-4">Summary</h3>
<p>These slides show how to calculate three distinct types of intervals
in linear regression, each answering a different question about
uncertainty:
展示了如何计算线性回归中三种不同类型的区间，每种区间分别回答了关于不确定性的不同问题：</p>
<ol type="1">
<li><strong>Confidence Interval for a Parameter (<span
class="math inline">\(\beta_j\)</span>):</strong> Provides a plausible
range for a single, true unknown coefficient in the model.
为模型中单个真实未知系数提供一个合理的范围。</li>
<li><strong>Confidence Interval for the Mean Response:</strong> Provides
a plausible range for the <em>average</em> outcome for a given set of
predictor values.
为给定一组预测变量值的<em>平均</em>结果提供一个合理的范围。</li>
<li><strong>Prediction Interval:</strong> Provides a plausible range for
a <em>single future</em> outcome for a given set of predictor values.
This interval is always wider than the confidence interval for the mean
response because it must also account for individual random error.
为给定一组预测变量值的<em>单个未来</em>结果提供一个合理的范围。该区间始终比平均响应的置信区间更宽，因为它还必须考虑单个随机误差。</li>
</ol>
<h3 id="deeper-dive-into-concepts-and-processes-1">Deeper Dive into
Concepts and Processes</h3>
<h4
id="confidence-interval-for-a-single-parameter-单个参数的置信区间">1.
Confidence Interval for a Single Parameter 单个参数的置信区间</h4>
<p>This interval addresses the uncertainty around one specific
coefficient, like the slope for your most important predictor.
此区间用于解决围绕某个特定系数的不确定性，例如最重要的预测因子的斜率。</p>
<ul>
<li><strong>The Question It Answers:</strong> “I’ve calculated a slope
of <span class="math inline">\(\hat{\beta}_1 = 10.5\)</span>. How sure
am I about this number? What is a plausible range for the <em>true</em>
population slope?” 我计算出了斜率为 <span
class="math inline">\(\hat{\beta}_1 =
10.5\)</span>。我对这个数字有多确定？<em>真实</em>总体斜率的合理范围是多少？”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\beta}_j \pm t_{n-p-1}(\alpha/2) s
\sqrt{c_{jj}}\)</span>
<ul>
<li><strong><span class="math inline">\(\hat{\beta}_j\)</span></strong>:
This is your best point estimate for the coefficient, taken directly
from the model output. 这是该系数的最佳点估计值，直接取自模型输出。</li>
<li><strong><span
class="math inline">\(t_{n-p-1}(\alpha/2)\)</span></strong>: This is the
<strong>critical value</strong> from a t-distribution. It’s a multiplier
that sets the width of the interval based on your desired confidence
level (e.g., for 95% confidence, <span
class="math inline">\(\alpha=0.05\)</span>). 这是 t
分布的<strong>临界值</strong>。它是一个乘数，根据您所需的置信水平设置区间宽度（例如，对于
95% 的置信度，<span class="math inline">\(\alpha=0.05\)</span>）。</li>
<li><strong><span class="math inline">\(s
\sqrt{c_{jj}}\)</span></strong>: This whole term is the <strong>standard
error</strong> of the coefficient <span
class="math inline">\(\hat{\beta}_j\)</span>. It measures the precision
of your estimate. A smaller standard error means a narrower, more
precise interval. 这整个项是系数 <span
class="math inline">\(\hat{\beta}_j\)</span>
的<strong>标准误差</strong>。它衡量您估计的精度。标准误差越小，区间越窄，精度越高。</li>
</ul></li>
</ul>
<h4 id="confidence-interval-for-the-mean-response-平均响应的置信区间">2.
Confidence Interval for the Mean Response 平均响应的置信区间</h4>
<p>This interval addresses the uncertainty about the location of the
regression line itself. 这个区间解决了回归线本身位置的不确定性。</p>
<ul>
<li><strong>The Question It Answers:</strong> “For a house with 3
bedrooms and 2 bathrooms, what is the plausible range for the
<em>average</em> selling price of <em>all such houses</em>?”
<strong>它回答的问题</strong>：“对于一栋有 3 间卧室和 2
间浴室的房子，<em>所有此类房屋</em>的<em>平均</em>售价的合理范围是多少？”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}}^T \mathbf{x} \pm
t_{n-p-1}(\alpha/2)s\sqrt{\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span>
<ul>
<li><strong><span class="math inline">\(\hat{\boldsymbol{\beta}}^T
\mathbf{x}\)</span></strong>: This is your point prediction, <span
class="math inline">\(\hat{y}\)</span>, for the given input vector
<strong>x</strong>. 这是给定输入向量 <strong>x</strong> 的点预测 <span
class="math inline">\(\hat{y}\)</span>。</li>
<li><strong><span
class="math inline">\(s\sqrt{\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span></strong>:
This is the standard error of the mean response. Its value depends on
how far the input vector <strong>x</strong> is from the center of the
data. This means the confidence interval is narrowest near the average
of your data and gets wider as you move toward the extremes.
这是平均响应的标准误差。其值取决于输入向量 <strong>x</strong>
距离数据中心的距离。这意味着置信区间在数据平均值附近最窄，并且随着接近极值而变宽。</li>
</ul></li>
</ul>
<h4
id="prediction-interval-for-an-individual-response-单个响应的预测区间">3.
Prediction Interval for an Individual Response 单个响应的预测区间</h4>
<p>This is the most comprehensive interval and is often the most useful
for making real-world predictions.
这是最全面的区间，通常对于进行实际预测最有用。</p>
<ul>
<li><strong>The Question It Answers:</strong> “I want to predict the
selling price for <em>one specific house</em> that has 3 bedrooms and 2
bathrooms. What is a plausible price range for this <em>single
house</em>?”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}}^T \mathbf{x} \pm
t_{n-p-1}(\alpha/2)s\sqrt{1 +
\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span></li>
<li><strong>The Key Difference:</strong> Notice the formula is identical
to the one above, except for the <strong><code>1 + ...</code></strong>
inside the square root. This “1” is critically important. It accounts
for the second source of uncertainty.
<strong>请注意，该公式与上面的公式完全相同，只是平方根中的</strong><code>1 + ...</code>**不同。这个“1”至关重要。它解释了第二个不确定性来源。
<ol type="1">
<li><strong>Uncertainty in the model:</strong> We are not perfectly
certain about the true location of the regression line. This is captured
by the <span
class="math inline">\(\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}\)</span>
term. **我们无法完全确定回归线的真实位置。这可以通过 <span
class="math inline">\(\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}\)</span>
项来捕捉。</li>
<li><strong>Uncertainty in the individual data point:</strong> Even if
we knew the true regression line perfectly, individual data points would
still be scattered around it due to random error (<span
class="math inline">\(\epsilon\)</span>). The “1” in the formula
accounts for this irreducible, random error of a single observation.
即使我们完全了解真实的回归线，由于随机误差 (<span
class="math inline">\(\epsilon\)</span>)，单个数据点仍然会散布在其周围。公式中的“1”解释了单个观测值中这种不可约的随机误差。</li>
</ol></li>
</ul>
<p>Because it accounts for both types of uncertainty, the
<strong>prediction interval is always wider than the confidence interval
for the mean</strong>.
由于它同时考虑了两种不确定性，因此<strong>预测区间</strong>总是比均值的置信区间更宽。</p>
<h4 id="the-core-difference-an-analogy-一个类比">The Core Difference: An
Analogy 一个类比</h4>
<ul>
<li><p><strong>Confidence Interval (Mean) 均值置信区间:</strong> Like
predicting the <strong>average</strong> arrival time for a specific
flight that runs every day. After observing it for a year, you can
predict the average very accurately (e.g., 10:05 AM ± 2 minutes).
就像预测每天特定航班的<strong>平均</strong>到达时间。经过一年的观察，您可以非常准确地预测平均值（例如，上午
10:05 ± 2 分钟）。</p></li>
<li><p><strong>Prediction Interval (Individual) 个体预测区间:</strong>
Like predicting the arrival time for that same flight on <strong>one
specific day</strong> next week. You have to account for the uncertainty
in the average <em>plus</em> the potential for random, one-time events
like weather or air traffic delays. Your prediction must be wider to be
safe (e.g., 10:05 AM ± 15 minutes).
就像预测同一航班下周<strong>某一天</strong>的到达时间。您必须考虑平均值的不确定性，以及*可能出现的随机、一次性事件，例如天气或空中交通延误。您的预测范围必须更广才能安全（例如，上午
10:05 ± 15 分钟）。</p></li>
</ul>
<h1 id="construct-different-types-of-intervals-1">12.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/ANOVA1.png">
<img src="/imgs/5054C3/ANOVA2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides explain <strong>Analysis of Variance (ANOVA)</strong>, a
method used in regression to break down the total variability in your
data to test if your model is statistically significant as a
whole.这些幻灯片讲解了<strong>方差分析
(ANOVA)</strong>，这是一种用于回归分析的方法，用于分解数据中的总变异性，以检验模型整体是否具有统计显著性。</p>
<h3 id="summary-5">Summary</h3>
<p>The core idea is to decompose the total variation in the response
variable (<strong>Total Sum of Squares, SS_total</strong>) into two
parts: the variation that is explained by your regression model
(<strong>Regression Sum of Squares, SS_reg</strong>) and the variation
that is left unexplained (<strong>Error Sum of Squares,
SS_error</strong>).
其核心思想是将响应变量的总变异（<strong>总平方和，SS_total</strong>）分解为两部分：回归模型可以解释的变异（<strong>回归平方和，SS_reg</strong>）和未解释的变异（<strong>误差平方和，SS_error</strong>）。</p>
<p>By comparing the size of the explained variation to the unexplained
variation using an <strong>F-statistic</strong>, we can formally test
the hypothesis that our model has predictive power. This entire process
is neatly organized in an <strong>ANOVA table</strong>.
通过使用<strong>F
统计量</strong>比较已解释变异与未解释变异的大小，我们可以正式检验模型具有预测能力的假设。整个过程都整齐地组织在<strong>方差分析表</strong>中。</p>
<h3 id="deeper-dive-into-concepts-and-connections">Deeper Dive into
Concepts and Connections</h3>
<h4
id="the-decomposition-of-variances-the-core-equation-方差分解核心方程">1.
The Decomposition of Variances (The Core Equation)
方差分解（核心方程）</h4>
<p>The first slide starts with the fundamental equation of ANOVA, which
stems directly from the geometric properties of least squares:
第一张幻灯片以方差分析的基本方程开头，该方程直接源于最小二乘的几何性质：</p>
<p><span class="math display">\[SS_{total} = SS_{reg} +
SS_{error}\]</span></p>
<ul>
<li><strong>SS_total (Total Sum of Squares):</strong> <span
class="math inline">\(\sum(y_i - \bar{y})^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>total
variation</strong> in your response variable, <code>y</code>. Imagine
you didn’t have a model and your only prediction for any <code>y</code>
was its overall average, <code>ȳ</code>. SS_total is the total squared
error of this simple “mean-only” model. It represents the total amount
of variation you are trying to explain.
这测量的是响应变量“y”的<strong>总变异</strong>。假设你没有模型，你对任何“y”的唯一预测是它的整体平均值“ȳ”。SS_total
是这个简单的“仅均值”模型的总平方误差。它代表了你试图解释的变异总量。</li>
</ul></li>
<li><strong>SS_reg (Regression Sum of Squares):</strong> <span
class="math inline">\(\sum(\hat{y}_i - \bar{y})^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>explained
variation</strong>. It’s the amount of variation in <code>y</code> that
is captured by your regression model. It calculates the difference
between your model’s predictions (<code>ŷ</code>) and the simple average
(<code>ȳ</code>). A large SS_reg means your model’s predictions are a
big improvement over just guessing the average.
<strong>它衡量</strong>解释变异**。它是回归模型捕捉到的 y
的变异量。它计算模型预测值（“ŷ”）与简单平均值（“ȳ”）之间的差异。较大的
SS_reg 意味着模型的预测结果比仅仅猜测平均值有显著改善。</li>
</ul></li>
<li><strong>SS_error (Error Sum of Squares):</strong> <span
class="math inline">\(\sum(y_i - \hat{y}_i)^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>unexplained
variation</strong> (also called the Residual Sum of Squares). It’s the
amount of variation your model <em>failed</em> to capture. It’s the sum
of the squared differences between the actual data (<code>y</code>) and
your model’s predictions (<code>ŷ</code>).
<strong>它衡量</strong>未解释变异**（也称为残差平方和）。它是模型<em>未能</em>捕捉到的变异量。它是实际数据
(<code>y</code>) 与模型预测值 (<code>ŷ</code>) 之间平方差之和。</li>
</ul></li>
</ul>
<p>The <strong>R-squared</strong> value is a direct consequence of this
decomposition. It’s the proportion of the total variance that is
explained by the model: <strong>R 平方</strong>
值是这种分解的直接结果。它是模型解释的总方差的比例：</p>
<p><span class="math display">\[R^2 =
\frac{SS_{reg}}{SS_{total}}\]</span></p>
<h4 id="the-anova-table-and-the-f-test">2. The ANOVA Table and the
F-test</h4>
<p>方差分析表和 F 检验 The second slide organizes these sums of squares
to perform a formal hypothesis test.
第二张幻灯片整理了这些平方和，以进行正式的假设检验。</p>
<ul>
<li><strong>The Question:</strong> “Is there <em>any</em> relationship
between my set of predictors and the response variable?” or “Is my model
better than nothing?”
“我的预测变量集和响应变量之间是否存在<em>任何</em>关系？”或“我的模型比没有模型好吗？”</li>
<li><strong>The Hypotheses:</strong>
<ul>
<li><strong>Null Hypothesis (<span
class="math inline">\(H_0\)</span>):</strong> <span
class="math inline">\(\beta_1 = \beta_2 = \dots = \beta_p = 0\)</span>.
(None of the predictors have a relationship with the response; the model
is useless). <strong>零假设 (<span
class="math inline">\(H_0\)</span>)</strong>：<span
class="math inline">\(\beta_1 = \beta_2 = \dots = \beta_p = 0\)</span>。
（所有预测变量都与响应变量无关；该模型毫无用处）。</li>
<li><strong>Alternative Hypothesis (<span
class="math inline">\(H_1\)</span>):</strong> At least one <span
class="math inline">\(\beta_j\)</span> is not zero. (The model has some
predictive value). <strong>备择假设 (<span
class="math inline">\(H_1\)</span>)：</strong>至少有一个 <span
class="math inline">\(\beta_j\)</span>
不为零。（该模型具有一定的预测值）。</li>
</ul></li>
</ul>
<p>To test this, we can’t just compare the raw SS values, because they
depend on the number of data points and predictors. We need to normalize
them. 为了验证这一点，我们不能仅仅比较原始的 SS
值，因为它们取决于数据点和预测变量的数量。我们需要对它们进行归一化。</p>
<ul>
<li><strong>Mean Squares (MS):</strong> This is the “average” variation.
We calculate it by dividing the Sum of Squares by its <strong>degrees of
freedom (df)</strong>.
<strong>这是“平均”变异。我们通过将平方和除以其</strong>自由度 (df)**
来计算它。
<ul>
<li><strong>MS_reg</strong> = <span class="math inline">\(SS_{reg} /
p\)</span>. This is the average explained variation <em>per
predictor</em>. 这是<em>每个预测变量</em>的平均解释变异。</li>
<li><strong>MS_error</strong> = <span class="math inline">\(SS_{error} /
(n - p - 1)\)</span>. This is the average unexplained variation, which
is our estimate of the error variance, <span
class="math inline">\(s^2\)</span>. 这是平均未解释变异，即我们对误差方差
<span class="math inline">\(s^2\)</span> 的估计值。</li>
</ul></li>
</ul>
<h4 id="the-connection-the-f-statistic-联系f-统计量">3. The Connection:
The F-statistic 联系：F 统计量</h4>
<p>The <strong>F-statistic</strong> is the key that connects everything.
It’s the ratio of the two mean squares: <strong>F
统计量</strong>是连接一切的关键。它是两个均方的比值： <span
class="math display">\[F = \frac{\text{Mean Squared
Regression}}{\text{Mean Squared Error}} =
\frac{MS_{reg}}{MS_{error}}\]</span></p>
<ul>
<li><strong>Intuitive Meaning:</strong> The F-statistic is a ratio of
the <strong>average explained variation</strong> to the <strong>average
unexplained variation</strong>. F
统计量是<strong>平均解释变异</strong>与<strong>平均未解释变异</strong>的比值。
<ul>
<li>If your model is useless (<span class="math inline">\(H_0\)</span>
is true), the explained variation should be about the same as the
random, unexplained variation. The F-statistic will be close to 1.
如果你的模型无效（H_0$
为真），则解释变异应该与随机的未解释变异大致相同。F 统计量接近 1。</li>
<li>If your model is useful (<span class="math inline">\(H_1\)</span> is
true), the explained variation should be significantly larger than the
unexplained variation. The F-statistic will be much greater than 1.
如果你的模型有效（H_1$ 为真），则解释变异应该显著大于未解释变异。 F
统计量将远大于 1。</li>
</ul></li>
</ul>
<p>We compare our calculated F-statistic to an
<strong>F-distribution</strong> to get a <strong>p-value</strong>. A
small p-value (&lt; 0.05) provides strong evidence to reject the null
hypothesis and conclude that your model, as a whole, is statistically
significant. 我们将计算出的 F 统计量与<strong>F
分布</strong>进行比较，得出<strong>p 值</strong>。较小的 p 值（&lt;
0.05）可以提供强有力的证据来拒绝零假设，并得出您的模型整体具有统计显著性的结论。</p>
<h1 id="construct-different-types-of-intervals-2">12.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/Gauss_Markov1.png">
<img src="/imgs/5054C3/Gauss_Markov2.png"></p>
<ul>
<li><strong>内容</strong>: These slides explain the <strong>Gauss-Markov
theorem</strong>, a cornerstone result in statistics that establishes
why the Least Squares Estimator (LSE) is considered the gold standard
for fitting linear models under a specific set of assumptions.
这些幻灯片解释了<strong>高斯-马尔可夫定理</strong>，这是统计学中的一个基石性成果，它阐明了为什么最小二乘估计量
(LSE) 被认为是在特定假设条件下拟合线性模型的黄金标准。</li>
</ul>
<h3 id="summary-6">Summary</h3>
<p>The slides argue for the superiority of the Least Squares Estimator
(LSE) by highlighting its key properties: it’s easy to compute,
consistent, and efficient. This culminates in the <strong>Gauss-Markov
Theorem</strong>, which proves that LSE is <strong>BLUE</strong>: the
<strong>B</strong>est <strong>L</strong>inear <strong>U</strong>nbiased
<strong>E</strong>stimator. This means that among all estimators that
are both linear and unbiased, the LSE is the “best” because it has the
smallest possible variance, making it the most precise. The second slide
provides the key steps for the mathematical proof of this important
theorem. 这些幻灯片通过强调最小二乘估计量 (LSE)
的关键特性来论证其优越性：易于计算、一致性高且高效。最终得出了<strong>高斯-马尔可夫定理</strong>，该定理证明了
LSE
是<strong>BLUE</strong>：<strong>最佳</strong>线性<strong>无偏</strong>估计量。这意味着在所有线性且无偏的估计量中，LSE
是“最佳”的，因为它具有最小的方差，因此精度最高。第二张幻灯片提供了这一重要定理的数学证明的关键步骤。</p>
<h3 id="deeper-dive-into-the-concepts">Deeper Dive into the
Concepts</h3>
<h4 id="properties-of-lse-slide-1-局部正交估计-lse-的性质">Properties of
LSE (Slide 1) 局部正交估计 (LSE) 的性质</h4>
<ul>
<li><strong>Easy Computation易于计算:</strong> The LSE has a direct,
closed-form solution called the Normal Equation (<span
class="math inline">\(\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\)</span>). You can
calculate it directly without needing complex iterative algorithms.</li>
<li><strong>Consistency一致性:</strong> As your sample size gets larger
and larger, the LSE estimate (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) is guaranteed
to get closer and closer to the true population value (<span
class="math inline">\(\boldsymbol{\beta}\)</span>). With enough data, it
will find the truth. 随着样本量越来越大，LSE 估计值 (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>)
必然会越来越接近真实的总体值 (<span
class="math inline">\(\boldsymbol{\beta}\)</span>)。只要有足够的数据，它就能找到真相。</li>
<li><strong>Efficiency效率:</strong> An efficient estimator is the one
with the lowest possible variance. This means its estimates are the most
precise and least spread out.
高效的估计器是方差尽可能低的估计器。这意味着它的估计值最精确，且分布最均匀。</li>
<li><strong>BLUE (Best Linear Unbiased
Estimator)BLUE（最佳线性无偏估计器）:</strong> This acronym elegantly
summarizes the Gauss-Markov theorem.
这个缩写完美地概括了高斯-马尔可夫定理。
<ul>
<li><strong>Linear:</strong> The estimator is a linear function of the
response variable <strong>y</strong>. We can write it as <span
class="math inline">\(\hat{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span> for some matrix <strong>A</strong>.
估计器是响应变量<strong>y</strong>的线性函数。对于某个矩阵<strong>A</strong>，我们可以将其写成
<span class="math inline">\(\hat{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>。</li>
<li><strong>Unbiased:</strong> The estimator does not systematically
overestimate or underestimate the true parameter. On average, its
expected value is the true value: <span
class="math inline">\(E[\hat{\boldsymbol{\beta}}] =
\boldsymbol{\beta}\)</span>.
估计器不会系统性地高估或低估真实参数。平均而言，其预期值即为真实值：<span
class="math inline">\(E[\hat{\boldsymbol{\beta}}] =
\boldsymbol{\beta}\)</span>。</li>
<li><strong>Best:</strong> It has the <strong>minimum variance</strong>
of all possible linear unbiased estimators. It’s the most precise and
reliable estimator in its class.
在所有可能的线性无偏估计器中，它的<strong>方差</strong>最小。它是同类中最精确、最可靠的估计器。</li>
</ul></li>
</ul>
<h4 id="the-gauss-markov-theorem-高斯-马尔可夫定理">The Gauss-Markov
Theorem 高斯-马尔可夫定理</h4>
<p>The theorem provides the theoretical justification for using OLS.
该定理为使用最小二乘法 (OLS) 提供了理论依据。 * <strong>The Core
Idea:</strong> You could invent many different ways to estimate the
coefficients of a linear model. As long as your proposed methods are
both linear and unbiased, the Gauss-Markov theorem guarantees that none
of them will be more precise than the standard least squares method. LSE
gives the “sharpest” possible estimates.
你可以发明许多不同的方法来估计线性模型的系数。只要你提出的方法是线性的且无偏的，高斯-马尔可夫定理就能保证，它们都不会比标准最小二乘法更精确。最小二乘法
(LSE) 给出了“最精确”的估计值。</p>
<ul>
<li><strong>The Logic of the Proof (Slide 2) 证明逻辑:</strong> The
proof is a clever comparison of variances. **该证明巧妙地比较了方差。
<ol type="1">
<li>It starts by defining <strong>any</strong> other linear unbiased
estimator as <span class="math inline">\(\tilde{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>.
首先，将<strong>任何</strong>其他线性无偏估计量定义为 <span
class="math inline">\(\tilde{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>。</li>
<li>It uses the “unbiased” property to force a condition on the matrix
<strong>A</strong>, which ultimately leads to the insight that
<strong>A</strong> can be written in terms of the LSE matrix plus some
other matrix <strong>D</strong>, where <strong>DX = 0</strong>.
它利用“无偏”性质对矩阵<strong>A</strong>强制施加一个条件，最终得出<strong>A</strong>可以写成LSE矩阵加上另一个矩阵<strong>D</strong>，其中<strong>DX
= 0</strong>。</li>
<li>It then calculates the variance of this other estimator, which turns
out to be: <span class="math display">\[Var(\tilde{\boldsymbol{\beta}})
= Var(\text{LSE}) + \text{a non-negative term involving }
\mathbf{D}\]</span> 然后计算另一个估计量的方差，结果为： <span
class="math display">\[Var(\tilde{\boldsymbol{\beta}}) = Var(\text{LSE})
+ \text{一个包含 } \mathbf{D} 的非负项\]</span></li>
<li>Since the variance of any other linear unbiased estimator is the
variance of the LSE <em>plus</em> something non-negative, the variance
of the LSE must be the smallest possible value.
由于任何其他线性无偏估计量的方差都是LSE的方差<em>加上</em>一个非负项，因此LSE的方差必须是最小的可能值。</li>
</ol></li>
</ul>
<h3 id="further-understandings-beyond-the-slides">Further Understandings
Beyond the Slides</h3>
<h4 id="what-are-the-required-assumptions需要哪些假设">1. What are the
required assumptions?需要哪些假设？</h4>
<p>The Gauss-Markov theorem is powerful, but it’s not magic. It only
holds if a set of assumptions about the model’s errors (<span
class="math inline">\(\epsilon\)</span>) are met:
高斯-马尔可夫定理虽然强大，但并非魔法。它仅在满足以下关于模型误差 (<span
class="math inline">\(\epsilon\)</span>) 的假设时成立： * <strong>Zero
Mean零均值:</strong> The average of the errors is zero (<span
class="math inline">\(E[\epsilon] = 0\)</span>). 误差的平均值为零 (<span
class="math inline">\(E[\epsilon] = 0\)</span>)。 * <strong>Constant
Variance (Homoscedasticity)恒定方差（同方差性）:</strong> The errors
have the same variance, <span class="math inline">\(\sigma^2\)</span>,
at all levels of the predictors.
<strong>在预测变量的各个水平上，误差具有相同的方差 <span
class="math inline">\(\sigma^2\)</span>。 * </strong>Uncorrelated
Errors不相关误差:** The error for one observation is not correlated with
the error for another. 一个观测值的误差与另一个观测值的误差不相关。 *
<strong>No Perfect Multicollinearity非完全多重共线性:</strong> The
predictor variables are not perfectly linearly related.
预测变量并非完全线性相关。</p>
<p><strong>Crucially, the Gauss-Markov theorem does NOT require the
errors to be normally distributed.</strong> The normality assumption is
only needed later for constructing confidence intervals and conducting
t-tests and F-tests.
至关重要的是，高斯-马尔可夫定理并不要求误差服从正态分布。**正态性假设仅在构建置信区间以及进行
t 检验和 F 检验时需要。</p>
<h4
id="when-is-lse-not-the-best-the-bias-variance-tradeoff-什么时候-lse-不是最佳选择-偏差-方差权衡">2.
When is LSE NOT the Best? (The Bias-Variance Tradeoff) 什么时候 LSE
不是最佳选择？ （偏差-方差权衡）</h4>
<p>While LSE is the best <em>unbiased</em> estimator, sometimes we can
get better predictive performance by accepting a little bit of bias in
exchange for a large reduction in variance. This is the core idea behind
modern regularization methods: 虽然 LSE
是最好的<em>无偏</em>估计器，但有时我们可以通过接受少量偏差来大幅降低方差，从而获得更好的预测性能。这是现代正则化方法背后的核心思想：
* <strong>Ridge Regression and LASSO岭回归和 LASSO:</strong> These are
popular techniques that produce <em>biased</em> estimates of the
coefficients. However, by introducing this small amount of bias, they
can often produce models with a lower overall error (Mean Squared Error)
than LSE, especially when predictors are highly correlated.
这些是产生<em>有偏</em>系数估计的流行技术。然而，通过引入少量偏差，它们通常可以生成比
LSE
具有更低总体误差（均方误差）的模型，尤其是在预测变量高度相关的情况下。
Therefore, while LSE is the theoretical champion in the world of
unbiased estimators, in the world of predictive modeling, methods that
intentionally introduce bias can sometimes be superior. 因此，虽然 LSE
是无偏估计领域的理论冠军，但在预测模型领域，有意引入偏差的方法有时会更胜一筹。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
