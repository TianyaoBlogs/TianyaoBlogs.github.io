<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tianyaoblogs.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="TianyaoBlogs">
<meta property="og:url" content="https://tianyaoblogs.github.io/index.html">
<meta property="og:site_name" content="TianyaoBlogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tianyaoblogs.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TianyaoBlogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TianyaoBlogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/26/5120C4-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/26/5120C4-2/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W3-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-26 21:00:00 / 修改时间：19:17:02" itemprop="dateCreated datePublished" datetime="2025-09-26T21:00:00+08:00">2025-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-4</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="monte-carlo-mc-method">1 Monte Carlo (MC) Method:</h2>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This whiteboard provides a concise but detailed overview of two
important and related simulation techniques in computational physics and
chemistry: the Metropolis Monte Carlo (MC) method and Hamiltonian (or
Hybrid) Monte Carlo (HMC). Here is a detailed breakdown of the concepts
presented.</p>
<h3 id="metropolis-monte-carlo-mc-method">1. Metropolis Monte Carlo (MC)
Method</h3>
<p>The heading “Metropolis MC method” introduces a foundational
algorithm in statistical mechanics. Metropolis Monte Carlo is a method
used to generate a sequence of states for a system, allowing for the
calculation of average properties.</p>
<ul>
<li><strong>Conceptual Diagram:</strong> The small box with numbered
sites (0-5) and an arrow showing a move from state 0 to 2, and then to
3, illustrates a “random walk.” In Metropolis MC, the system transitions
from one state to another by making small, random changes.</li>
<li><strong>Random Number Generation:</strong> The notation
<code>rand t \in (0,1)</code> indicates the use of a random number <span
class="math inline">\(t\)</span> drawn from a uniform distribution
between 0 and 1. This is a core component of the algorithm, used to
decide whether to accept or reject a proposed new state.</li>
<li><strong>Detailed Balance Condition:</strong> The equation <span
class="math inline">\(P_o T(o \to n) = P_n T(n \to o)\)</span> is the
principle of detailed balance. It states that in a system at
equilibrium, the probability of being in an old state (<span
class="math inline">\(o\)</span>) and transitioning to a new state
(<span class="math inline">\(n\)</span>) is equal to the probability of
being in the new state and transitioning back to the old one. This
condition is crucial because it ensures that the simulation will
eventually sample states according to their correct thermodynamic
probabilities (the Boltzmann distribution).</li>
<li><strong>Acceptance Rate:</strong> The note <code>\sim 30\%?</code>
likely refers to the target <strong>acceptance rate</strong> for an
efficient Metropolis MC simulation. If new states are accepted too often
or too rarely, the exploration of the system’s possible configurations
is inefficient. While the famous optimal acceptance rate for certain
high-dimensional problems is around 23.4%, a range of 20-50% is often
considered effective.</li>
</ul>
<h3 id="hamiltonian-hybrid-monte-carlo-hmc">2. Hamiltonian / Hybrid
Monte Carlo (HMC)</h3>
<p>The second topic, “Hamiltonian/Hybrid MC (HMC),” is a more advanced
Monte Carlo method that uses principles from classical mechanics to
propose new states more intelligently than the simple random-walk
approach of the standard Metropolis method. This often leads to a much
higher acceptance rate and more efficient exploration of the state
space.</p>
<p>The whiteboard outlines a four-step HMC algorithm:</p>
<p><strong>Step 1: Randomize Velocities</strong> The first step is to
randomize the velocities: <span class="math inline">\(\vec{v}_i \sim
\mathcal{N}(0, k_B T)\)</span>.</p>
<ul>
<li>This step introduces momentum into the system. For each particle
<span class="math inline">\(i\)</span>, a velocity vector <span
class="math inline">\(\vec{v}_i\)</span> is randomly drawn from a normal
(Gaussian) distribution with a mean of 0 and a variance related to the
temperature <span class="math inline">\(T\)</span> and the Boltzmann
constant <span class="math inline">\(k_B\)</span>.</li>
<li>The full formula for this probability distribution, <span
class="math inline">\(f(\vec{v})\)</span>, is the
<strong>Maxwell-Boltzmann distribution</strong>, which is written out
further down the board.</li>
</ul>
<p><strong>Step 2: Molecular Dynamics (MD) Integration</strong> The
board notes this as <code>t=0 \to h \text&#123; or &#125; mh</code>
<code>MD</code> and mentions the <code>Verlet</code> algorithm.</p>
<ul>
<li>This is the “Hamiltonian dynamics” part of the algorithm. Starting
from the current positions and the newly randomized velocities, the
system’s trajectory is calculated for a short period of time (<span
class="math inline">\(h\)</span> or <span
class="math inline">\(mh\)</span>) using Molecular Dynamics (MD).</li>
<li>The name <strong>Verlet</strong> refers to the Verlet integration
algorithm, a numerical method used to solve Newton’s equations of
motion. It is popular in MD simulations because it is time-reversible
and conserves energy well over long simulations.</li>
</ul>
<p><strong>Step 3: Calculate Total Energy</strong> The third step is to
<code>calculate total energy</code>: <span class="math inline">\(E_n =
K_n + V_n\)</span>.</p>
<ul>
<li>After the MD trajectory, the system is in a new state <span
class="math inline">\(n\)</span>. The total energy of this new state,
<span class="math inline">\(E_n\)</span>, is calculated as the sum of
its kinetic energy (<span class="math inline">\(K_n\)</span>, from the
velocities) and its potential energy (<span
class="math inline">\(V_n\)</span>, from the positions).</li>
</ul>
<p><strong>Step 4: Acceptance Test</strong> The final step is the
acceptance criterion: <span class="math inline">\(\text{acc}(o \to n) =
\min(1, e^{-\beta(E_n - E_o)})\)</span>.</p>
<ul>
<li>This is the Metropolis acceptance criterion. The algorithm decides
whether to accept the new state <span class="math inline">\(n\)</span>
or reject it and stay in the old state <span
class="math inline">\(o\)</span>.</li>
<li>The probability of acceptance depends on the change in total energy
(<span class="math inline">\(E_n - E_o\)</span>). If the new energy is
lower, the move is always accepted. If the new energy is higher, it
might still be accepted with a probability <span
class="math inline">\(e^{-\beta(E_n - E_o)}\)</span>, where <span
class="math inline">\(\beta = 1/(k_B T)\)</span>. This allows the system
to escape from local energy minima.</li>
</ul>
<h3 id="key-formulas-and-notations">Key Formulas and Notations</h3>
<ul>
<li><p><strong>Maxwell-Boltzmann Distribution:</strong> The formula for
the velocity distribution is given as: <span
class="math inline">\(f(\vec{v}) = \left(\frac{m}{2\pi k_B
T}\right)^{3/2} \exp\left(-\frac{m v^2}{2 k_B T}\right)\)</span> This
gives the probability density for a particle of mass <span
class="math inline">\(m\)</span> to have a velocity <span
class="math inline">\(\vec{v}\)</span> at a given temperature <span
class="math inline">\(T\)</span>.</p></li>
<li><p><strong>Energy Conservation and Acceptance Rate:</strong> The
notes <span class="math inline">\(E_n \approx E_o\)</span> and <span
class="math inline">\(75\%\)</span> highlight a key advantage of HMC.
Because the Verlet integrator approximately conserves energy, the final
energy <span class="math inline">\(E_n\)</span> after the MD trajectory
is usually very close to the initial energy <span
class="math inline">\(E_o\)</span>. This means the term <span
class="math inline">\((E_n - E_o)\)</span> is small, and the acceptance
probability is high. The <span class="math inline">\(75\%\)</span>
indicates a typical or target acceptance rate for HMC, which is
significantly higher than for standard Metropolis MC.</p></li>
<li><p><strong>Hamiltonian Operator:</strong> The symbol <span
class="math inline">\(\hat{H}\)</span> written on the adjacent board
represents the Hamiltonian operator, which gives the total energy of the
system. The note <code>Δ Adiabatic</code> suggests that the MD evolution
is ideally an adiabatic process (no heat exchange), during which the
total energy (the Hamiltonian) is conserved.</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/18/img_assert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/18/img_assert/" class="post-title-link" itemprop="url">BLOGS - IMG Assert</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-18 10:00:00" itemprop="dateCreated datePublished" datetime="2025-09-18T10:00:00+08:00">2025-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:51" itemprop="dateModified" datetime="2025-09-19T19:24:51+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题主要为了图像不显示问题">【问题】主要为了图像不显示问题</h2>
<h3 id="step1根目录中的配置文件">Step1:根目录中的配置文件</h3>
<h3 id="step2将-markdown-行替换为html-代码">Step2:将 Markdown
行替换为HTML 代码</h3>
<h3 id="step3设置下方添加root">Step3:设置下方添加ROOT</h3>
<h3
id="step4不需要此插件终端中运行以下命令来卸载插件">Step4:不需要此插件终端中运行以下命令来卸载插件：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line">$ url: https://TianyaoBlogs.github.io/</span><br><span class="line"></span><br><span class="line">$ root: /</span><br><span class="line"></span><br><span class="line">$ permalink: :year/:month/:day/:title/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;img src=<span class="string">&quot;/imgs/5054C3/General_linear_regression_model.png&quot;</span> alt=<span class="string">&quot;A diagram of the general linear regression model&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-asset-image</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/17/5120C3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/17/5120C3/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W3-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-17 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-17T21:00:00+08:00">2025-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 20:28:09" itemprop="dateModified" datetime="2025-09-19T20:28:09+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="radial-distribution-function">1 radial distribution
function:</h2>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This whiteboard explains the process of calculating the
<strong>radial distribution function</strong>, often denoted as <span
class="math inline">\(g(r)\)</span>, to analyze the atomic structure of
a material, which is referred to here as a “film”.
本白板解释了计算<strong>径向分布函数</strong>（通常表示为 <span
class="math inline">\(g(r)\)</span>）的过程，用于分析材料（本文中称为“薄膜”）的原子结构。</p>
<p>In simple terms, the radial distribution function tells you the
probability of finding an atom at a certain distance from another
reference atom. It’s a powerful way to see the local structure in a
disordered system like a liquid or an amorphous solid.</p>
<p>简单来说，径向分布函数表示在距离另一个参考原子一定距离处找到一个原子的概率。它是观察无序系统（例如液体或非晶态固体）局部结构的有效方法。</p>
<h3 id="core-concept-radial-distribution-function-径向分布函数">## Core
Concept: Radial Distribution Function 径向分布函数</h3>
<p>The main goal is to compute the radial distribution function, <span
class="math inline">\(g(r)\)</span>, which is defined as the ratio of
the actual number of atoms found in a thin shell at a distance <span
class="math inline">\(r\)</span> to the number of atoms you’d expect to
find if the material were an ideal gas (completely random).
主要目标是计算径向分布函数 <span
class="math inline">\(g(r)\)</span>，其定义为在距离 <span
class="math inline">\(r\)</span>
的薄壳层中实际发现的原子数与材料为理想气体（完全随机）时预期发现的原子数之比。</p>
<p>The formula is expressed as: <span class="math display">\[g(r)dr =
\frac{n(r)}{\text{ideal gas}}\]</span></p>
<ul>
<li><strong><span class="math inline">\(n(r)\)</span></strong>:
Represents the average number of atoms found in a thin spherical shell
between a distance <span class="math inline">\(r\)</span> and <span
class="math inline">\(r+dr\)</span> from a central atom.
表示距离中心原子 <span class="math inline">\(r\)</span> 到 <span
class="math inline">\(r+dr\)</span> 之间的薄球壳中原子的平均数量。</li>
<li><strong>ideal gas</strong>: Represents the number of atoms you would
expect in that same shell if the atoms were distributed completely
randomly with the same average density (<span
class="math inline">\(\rho\)</span>). The volume of this shell is
approximately <span class="math inline">\(4\pi r^2
dr\)</span>.表示如果原子完全随机分布且平均密度 (<span
class="math inline">\(\rho\)</span>)
相同，则该球壳中原子的数量。该球壳的体积约为 <span
class="math inline">\(4\pi r^2 dr\)</span>。</li>
</ul>
<p>A peak in the <span class="math inline">\(g(r)\)</span> plot
indicates a high probability of finding neighboring atoms at that
specific distance, revealing the material’s structural shells (e.g.,
nearest neighbors, second-nearest neighbors, etc.).<span
class="math inline">\(g(r)\)</span>
图中的峰值表示在该特定距离处找到相邻原子的概率很高，从而揭示了材料的结构壳（例如，最近邻、次近邻等）。</p>
<h3 id="calculation-method">## Calculation Method</h3>
<p>The board outlines a two-step averaging process to get a
statistically meaningful result from simulation data (a “film” at 20
frames per second).</p>
<ol type="1">
<li><p><strong>Average over atoms:</strong> In a single frame (a
snapshot in time), you pick one atom as the center. Then, you count how
many other atoms (<span class="math inline">\(n(r)\)</span>) are in
concentric spherical shells around it. This process is repeated,
treating each atom in the frame as the center, and the results are
averaged.</p></li>
<li><p><strong>Average over frames:</strong> The entire process
described above is repeated for multiple frames from the simulation or
video. This time-averaging ensures that the final result represents the
typical structure of the material over time, smoothing out random
fluctuations.</p></li>
</ol>
<p>The board notes “dx = bin width 0.01Å”, which is a practical detail
for the calculation. To create a histogram, the distance <code>r</code>
is divided into small segments (bins) of 0.01 angstroms.</p>
<h3 id="connection-to-experiments">## Connection to Experiments</h3>
<p>Finally, the whiteboard mentions <strong>“frame X-ray
scattering”</strong>. This is a crucial point because it connects this
computational analysis to real-world experiments. Experimental
techniques like X-ray or neutron scattering can be used to measure a
quantity called the structure factor, <span
class="math inline">\(S(q)\)</span>, which is directly related to the
radial distribution function <span class="math inline">\(g(r)\)</span>
through a mathematical operation called a Fourier transform. This allows
scientists to directly compare the structure produced in their
simulations with the structure of a real material measured in a lab.
最后，白板上提到了<strong>“帧 X
射线散射”</strong>。这一点至关重要，因为它将计算分析与实际实验联系起来。X射线或中子散射等实验技术可以用来测量一个称为结构因子<span
class="math inline">\(S(q)\)</span>的量，该量通过傅里叶变换的数学运算与径向分布函数<span
class="math inline">\(g(r)\)</span>直接相关。这使得科学家能够直接将模拟中产生的结构与实验室测量的真实材料结构进行比较。</p>
<p>The board correctly links <span class="math inline">\(g(r)\)</span>
to X-ray scattering experiments. The quantity measured in these
experiments is the <strong>static structure factor</strong>, <span
class="math inline">\(S(q)\)</span>, which describes how the material
scatters radiation. The relationship between the two is a Fourier
transform: 该板正确地将<span
class="math inline">\(g(r)\)</span>与X射线散射实验联系起来。这些实验中测量的量是<strong>静态结构因子</strong><span
class="math inline">\(S(q)\)</span>，它描述了材料如何散射辐射。两者之间的关系是傅里叶变换：
<span class="math display">\[S(q) = 1 + 4 \pi \rho \int_0^\infty [g(r) -
1] r^2 \frac{\sin(qr)}{qr} dr\]</span> This equation is crucial because
it bridges the gap between computer simulations (which calculate <span
class="math inline">\(g(r)\)</span>) and physical experiments (which
measure <span class="math inline">\(S(q)\)</span>).
这个方程至关重要，因为它弥合了计算机模拟（计算 <span
class="math inline">\(g(r)\)</span>）和物理实验（测量 <span
class="math inline">\(S(q)\)</span>）之间的差距。</p>
<h3
id="the-gaussian-distribution-probability-of-particle-position-高斯分布粒子位置的概率">##
2. The Gaussian Distribution: Probability of Particle Position
高斯分布：粒子位置的概率</h3>
<p>The board starts with the formula for a one-dimensional
<strong>Gaussian (or normal) distribution</strong>:
白板首先展示的是一维<strong>高斯（或正态）分布</strong>的公式：</p>
<p><span class="math display">\[f(x | \mu, \sigma^2) =
\frac{1}{\sqrt{2\pi\sigma^2}}
\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\]</span></p>
<p>This equation describes the probability of finding a particle at a
specific position <code>x</code> after a certain amount of time has
passed. * <strong><span class="math inline">\(\mu\)</span> (mu)</strong>
is the <strong>mean</strong> or average position. For a simple diffusion
process starting at the origin, the particles spread out symmetrically,
so the average position remains at the origin (<span
class="math inline">\(\mu = 0\)</span>). * <strong><span
class="math inline">\(\sigma^2\)</span> (sigma squared)</strong> is the
<strong>variance</strong>, which measures how spread out the particles
are from the mean position. A larger variance means the particles have,
on average, traveled farther from the starting point.
这个方程描述了经过一定时间后，在特定位置“x”找到粒子的概率。 *
<strong><span class="math inline">\(\mu\)</span> (mu)</strong>
是<strong>平均值</strong>或平均位置。对于从原点开始的简单扩散过程，粒子对称扩散，因此平均位置保持在原点（<span
class="math inline">\(\mu = 0\)</span>）。 * <strong><span
class="math inline">\(\sigma^2\)</span>（sigma 平方）</strong>
是<strong>方差</strong>，用​​于衡量粒子与平均位置的扩散程度。方差越大，意味着粒子平均距离起点越远。</p>
<p>The note “Black-Scholes” is a side reference. The Black-Scholes
model, famous in financial mathematics for pricing options, uses similar
mathematical principles based on Brownian motion to model the random
fluctuations of stock prices. “Black-Scholes”注释仅供参考。Black-Scholes
模型在金融数学中以期权定价而闻名，它使用基于布朗运动的类似数学原理来模拟股票价格的随机波动。</p>
<h3
id="mean-squared-displacement-msd-quantifying-the-spread-均方位移-msd量化扩散">##
3. Mean Squared Displacement (MSD): Quantifying the Spread 均方位移
(MSD)：量化扩散</h3>
<p>The core of the board is dedicated to the <strong>Mean Squared
Displacement (MSD)</strong>. This is the primary tool used to measure
how far, on average, particles have moved over a time interval
<code>t</code>. 本版块的核心内容是<strong>均方位移
(MSD)</strong>。这是用于测量粒子在时间间隔“t”内平均移动距离的主要工具。</p>
<p>The variance <span class="math inline">\(\sigma^2\)</span> is
formally defined as the average of the squared deviations from the mean:
<span class="math display">\[\sigma^2 = \langle x^2(t) \rangle - \langle
x(t) \rangle^2\]</span> * <span class="math inline">\(\langle x(t)
\rangle\)</span> is the average displacement. As mentioned, for simple
diffusion, <span class="math inline">\(\langle x(t) \rangle =
0\)</span>. * <span class="math inline">\(\langle x^2(t)
\rangle\)</span> is the average of the <em>square</em> of the
displacement. 方差<span
class="math inline">\(\sigma^2\)</span>的正式定义为与平均值偏差平方的平均值：
<span class="math display">\[\sigma^2 = \langle x^2(t) \rangle - \langle
x(t) \rangle^2\]</span> * <span class="math inline">\(\langle x(t)
\rangle\)</span>是平均位移。如上所述，对于简单扩散，<span
class="math inline">\(\langle x(t) \rangle = 0\)</span>。 * <span
class="math inline">\(\langle x^2(t)
\rangle\)</span>是位移<em>平方</em>的平均值。</p>
<p>Since <span class="math inline">\(\langle x(t) \rangle = 0\)</span>,
the variance is simply equal to the MSD: <span
class="math display">\[\sigma^2 = \langle x^2(t) \rangle\]</span> 由于
<span class="math inline">\(\langle x(t) \rangle =
0\)</span>，方差等于均方差 (MSD)： <span class="math display">\[\sigma^2
= \langle x^2(t) \rangle\]</span></p>
<p>The crucial insight for a diffusive process is that the <strong>MSD
grows linearly with time</strong>. The rate of this growth is determined
by the <strong>diffusion coefficient, D</strong>. The board shows this
relationship for different dimensions: 扩散过程的关键在于<strong>MSD
随时间线性增长</strong>。其增长率由<strong>扩散系数
D</strong>决定。棋盘显示了不同维度下的这种关系：</p>
<ul>
<li><strong>1D:</strong> <span class="math inline">\(\langle x^2(t)
\rangle = 2Dt\)</span> (Movement along a line) （沿直线运动）</li>
<li><strong>2D:</strong> The board has a slight typo or ambiguity with
<span class="math inline">\(\langle z^2(t) \rangle = 2Dt\)</span>. For
2D motion in the x-y plane, the total MSD would be <span
class="math inline">\(\langle r^2(t) \rangle = \langle x^2(t) \rangle +
\langle y^2(t) \rangle = 4Dt\)</span>. The note on the board might be
referring to just one component of motion. **棋盘上的 <span
class="math inline">\(\langle z^2(t) \rangle = 2Dt\)</span>
存在轻微拼写错误或歧义。对于 x-y 平面上的二维运动，总平均散射差 (MSD) 为
<span class="math inline">\(\langle r^2(t) \rangle = \langle x^2(t)
\rangle + \langle y^2(t) \rangle =
4Dt\)</span>。黑板上的注释可能仅指运动的一个分量。</li>
<li><strong>3D:</strong> <span class="math inline">\(\langle r^2(t)
\rangle = \langle |\vec{r}(t) - \vec{r}(0)|^2 \rangle = 6Dt\)</span>
(Movement in 3D space, which is the most common case in molecular
simulations) （三维空间中的运动，这是分子模拟中最常见的情况） Here,
<span class="math inline">\(\vec{r}(t)\)</span> is the position vector
of a particle at time <code>t</code>. The quantity <span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span> is the average of the squared distance a particle has
traveled from its initial position <span
class="math inline">\(\vec{r}(0)\)</span>. 这里，<span
class="math inline">\(\vec{r}(t)\)</span> 是粒子在时间 <code>t</code>
的位置矢量。 <span class="math inline">\(\langle |\vec{r}(t) -
\vec{r}(0)|^2 \rangle\)</span> 是粒子从其初始位置 <span
class="math inline">\(\vec{r}(0)\)</span> 行进距离的平方平均值。</li>
</ul>
<h3
id="the-einstein-relation-connecting-microscopic-motion-to-a-macroscopic-property-爱因斯坦关系将微观运动与宏观特性联系起来">##
4. The Einstein Relation: Connecting Microscopic Motion to a Macroscopic
Property 爱因斯坦关系：将微观运动与宏观特性联系起来</h3>
<p>Finally, the board presents the famous <strong>Einstein
relation</strong>, which rearranges the 3D MSD equation to solve for the
diffusion coefficient <code>D</code>:</p>
<p><span class="math display">\[D = \lim_{t \to \infty} \frac{\langle
|\vec{r}(t) - \vec{r}(0)|^2 \rangle}{6t}\]</span></p>
<p>This is a cornerstone equation in statistical mechanics. It provides
a practical way to calculate a macroscopic property—the
<strong>diffusion coefficient <code>D</code></strong>—from the
microscopic movements of individual particles observed in a computer
simulation.
这是统计力学中的一个基石方程。它提供了一种实用的方法，可以通过计算机模拟中观察到的单个粒子的微观运动来计算宏观属性——扩散系数“D”。</p>
<p>In practice, one would: 1. Run a simulation of particles.
运行粒子模拟。 2. Track the position of each particle over time.
跟踪每个粒子随时间的位置。 3. Calculate the squared displacement <span
class="math inline">\(|\vec{r}(t) - \vec{r}(0)|^2\)</span> for each
particle at various time intervals <code>t</code>.
计算每个粒子在不同时间间隔“t”的位移平方<span
class="math inline">\(|\vec{r}(t) - \vec{r}(0)|^2\)</span>。 4. Average
this value over all particles to get the MSD, <span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span>. 对所有粒子取平均值，得到均方差（MSD），即<span
class="math inline">\(\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle\)</span>。 5. Plot the MSD as a function of time.
将MSD绘制成时间函数。 6. The slope of this line, divided by 6, gives the
diffusion coefficient <code>D</code>. The <code>lim t→∞</code> indicates
that this linear relationship is most accurate for long time scales,
after initial transient effects have died down.
这条直线的斜率除以6，即扩散系数“D”。“lim
t→∞”表明，在初始瞬态效应消退后，这种线性关系在长时间尺度上最为准确。</p>
<h3 id="right-board-green-kubo-relations">## 5. Right Board: Green-Kubo
Relations</h3>
<p>This board introduces a more advanced and powerful method to
calculate transport coefficients like the diffusion coefficient, known
as the <strong>Green-Kubo relations</strong>.
本面板介绍了一种更先进、更强大的方法来计算扩散系数等传输系数，即<strong>Green-Kubo
关系</strong>。</p>
<h4 id="velocity-autocorrelation-function-vacf-速度自相关函数-vacf">###
<strong>Velocity Autocorrelation Function (VACF)</strong> 速度自相关函数
(VACF)</h4>
<p>The key idea is to look at how a particle’s velocity at one point in
time is related to its velocity at a later time. This is measured by the
<strong>Velocity Autocorrelation Function (VACF)</strong>: <span
class="math display">\[C_{vv}(t) = \langle \vec{v}(t&#39;) \cdot
\vec{v}(t&#39; + t) \rangle\]</span> This function tells us how long a
particle “remembers” its velocity. For a typical liquid, the velocity is
quickly randomized by collisions, so the VACF decays to zero rapidly.
其核心思想是考察粒子在某一时间点的速度与其在之后时间点的速度之间的关系。这可以通过<strong>速度自相关函数
(VACF)</strong>来测量： <span class="math display">\[C_{vv}(t) = \langle
\vec{v}(t&#39;) \cdot \vec{v}(t&#39; + t) \rangle\]</span>
此函数告诉我们粒子“记住”其速度的时间。对于典型的液体，速度会因碰撞而迅速随机化，因此
VACF 会迅速衰减为零。</p>
<h4 id="connecting-msd-and-vacf">### <strong>Connecting MSD and
VACF</strong></h4>
<p>The board shows the mathematical link between the MSD and the VACF.
Starting with the definition of position as the integral of velocity,
<span class="math inline">\(\vec{r}(t) = \int_0^t \vec{v}(t&#39;)
dt&#39;\)</span>, one can show that the MSD is a double integral of the
VACF. The board writes this as: <span class="math display">\[\langle
x^2(t) \rangle = \left\langle \left( \int_0^t v(t&#39;) dt&#39; \right)
\left( \int_0^t v(t&#39;&#39;) dt&#39;&#39; \right) \right\rangle =
\int_0^t dt&#39; \int_0^t dt&#39;&#39; \langle v(t&#39;) v(t&#39;&#39;)
\rangle\]</span> This shows that the two pictures of motion—the
particle’s displacement (MSD) and its velocity fluctuations (VACF)—are
deeply connected. 该面板展示了 MSD 和 VACF
之间的数学联系。从位置定义为速度的积分开始，<span
class="math inline">\(\vec{r}(t) = \int_0^t \vec{v}(t&#39;)
dt&#39;\)</span>，可以证明 MSD 是 VACF 的二重积分。黑板上写着： <span
class="math display">\[\langle x^2(t) \rangle = \left\langle \left(
\int_0^t v(t&#39;) dt&#39; \right) \left( \int_0^t v(t&#39;&#39;)
dt&#39;&#39; \right) \right\rangle = \int_0^t dt&#39; \int_0^t
dt&#39;&#39; \langle v(t&#39;) v(t&#39;&#39;) \rangle\]</span>
这表明，粒子运动的两幅图像——粒子的位移（MSD）和速度涨落（VACF）——之间存在着深刻的联系。</p>
<h4 id="the-green-kubo-formula-for-diffusion-扩散的格林-久保公式">###
<strong>The Green-Kubo Formula for Diffusion
扩散的格林-久保公式</strong></h4>
<p>By combining the Einstein relation with the integral of the VACF, one
arrives at the Green-Kubo formula for the diffusion coefficient: <span
class="math display">\[D = \frac{1}{3} \int_0^\infty \langle \vec{v}(0)
\cdot \vec{v}(t) \rangle dt\]</span> This incredible result states that
the <strong>macroscopic</strong> property of diffusion (<span
class="math inline">\(D\)</span>) is determined by the integral of the
<strong>microscopic</strong> velocity correlations. It’s often a more
efficient way to compute <span class="math inline">\(D\)</span> in
simulations than calculating the long-time limit of the MSD.
将爱因斯坦关系与VACF积分相结合，可以得到扩散系数的格林-久保公式： <span
class="math display">\[D = \frac{1}{3} \int_0^\infty \langle \vec{v}(0)
\cdot \vec{v}(t) \rangle dt\]</span>
这个令人难以置信的结果表明，扩散的<strong>宏观</strong>特性（<span
class="math inline">\(D\)</span>）由<strong>微观</strong>速度关联的积分决定。在模拟中，这通常是计算<span
class="math inline">\(D\)</span>比计算MSD的长期极限更有效的方法。</p>
<h3 id="the-grand-narrative-from-micro-to-macro-宏大叙事从微观到宏观">##
6. The Grand Narrative: From Micro to Macro 宏大叙事：从微观到宏观</h3>
<p>The previous whiteboards gave us two ways to calculate the
<strong>diffusion constant, D</strong>, from the microscopic random walk
of individual atoms:
之前的白板提供了两种从单个原子的微观随机游动计算<strong>扩散常数
D</strong>的方法： 1. <strong>Einstein Relation:</strong> From the
long-term slope of the Mean Squared Displacement (MSD). 根据均方位移
(MSD) 的长期斜率。 2. <strong>Green-Kubo Relation:</strong> From the
integral of the Velocity Autocorrelation Function (VACF).
根据速度自相关函数 (VACF) 的积分。</p>
<p>This new whiteboard shows how that single microscopic parameter,
<code>D</code>, governs the large-scale, observable process of diffusion
described by <strong>Fick’s Laws</strong> and the <strong>Diffusion
Equation</strong>. 这块新的白板展示了单个微观参数 <code>D</code>
如何控制<strong>菲克定律</strong>和<strong>扩散方程</strong>所描述的大规模可观测扩散过程。</p>
<h3 id="the-starting-point-a-liquids-structure-起点液体的结构">## 1. The
Starting Point: A Liquid’s Structure 起点：液体的结构</h3>
<p>The plot on the top left is the <strong>Radial Distribution Function,
<span class="math inline">\(g(r)\)</span></strong>, which we discussed
in detail from the first whiteboard. 左上角的图是<strong>径向分布函数
<span
class="math inline">\(g(r)\)</span></strong>，我们在第一个白板上详细讨论过它。</p>
<ul>
<li><strong>The Plot:</strong> It shows the characteristic structure of
a liquid. The peaks are labeled “1st”, “2nd”, and “3rd”, corresponding
to the first, second, and third <strong>solvation shells</strong>
(layers of neighboring atoms).
它显示了液体的特征结构。峰分别标记为“第一”、“第二”和“第三”，分别对应于第一、第二和第三<strong>溶剂化壳层</strong>（相邻原子层）。</li>
<li><strong>The Limit:</strong> The note <code>lim r→∞ g(r) = 1</code>
confirms that at large distances, the liquid has no long-range order, as
expected.注释“lim r→∞ g(r) =
1”证实了在远距离下，液体没有长程有序，这与预期一致。</li>
<li><strong>System Parameters:</strong> The values <code>T = 0.71</code>
and <code>ρ = 0.844</code> are the temperature and density of the
simulated system (likely in reduced or “Lennard-Jones” units) for which
this <span class="math inline">\(g(r)\)</span> was calculated. 值“T =
0.71”和“ρ =
0.844”分别是模拟系统的温度和密度（可能采用约化或“Lennard-Jones”单位），用于计算此
<span class="math inline">\(g(r)\)</span>。</li>
</ul>
<p>This section sets the stage: we are looking at the dynamics within a
system that has this specific liquid-like structure.
本节奠定了基础：我们将研究具有特定类液体结构的系统内的动力学。</p>
<h3 id="the-macroscopic-laws-of-diffusion-宏观扩散定律">## 2. The
Macroscopic Laws of Diffusion 宏观扩散定律</h3>
<p>The bottom-left and top-right sections introduce the continuum
equations that describe how concentration changes in space and time.
左下角和右上角部分介绍了描述浓度随空间和时间变化的连续方程。左下角和右上角部分介绍了描述浓度随空间和时间变化的连续方程。</p>
<h4 id="ficks-first-law-菲克第一定律">### <strong>Fick’s First Law
菲克第一定律</strong></h4>
<p><span class="math display">\[\vec{J} = -D \nabla C\]</span> This is
Fick’s first law of diffusion. It states that there is a
<strong>flux</strong> of particles (<span
class="math inline">\(\vec{J}\)</span>), meaning a net flow. This flow
is directed from high concentration to low concentration (hence the
minus sign) and its magnitude is proportional to the
<strong>concentration gradient</strong> (<span
class="math inline">\(\nabla C\)</span>).
这是菲克第一扩散定律。它指出存在粒子的<strong>通量</strong> (<span
class="math inline">\(\vec{J}\)</span>)，即净流量。该流量从高浓度流向低浓度（因此带有负号），其大小与<strong>浓度梯度</strong>
(<span class="math inline">\(\nabla C\)</span>) 成正比。</p>
<p><strong>The Crucial Link:</strong> The proportionality constant is
<strong>D</strong>, the very same <strong>diffusion constant</strong> we
calculated from the microscopic random walk (MSD/VACF). This is the key
connection: the collective result of countless individual random walks
is a predictable net flow of particles.
比例常数是<strong>D</strong>，与我们根据微观随机游走 (MSD/VACF)
计算出的<strong>扩散常数</strong>完全相同。这是关键的联系：无数个体随机游动的集合结果是可预测的粒子净流。</p>
<h4
id="the-diffusion-equation-ficks-second-law-扩散方程菲克第二定律">###
<strong>The Diffusion Equation (Fick’s Second Law)
扩散方程（菲克第二定律）</strong></h4>
<p><span class="math display">\[\frac{\partial C(\vec{r},t)}{\partial t}
= D \nabla^2 C(\vec{r},t)\]</span> This is the <strong>diffusion
equation</strong>, one of the most important equations in physics and
chemistry (also called the heat equation, as noted). It’s derived from
Fick’s first law and the principle of mass conservation (<span
class="math inline">\(\frac{\partial C}{\partial t} + \nabla \cdot
\vec{J} = 0\)</span>). It’s a differential equation that tells you
exactly how the concentration at any point, <span
class="math inline">\(C(\vec{r},t)\)</span>, will change over time.
这就是<strong>扩散方程</strong>，它是物理学和化学中最重要的方程之一（也称为热方程）。它源于菲克第一定律和质量守恒定律（<span
class="math inline">\(\frac{\partial C}{\partial t} + \nabla \cdot
\vec{J} = 0\)</span>）。它是一个微分方程，可以精确地告诉你任意一点的浓度
<span class="math inline">\(C(\vec{r},t)\)</span> 随时间的变化。</p>
<h3
id="the-solution-connecting-back-to-the-random-walk-与随机游动联系起来">##
3. The Solution: Connecting Back to the Random Walk
与随机游动联系起来</h3>
<p>This is the most beautiful part. The board shows the solution to the
diffusion equation for a very specific scenario, linking the macroscopic
equation directly back to the microscopic random walk.
黑板上展示了一个非常具体场景下扩散方程的解，将宏观方程直接与微观随机游动联系起来。</p>
<h4 id="the-initial-condition-初始条件">### <strong>The Initial
Condition 初始条件</strong></h4>
<p>The problem is set up by assuming all particles start at a single
point at time zero: <span class="math display">\[C(\vec{r}, 0) =
\delta(\vec{r})\]</span> This is a <strong>Dirac delta
function</strong>, representing an infinitely concentrated point source
at the origin. 问题假设所有粒子在时间零点处从一个点开始： <span
class="math display">\[C(\vec{r}, 0) = \delta(\vec{r})\]</span>
这是一个<strong>狄拉克函数</strong>，表示一个在原点处无限集中的点源。</p>
<h4 id="the-fundamental-solution-greens-function-基本解格林函数">###
<strong>The Fundamental Solution (Green’s Function)
基本解（格林函数）</strong></h4>
<p>The solution to the diffusion equation with this starting condition
is called the <strong>fundamental solution</strong> or <strong>Green’s
function</strong>. For one dimension, it is: <span
class="math display">\[C(x,t) = \frac{1}{\sqrt{4\pi Dt}}
\exp\left(-\frac{x^2}{4Dt}\right)\]</span></p>
<p><strong>The “Aha!” Moment:</strong> This is a <strong>Gaussian
distribution</strong>. Let’s compare it to the formula from the second
whiteboard: * The mean is <span class="math inline">\(\mu=0\)</span>.
均值为 <span class="math inline">\(\mu=0\)</span>。 * The variance is
<span class="math inline">\(\sigma^2 = 2Dt\)</span>. 方差为 <span
class="math inline">\(\sigma^2 = 2Dt\)</span>。</p>
<p>This is an incredible result. The macroscopic diffusion equation
predicts that a concentration pulse will spread out over time, and the
shape of the concentration profile will be a Gaussian curve. The width
of this curve, measured by its variance <span
class="math inline">\(\sigma^2\)</span>, is <strong>exactly the Mean
Squared Displacement, <span class="math inline">\(\langle x^2(t)
\rangle\)</span>, of the individual random-walking particles.</strong>
宏观扩散方程预测浓度脉冲会随时间扩散，浓度分布的形状将是高斯曲线。这条曲线的宽度，用其方差
<span class="math inline">\(\sigma^2\)</span>
来衡量，<strong>恰好是单个随机游动粒子的均方位移 <span
class="math inline">\(\langle x^2(t) \rangle\)</span>。</strong></p>
<p>This perfectly unites the two perspectives: * <strong>Microscopic微观
(Board 2):</strong> Particles undergo a random walk, and their average
squared displacement from the origin grows as <span
class="math inline">\(\langle x^2(t) \rangle = 2Dt\)</span>.
粒子进行随机游动，它们相对于原点的平均平方位移随着 <span
class="math inline">\(\langle x^2(t) \rangle = 2Dt\)</span>
的增长而增长。 * <strong>Macroscopic宏观 (This Board):</strong> A
collection of these particles, described by a continuum concentration
<code>C</code>, spreads out in a Gaussian profile whose variance is
<span class="math inline">\(\sigma^2 = 2Dt\)</span>.
这些粒子的集合，用连续浓度“C”来描述，呈方差为 <span
class="math inline">\(\sigma^2 = 2Dt\)</span> 的高斯分布。</p>
<p>The two pictures are mathematically identical.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/17/5120C3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/17/5120C3-2/" class="post-title-link" itemprop="url">PHYS 5120 - Computational Energy Materials and Electronic Structure Simulations-W3-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-17 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-17T21:00:00+08:00">2025-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-21 05:21:00" itemprop="dateModified" datetime="2025-09-21T05:21:00+08:00">2025-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHYS-5120/" itemprop="url" rel="index"><span itemprop="name">PHYS-5120</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PHYS 5120 - 计算能源材料和电子结构模拟 Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://chem.hkust.edu.hk/people/ding-pan-panding">Lecturer:
Prof.PAN DING</a></p>
<h2 id="radial-distribution-function-rdf静态结构">1 radial distribution
function RDF静态结构:</h2>
<ul>
<li><strong>内容</strong>: This whiteboard serves as an excellent
summary, pulling together all the key concepts we’ve discussed into a
single, cohesive picture. Let’s connect everything on this slide to our
detailed conversation.</li>
</ul>
<h3 id="rdf-the-static-structure-rdf静态结构">1. RDF: The Static
Structure RDF静态结构</h3>
<p>On the top left, you see <strong>RDF (Radial Distribution
Function)</strong>.</p>
<ul>
<li><strong>The Plots:</strong> The board shows the familiar <span
class="math inline">\(g(r)\)</span> plot with its characteristic peaks
for a liquid. Below it is a plot of the interatomic potential energy,
<span class="math inline">\(V(r)\)</span>. This addition is very
insightful! It shows <em>why</em> the first peak in <span
class="math inline">\(g(r)\)</span> exists: it corresponds to the
minimum energy distance (<span class="math inline">\(\sigma\)</span>)
where particles are most stable and likely to be found.
白板展示了我们熟悉的<span
class="math inline">\(g(r)\)</span>图，它带有液体的特征峰。下方是原子间势能<span
class="math inline">\(V(r)\)</span>的图。这个补充非常有见地！它解释了为什么
<span class="math inline">\(g(r)\)</span>
中的第一个峰值存在：它对应于粒子最稳定且最有可能被发现的最小能量距离
(<span class="math inline">\(\sigma\)</span>)。</li>
<li><strong>Connection:</strong> This section summarizes our first
discussion. It’s the starting point for our analysis—a static snapshot
of the material’s average atomic arrangement before we consider how the
atoms move.
本节总结了我们的第一个讨论。这是我们分析的起点——在我们考虑原子如何运动之前，它是材料平均原子排列的静态快照。</li>
</ul>
<h3
id="msd-and-the-einstein-relation-the-displacement-picture-均方位移-msd-和爱因斯坦关系位移图像">2.
MSD and The Einstein Relation: The Displacement Picture 均方位移 (MSD)
和爱因斯坦关系：位移图像</h3>
<p>The board then moves to dynamics, presenting two methods to calculate
the <strong>diffusion constant, D</strong>. The first is the
<strong>Einstein relation</strong>. 两种计算<strong>扩散常数
D</strong>的方法。第一种是<strong>爱因斯坦关系</strong>。</p>
<ul>
<li><strong>The Formula:</strong> It correctly states that the Mean
Squared Displacement (MSD), <span class="math inline">\(\langle r^2
\rangle\)</span>, is equal to <span class="math inline">\(6Dt\)</span>
in three dimensions. It then rearranges this to solve for <span
class="math inline">\(D\)</span>: 它正确地指出了均方位移 (MSD)，<span
class="math inline">\(\langle r^2 \rangle\)</span>，在三维空间中等于
<span class="math inline">\(6Dt\)</span>。然后重新排列该公式以求解 <span
class="math inline">\(D\)</span>： <span class="math display">\[D =
\lim_{t\to\infty} \frac{\langle |\vec{r}(t) - \vec{r}(0)|^2
\rangle}{6t}\]</span></li>
<li><strong>The Diagram:</strong> The central diagram beautifully
illustrates the concept. It shows a particle in a simulation box (with
“N=108” likely being the number of particles simulated) moving from an
initial position <span class="math inline">\(\vec{r}_i(0)\)</span> to a
final position <span class="math inline">\(\vec{r}_i(t_j)\)</span>. The
MSD is the average of the square of this displacement over all particles
and many time origins. The graph labeled “MSD” shows how you would plot
this data and find the slope (“fitting”) to calculate <span
class="math inline">\(D\)</span>.
中间的图表完美地阐释了这个概念。它展示了一个粒子在模拟框中（“N=108”
可能是模拟粒子的数量）从初始位置 <span
class="math inline">\(\vec{r}_i(0)\)</span> 移动到最终位置 <span
class="math inline">\(\vec{r}_i(t_j)\)</span>。MSD
是该位移平方在所有粒子和多个时间原点上的平均值。标有“MSD”的图表显示了如何绘制这些数据并找到斜率（“拟合”）来计算
<span class="math inline">\(D\)</span>。</li>
<li><strong>Connection:</strong> This is a perfect summary of the
“Displacement Picture” we analyzed on the second whiteboard. It’s the
most intuitive way to think about diffusion: how far particles spread
out over
time.这完美地总结了我们在第二个白板上分析的“位移图”。这是思考扩散最直观的方式：粒子随时间扩散的距离。</li>
</ul>
<h3
id="the-green-kubo-relation-the-fluctuation-picture-格林-久保关系涨落图">3.
The Green-Kubo Relation: The Fluctuation Picture
格林-久保关系：涨落图</h3>
<p>Finally, the board presents the more advanced but often more
practical method: the <strong>Green-Kubo relation</strong>.</p>
<ul>
<li><strong>The Equations:</strong> This section displays the two key
equations from our last discussion:
<ol type="1">
<li>The MSD as the double integral of the Velocity Autocorrelation
Function (VACF). 速度自相关函数 (VACF) 的二重积分的均方差 (MSD)。</li>
<li>The crucial derivative step: <span
class="math inline">\(\frac{d\langle x^2(t)\rangle}{dt} = 2 \int_0^t
dt&#39;&#39; \langle V_x(t) V_x(t&#39;&#39;) \rangle\)</span>.
关键的导数步骤：<span class="math inline">\(\frac{d\langle
x^2(t)\rangle}{dt} = 2 \int_0^t dt&#39;&#39; \langle V_x(t)
V_x(t&#39;&#39;) \rangle\)</span>。</li>
</ol></li>
<li><strong>The Diagram:</strong> The small diagram of a square with
axes <span class="math inline">\(t&#39;\)</span> and <span
class="math inline">\(t&#39;&#39;\)</span> visually represents the
two-dimensional domain of integration for the double integral.
一个带有轴 <span class="math inline">\(t&#39;\)</span> 和 <span
class="math inline">\(t&#39;&#39;\)</span>
的小正方形图直观地表示了二重积分的二维积分域。</li>
<li><strong>Connection:</strong> This summarizes the “Fluctuation
Picture.” It shows the mathematical heart of the derivation that proves
the Einstein and Green-Kubo methods are equivalent. As we concluded,
this method is often numerically superior because it involves
integrating a rapidly decaying function (the VACF) rather than finding
the slope of a noisy, unbounded function (the MSD).
这概括了“涨落图”。它展示了证明爱因斯坦方法和格林-久保方法等价的推导过程的数学核心。正如我们总结的那样，这种方法通常在数值上更胜一筹，因为它涉及对快速衰减函数（VACF）进行积分，而不是求噪声无界函数（MSD）的斜率。</li>
</ul>
<p>In essence, this single whiteboard is a complete roadmap for
analyzing diffusion in a molecular simulation. It shows how to first
characterize the material’s <strong>structure</strong> (<span
class="math inline">\(g(r)\)</span>) and then how to compute its key
dynamic property—the <strong>diffusion constant
<code>D</code></strong>—using two powerful, interconnected methods.
本质上，这块白板就是分子模拟中分析扩散的完整路线图。它展示了如何首先表征材料的<strong>结构</strong>（<span
class="math inline">\(g(r)\)</span>），然后如何使用两种强大且相互关联的方法计算其关键的动态特性——<strong>扩散常数
<code>D</code></strong>。</p>
<p>This whiteboard beautifully concludes the derivation of the
Green-Kubo relation, showing the final formulas and how they are used in
practice. It provides the punchline to the mathematical story we’ve been
following.</p>
<p>Let’s break down the details.</p>
<h3 id="finalizing-the-derivation">4. Finalizing the Derivation</h3>
<p>The top lines of the board show the final step in connecting the Mean
Squared Displacement (MSD) to the Velocity Autocorrelation Function
(VACF).</p>
<p><span class="math display">\[\lim_{t\to\infty} \frac{d\langle x^2
\rangle}{dt} = 2 \int_0^\infty d\tau \langle V_x(0) V_x(\tau)
\rangle\]</span></p>
<ul>
<li><strong>The Left Side:</strong> As we know from the <strong>Einstein
relation</strong>, the long-time limit of the derivative of the 1D MSD,
<span class="math inline">\(\lim_{t\to\infty} \frac{d\langle x^2
\rangle}{dt}\)</span>, is simply equal to <strong><span
class="math inline">\(2D\)</span></strong>.</li>
<li><strong>The Right Side:</strong> This is the result of the
mathematical derivation from the previous slide. It shows that this same
quantity is also equal to twice the total integral of the VACF.</li>
</ul>
<p>By equating these two, we can solve for the diffusion coefficient,
<code>D</code>.</p>
<h3 id="the-velocity-autocorrelation-function-vacf">5. The Velocity
Autocorrelation Function (VACF)</h3>
<p>The board explicitly names the key quantity here:</p>
<p><span class="math display">\[\Phi(\tau) = \langle V_x(0) V_x(\tau)
\rangle\]</span></p>
<p>This is the <strong>“Velocity autocorrelation function”</strong>
(abbreviated as VAF on the board), which we’ve denoted as VACF. The
variable has been changed from <code>t</code> to <code>τ</code> (tau) to
represent a “time lag” or interval, which is common notation.</p>
<ul>
<li><strong>The Plot:</strong> The graph on the board shows a typical
plot of the VACF, <span class="math inline">\(\Phi(\tau)\)</span>,
versus the time lag <span class="math inline">\(\tau\)</span>.
<ul>
<li>It starts at a maximum positive value at <span
class="math inline">\(\tau=0\)</span> (when the velocity is perfectly
correlated with itself).</li>
<li>It rapidly decays towards zero as the particle undergoes collisions
that randomize its velocity.</li>
</ul></li>
<li><strong>The Integral:</strong> The shaded area under this curve
represents the value of the integral <span
class="math inline">\(\int_0^\infty \Phi(\tau) d\tau\)</span>. The
Green-Kubo formula states that the diffusion coefficient is directly
proportional to this area.</li>
</ul>
<h3 id="the-green-kubo-formulas-for-the-diffusion-coefficient">6. The
Green-Kubo Formulas for the Diffusion Coefficient</h3>
<p>After canceling the factor of 2, the board presents the final,
practical formulas for <code>D</code>.</p>
<ul>
<li><strong>In 1 Dimension:</strong> <span class="math display">\[D =
\int_0^\infty d\tau \langle V_x(0) V_x(\tau) \rangle\]</span></li>
<li><strong>In 3 Dimensions:</strong> This is the more general and
useful formula. <span class="math display">\[D = \frac{1}{3}
\int_0^\infty d\tau \langle \vec{v}(0) \cdot \vec{v}(\tau)
\rangle\]</span> There are two important changes for 3D:
<ol type="1">
<li>We use the full <strong>velocity vectors</strong> and their dot
product, <span class="math inline">\(\vec{v}(0) \cdot
\vec{v}(\tau)\)</span>, to capture motion in all directions.</li>
<li>We divide by <strong>3</strong> to get the average contribution to
diffusion in any one direction (x, y, or z).</li>
</ol></li>
</ul>
<h3 id="practical-calculation-in-a-simulation">7. Practical Calculation
in a Simulation</h3>
<p>The last formula on the board shows how this is implemented in a
computer simulation with a finite number of atoms.</p>
<p><span class="math display">\[D = \frac{1}{3N} \int_0^\infty d\tau
\sum_{i=1}^{N} \langle \vec{v}_i(0) \cdot \vec{v}_i(\tau)
\rangle\]</span></p>
<ul>
<li><strong><span
class="math inline">\(\sum_{i=1}^{N}\)</span></strong>: This
<strong>summation</strong> symbol indicates that you must compute the
VACF for <em>each individual atom</em> (from atom <code>i=1</code> to
atom <code>N</code>).</li>
<li><strong><span class="math inline">\(\frac{1}{N}\)</span></strong>:
You then <strong>average</strong> the results over all <code>N</code>
atoms in your simulation box.</li>
<li><strong><span class="math inline">\(\langle \dots
\rangle\)</span></strong>: The angle brackets here still imply an
additional average over multiple different starting times
(<code>t=0</code>) to get good statistics.</li>
</ul>
<p>This formula is the practical recipe: to get the diffusion
coefficient, you track the velocity of every atom, calculate each one’s
VACF, average them together, and then integrate the result over
time.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/16/5054C3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/16/5054C3/" class="post-title-link" itemprop="url">MSDM 5054 - Statistical Machine Learning-L3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-16 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-16T21:00:00+08:00">2025-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:11" itemprop="dateModified" datetime="2025-09-19T19:24:11+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计机器学习Lecture-3</p>
<p><a target="_blank" rel="noopener" href="https://www.math.hkust.edu.hk/~madxia/">Lecturer: Prof.XIA
DONG</a></p>
<h1 id="general-linear-regression-model.">1. General linear regression
model.</h1>
<p><img src="/imgs/5054C3/General_linear_regression_model.png" alt="Diagram of a linear regression model">
## 1.1 general linear regression model - <strong>内容</strong>:
<strong>general linear regression model</strong>.</p>
<p>the fundamental equation:</p>
<p><span class="math display">\[y_i = \beta_0 + \beta_1x_{i1} + \dots +
\beta_px_{ip} + \epsilon_i\]</span></p>
<p>And it correctly identifies the main goal: to <strong>estimate the
parameters</strong> (the coefficients <span
class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span>) from
data so we can make predictions on new data.</p>
<p>核心目标：通过数据<strong>估计参数</strong>（即系数 <span
class="math inline">\(\beta_0, \beta_1, \dots,
\beta_p\)</span>），从而对新数据进行预测。</p>
<h2
id="how-we-actually-find-the-best-values-for-the-β-coefficients-parameter-estimation">1.2
How we actually find the best values for the <span
class="math inline">\(β\)</span> coefficients (parameter
estimation)?:</h2>
<ul>
<li><strong>内容</strong>: We find the best values for the <span
class="math inline">\(\beta\)</span> coefficients by finding the values
that <strong>minimize the overall error</strong> of the model. The most
common and fundamental method for this is called <strong>Ordinary Least
Squares (OLS)</strong>.</li>
</ul>
<h3
id="the-main-method-ordinary-least-squares-ols-普通最小二乘法-ols">##
The Main Method: Ordinary Least Squares (OLS) 普通最小二乘法 (OLS)</h3>
<p>The core idea of OLS is to find the line (or hyperplane in multiple
dimensions) that is as close as possible to all the data points
simultaneously. OLS
的核心思想是找到一条尽可能同时接近所有数据点的直线（或多维超平面）。</p>
<h4 id="define-the-error-residuals-误差">1. Define the Error (Residuals)
误差</h4>
<p>First, we need to define what “error” means. For any single data
point, the error is the difference between the actual value (<span
class="math inline">\(y_i\)</span>) and the value predicted by our model
(<span class="math inline">\(\hat{y}_i\)</span>). This difference is
called the <strong>residual</strong>.
首先，需要定义“误差”的含义。对于任何单个数据点，误差是实际值 (<span
class="math inline">\(y_i\)</span>) 与模型预测值 (<span
class="math inline">\(\hat{y}_i\)</span>)
之间的差值。这个差值称为<strong>残差</strong>。</p>
<p><strong>Residual</strong> = Actual Value - Predicted Value
<strong>残差</strong> = 实际值 - 预测值 <span class="math display">\[e_i
= y_i - \hat{y}_i\]</span></p>
<p>You can visualize residuals as the vertical distance from each data
point to the regression line.
可以将残差可视化为每个数据点到回归线的垂直距离。</p>
<h4
id="the-cost-function-sum-of-squared-residuals-成本函数残差平方和">2.
The Cost Function: Sum of Squared Residuals 成本函数：残差平方和</h4>
<p>We want to make all these residuals as small as possible. We can’t
just add them up, because some are positive and some are negative, and
they would cancel each other out.
所有残差尽可能小。不能简单地将它们相加，因为有些是正数，有些是负数，它们会相互抵消。</p>
<p>So, we square each residual (which makes them all positive) and then
sum them up. This gives us the <strong>Sum of Squared Residuals
(SSR)</strong>, which is our “cost function.”
因此，将每个残差求平方（使它们都为正数），然后将它们相加。这就得到了<strong>残差平方和
(SSR)</strong>，也就是“成本函数”。</p>
<p><span class="math display">\[SSR = \sum_{i=1}^{n} e_i^2 =
\sum_{i=1}^{n} (y_i - \hat{y}_i)^2\]</span></p>
<p>The goal of OLS is simple: <strong>find the values of <span
class="math inline">\(\beta_0, \beta_1, \dots, \beta_p\)</span> that
make this SSR value as small as possible.</strong></p>
<h4
id="solving-for-the-coefficients-the-normal-equation-求解系数正态方程">3.
Solving for the Coefficients: The Normal Equation
求解系数：正态方程</h4>
<p>For linear regression, calculus provides a direct, exact solution to
this minimization problem. By taking the derivative of the SSR function
with respect to each <span class="math inline">\(\beta\)</span>
coefficient and setting it to zero, we can solve for the optimal values.
对于线性回归，微积分为这个最小化问题提供了直接、精确的解。通过对 SSR
函数的每个 <span class="math inline">\(\beta\)</span>
系数求导并将其设为零，就可以求解出最优值。</p>
<p>This process results in a formula known as the <strong>Normal
Equation</strong>, which can be expressed cleanly using matrix algebra:
这个过程会得到一个称为<strong>正态方程</strong>的公式，它可以用矩阵代数清晰地表示出来：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is the
vector of our estimated coefficients.估计系数的向量。</li>
<li><span class="math inline">\(\mathbf{X}\)</span> is a matrix where
each row is an observation and each column is a feature (with an added
column of 1s for the intercept <span
class="math inline">\(\beta_0\)</span>).其中每一行代表一个观测值，每一列代表一个特征（截距
<span class="math inline">\(\beta_0\)</span> 增加了一列全为 1
的值）。</li>
<li><span class="math inline">\(\mathbf{y}\)</span> is the vector of the
actual response values.实际响应值的向量。</li>
</ul>
<p>Statistical software and programming libraries (like Scikit-learn in
Python) use this equation (or more computationally stable versions of
it) to find the best coefficients for you instantly.</p>
<h3 id="an-alternative-method-gradient-descent-梯度下降">## An
Alternative Method: Gradient Descent 梯度下降</h3>
<p>While the Normal Equation gives a direct answer, it can be very slow
if you have a massive number of features (e.g., hundreds of thousands).
An alternative, iterative method used across machine learning is
<strong>Gradient Descent</strong>.</p>
<p><strong>The Intuition:</strong> Imagine the SSR cost function is a
big valley. Your initial (random) <span
class="math inline">\(\beta\)</span> coefficients place you somewhere on
the slope of this valley.</p>
<ol type="1">
<li><strong>Check the slope</strong> (the gradient) at your current
position. <strong>检查您当前位置的斜率</strong>（梯度）。</li>
<li><strong>Take a small step</strong> in the steepest <em>downhill</em>
direction. <strong>朝最陡的<em>下坡</em>方向</strong>迈出一小步**。</li>
<li><strong>Repeat.</strong> You keep taking steps downhill until you
reach the bottom of the valley. The bottom of the valley represents the
minimum SSR, and your coordinates at that point are the optimal <span
class="math inline">\(\beta\)</span> coefficients.
<strong>重复</strong>。您继续向下走，直到到达山谷底部。谷底代表最小SSR，该点的坐标即为最优<span
class="math inline">\(\beta\)</span>系数。</li>
</ol>
<p>The size of each “step” you take is controlled by a parameter called
the <strong>learning rate</strong>. Gradient Descent is the foundational
optimization algorithm for many complex models, including neural
networks.
每次“步进”的大小由一个称为<strong>学习率</strong>的参数控制。梯度下降是许多复杂模型（包括神经网络）的基础优化算法。</p>
<h3 id="summary-ols-vs.-gradient-descent">## Summary: OLS vs. Gradient
Descent</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Ordinary Least Squares (OLS)</th>
<th style="text-align: left;">Gradient Descent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>How it works</strong></td>
<td style="text-align: left;">Direct calculation using the Normal
Equation.</td>
<td style="text-align: left;">Iterative; takes steps to minimize
error.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Pros</strong></td>
<td style="text-align: left;">Provides an exact, optimal solution. No
parameters to tune.</td>
<td style="text-align: left;">More efficient for very large datasets.
Very versatile.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Cons</strong></td>
<td style="text-align: left;">Can be computationally expensive with many
features.</td>
<td style="text-align: left;">Requires choosing a learning rate. May not
find the exact minimum.</td>
</tr>
</tbody>
</table>
<h1 id="simple-linear-regression">2. Simple Linear Regression</h1>
<p><img src="/imgs/5054C3/Simple_Linear_Regression.png" alt="Simple_Linear_Regression"></p>
<h2 id="simple-linear-regression-1">2.1 Simple Linear Regression</h2>
<ul>
<li><strong>内容</strong>: <strong>Simple Linear Regression:</strong> a
special case of the general model you showed earlier where you only have
<strong>one</strong> predictor variable (<span
class="math inline">\(p=1\)</span>).</li>
</ul>
<h3 id="the-model-and-the-goal-模型和目标">## The Model and the Goal
模型和目标</h3>
<p>Sets up the simplified equation for a line: <span
class="math display">\[y_i = \beta_0 + \beta_1x_i + \epsilon_i\]</span>
* <span class="math inline">\(y_i\)</span> is the outcome you want to
predict.要预测的结果。 * <span class="math inline">\(x_i\)</span> is
your single input feature or covariate.单个输入特征或协变量。 * <span
class="math inline">\(\beta_1\)</span> is the <strong>slope</strong> of
the line. It tells you how much <span class="math inline">\(y\)</span>
is expected to increase for a one-unit increase in <span
class="math inline">\(x\)</span>.表示 <span
class="math inline">\(x\)</span> 每增加一个单位，<span
class="math inline">\(y\)</span> 预计会增加多少。 * <span
class="math inline">\(\beta_0\)</span> is the
<strong>intercept</strong>. It’s the predicted value of <span
class="math inline">\(y\)</span> when <span
class="math inline">\(x\)</span> is zero.当 <span
class="math inline">\(x\)</span> 为零时 <span
class="math inline">\(y\)</span> 的预测值。 * <span
class="math inline">\(\epsilon_i\)</span> is the random error
term.是随机误差项。</p>
<p>The goal, stated as “Minimize the sum of squares of err,” is exactly
the <strong>Ordinary Least Squares (OLS)</strong> method we just
discussed. It’s written here as: <span class="math display">\[\min_{a,b}
\sum_{i=1}^{n} (y_i - a - bx_i)^2\]</span> This is just a different way
of writing the same thing, where they use <code>a</code> for the
intercept (<span class="math inline">\(\beta_0\)</span>) and
<code>b</code> for the slope (<span
class="math inline">\(\beta_1\)</span>). You’re trying to find the
specific values of the slope and intercept that make the sum of all the
squared errors as small as possible.
目标，即“最小化误差平方和”，正是<strong>普通最小二乘法
(OLS)</strong>。： <span class="math display">\[\min_{a,b}
\sum_{i=1}^{n} (y_i - a - bx_i)^2\]</span> 这是另一种写法，其中用
<code>a</code> 表示截距 (<span
class="math inline">\(\beta_0\)</span>)，<code>b</code> 表示斜率 (<span
class="math inline">\(\beta_1\)</span>)。尝试找到斜率和截距的具体值，使得所有平方误差之和尽可能小。</p>
<h3 id="the-solution-the-estimator-formulas-解决方案估计公式">## The
Solution: The Estimator Formulas 解决方案：估计公式</h3>
<p>The most important part of this slide is the
<strong>solution</strong>. For the simple case with only one variable,
you don’t need complex matrix algebra (the Normal Equation). Instead,
the minimization problem can be solved with these two straightforward
formulas:
对于只有一个变量的简单情况，不需要复杂的矩阵代数（正态方程）。相反，最小化问题可以用以下两个简单的公式来解决：</p>
<h4 id="the-slope-hatbeta_1">1. The Slope: <span
class="math inline">\(\hat{\beta}_1\)</span></h4>
<p><span class="math display">\[\hat{\beta}_1 = \frac{\sum_{i=1}^{n}
(x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^{n} (x_i -
\bar{x})^2}\]</span> * <strong>Intuition:</strong> This formula might
look complex, but it’s actually very intuitive. * The numerator, <span
class="math inline">\(\sum(x_i - \bar{x})(y_i - \bar{y})\)</span>, is
closely related to the <strong>covariance</strong> between X and Y. It
measures whether X and Y tend to move in the same direction (positive
slope) or in opposite directions (negative slope). 与 X 和 Y
之间的<strong>协方差</strong>密切相关。它衡量 X 和 Y
是倾向于朝相同方向（正斜率）还是朝相反方向（负斜率）移动。 * The
denominator, <span class="math inline">\(\sum(x_i - \bar{x})^2\)</span>,
is related to the <strong>variance</strong> of X. It measures how much X
varies on its own. 它衡量 X 自身的变化量。 * <strong>In short, the slope
is a measure of how X and Y vary together, scaled by how much X varies
by itself.</strong> 斜率衡量的是 X 和 Y 共同变化的程度，并以 X
自身的变化量为标度。</p>
<h4 id="the-intercept-hatbeta_0-截距">2. The Intercept: <span
class="math inline">\(\hat{\beta}_0\)</span> 截距</h4>
<p><span class="math display">\[\hat{\beta}_0 = \bar{y} -
\hat{\beta}_1\bar{x}\]</span> * <strong>Intuition:</strong> This formula
is even simpler and has a wonderful geometric meaning. It ensures that
the <strong>line of best fit always passes through the “center of mass”
of the data</strong>, which is the point of averages <span
class="math inline">\((\bar{x}, \bar{y})\)</span>.
它确保<strong>最佳拟合线始终穿过数据的“质心”</strong>，即平均值 <span
class="math inline">\((\bar{x}, \bar{y})\)</span> 的点。计算出最佳斜率
(<span class="math inline">\(\hat{\beta}_1\)</span>)
后，就可以将其代入此公式。然后，可以调整截距 (<span
class="math inline">\(\hat{\beta}_0\)</span>)，使直线完美地围绕数据云的中心点旋转。
* Once you’ve calculated the best slope (<span
class="math inline">\(\hat{\beta}_1\)</span>), you can plug it into this
formula. You then adjust the intercept (<span
class="math inline">\(\hat{\beta}_0\)</span>) so that the line pivots
perfectly around the central point of your data cloud.</p>
<p>In summary, this slide provides the precise, closed-form formulas to
calculate the slope and intercept for the line of best fit in a simple
linear regression model.</p>
<h1 id="statistical-inference">3. Statistical Inference</h1>
<p><img src="/imgs/5054C3/Statistical_Inference1.png" alt="Statistical_Inference1">
<img src="/imgs/5054C3/Statistical_Inference2.png" alt="Statistical_Inference2">
## 3.1 Statistical Inference - <strong>内容</strong>:
<strong>Statistical Inference:</strong> These two slides are deeply
connected and explain how we go from just <em>calculating</em> the
coefficients to understanding how <em>accurate</em> and
<em>reliable</em> they are.
解释了我们如何从仅仅<em>计算</em>系数到理解它们的<em>准确性</em>和<em>可靠性</em>。</p>
<h3 id="the-core-problem-quantifying-uncertainty-量化不确定性">## The
Core Problem: Quantifying Uncertainty 量化不确定性</h3>
<p>The second slide poses the fundamental questions: * “How accurate are
<span class="math inline">\(\hat{\beta}_0\)</span> and <span
class="math inline">\(\hat{\beta}_1\)</span>?”准确性如何？ * “What are
the distributions of <span class="math inline">\(\hat{\beta}_0\)</span>
and <span class="math inline">\(\hat{\beta}_1\)</span>?”分布是什么？</p>
<p>The reason we ask this is that our estimated coefficients (<span
class="math inline">\(\hat{\beta}_0, \hat{\beta}_1\)</span>) were
calculated from a <strong>specific sample of data</strong>. If we
collected a different random sample from the same population, we would
get slightly different estimates.估计的系数 (<span
class="math inline">\(\hat{\beta}_0, \hat{\beta}_1\)</span>)
是根据<strong>特定的数据样本</strong>计算出来的。如果我们从同一总体中随机抽取不同的样本，我们得到的估计值会略有不同。</p>
<p>The goal of statistical inference is to use the estimates from our
single sample to make conclusions about the <strong>true, unknown
population parameters</strong> (<span class="math inline">\(\beta_0,
\beta_1\)</span>) and to quantify our uncertainty about
them.统计推断的目标是利用单个样本的估计值得出关于<strong>真实、未知的总体参数</strong>（<span
class="math inline">\(\beta_0,
\beta_1\)</span>）的结论，并量化对这些参数的不确定性。</p>
<h3
id="the-key-assumption-that-makes-it-possible-实现这一目标的关键假设">##
The Key Assumption That Makes It Possible 实现这一目标的关键假设</h3>
<p>To figure out the distribution of our estimates, we must make an
assumption about the distribution of the errors. This is the most
important assumption in linear regression for inference:
为了确定估计值的分布，必须对误差的分布做出假设。这是线性回归推断中最重要的假设：
<strong>Assumption:</strong> <span class="math inline">\(\epsilon_i
\stackrel{\text{i.i.d.}}{\sim} N(0, \sigma^2)\)</span></p>
<p>This means we assume the random error terms are: * <strong>Normally
distributed</strong> (<span class="math inline">\(N\)</span>).*
<strong>正态分布</strong>（<span class="math inline">\(N\)</span>）。 *
Have a mean of <strong>zero</strong> (our model is correct on average).*
均值为<strong>零</strong>（模型平均而言是正确的）。 * Have a constant
variance <strong><span class="math inline">\(\sigma^2\)</span></strong>
(homoscedasticity).* 方差为常数<strong><span
class="math inline">\(\sigma^2\)</span></strong>（方差齐性）。 * Are
<strong>independent and identically distributed</strong> (i.i.d.),
meaning each error is independent of the others.*
是<strong>独立同分布</strong>（i.i.d.）的，这意味着每个误差都独立于其他误差。</p>
<p><strong>Why is this important?</strong> Because our coefficients
<span class="math inline">\(\hat{\beta}_0\)</span> and <span
class="math inline">\(\hat{\beta}_1\)</span> are calculated as weighted
sums of the <span class="math inline">\(y_i\)</span> values, and the
<span class="math inline">\(y_i\)</span> values depend on the errors
<span class="math inline">\(\epsilon_i\)</span>. This assumption about
the errors allows us to prove that our estimated coefficients themselves
are also normally distributed. 系数 <span
class="math inline">\(\hat{\beta}_0\)</span> 和 <span
class="math inline">\(\hat{\beta}_1\)</span> 是通过 <span
class="math inline">\(y_i\)</span> 值的加权和计算的，而 <span
class="math inline">\(y_i\)</span> 值取决于误差 <span
class="math inline">\(\epsilon_i\)</span>。这个关于误差的假设使能够证明估计的系数本身也服从正态分布。</p>
<h3
id="the-solution-the-theorem-and-the-t-distribution-定理和-t-分布">##
The Solution: The Theorem and the t-distribution 定理和 t 分布</h3>
<p>The first slide provides the central theorem that allows us to
perform inference. It tells us exactly how to standardize our estimated
coefficients so they follow a known distribution.
第一张幻灯片提供了进行推断的核心定理。它准确地告诉我们如何对估计的系数进行标准化，使其服从已知的分布。</p>
<h4 id="the-standard-error-s.e.-标准误差-s.e.">1. The Standard Error
(s.e.) 标准误差 (s.e.)</h4>
<p>First, look at the denominators in the red dotted boxes. These are
the <strong>standard errors</strong> of the coefficients,
<code>s.e.($\hat&#123;\beta&#125;_1$)</code> and
<code>s.e.($\hat&#123;\beta&#125;_0$)</code>.
第一张幻灯片提供了进行推断的核心定理。它准确地告诉我们如何对估计的系数进行标准化，使其服从已知的分布。</p>
<ul>
<li><strong>What it is:</strong> The standard error is the estimated
<strong>standard deviation of the coefficient’s sampling
distribution</strong>. In simpler terms, it’s a measure of the average
amount by which our estimate <span
class="math inline">\(\hat{\beta}_1\)</span> would differ from the true
<span class="math inline">\(\beta_1\)</span> if we were to repeat the
experiment many times.
标准误差是系数抽样分布的<strong>标准差</strong>估计值。简单来说，它衡量的是如果我们重复实验多次，我们估计的
<span class="math inline">\(\hat{\beta}_1\)</span> 与真实的 <span
class="math inline">\(\beta_1\)</span> 之间的平均差异。</li>
<li><strong>A smaller standard error means a more precise and reliable
estimate.</strong>
<strong>标准误差越小，估计值越精确可靠。</strong></li>
</ul>
<h4 id="the-t-statistic-t-统计量">2. The t-statistic t 统计量</h4>
<p>The theorem shows two fractions that form a
<strong>t-statistic</strong>. The general structure for this is:
该定理展示了两个构成<strong>t 统计量</strong>的分数。其一般结构如下：
<span class="math display">\[t = \frac{\text{ (Sample Estimate - True
Value) }}{\text{ Standard Error of the Estimate }}\]</span></p>
<p>For <span class="math inline">\(\beta_1\)</span>, this is: <span
class="math inline">\(\frac{\hat{\beta}_1 -
\beta_1}{\text{s.e.}(\hat{\beta}_1)}\)</span>.</p>
<p>The key insight is that this specific quantity follows a
<strong>Student’s t-distribution</strong> with <strong><span
class="math inline">\(n-2\)</span> degrees of freedom</strong>.
关键在于，这个特定量服从<strong>学生 t
分布</strong>，其自由度为<strong><span
class="math inline">\(n-2\)</span>。 * </strong>Student’s
t-distribution:** This is a probability distribution that looks very
similar to the normal distribution but has slightly “heavier” tails. We
use it instead of the normal distribution because we had to
<em>estimate</em> the standard deviation of the errors (<code>s</code>
in the formula), which adds extra uncertainty.
这是一种概率分布，与正态分布非常相似，但尾部略重。使用它来代替正态分布，是因为必须<em>估计</em>误差的标准差（公式中的
<code>s</code>），这会增加额外的不确定性。 * <strong>Degrees of Freedom
(n-2):</strong> We start with <code>n</code> data points, but we lose
two degrees of freedom because we used the data to estimate two
parameters: <span class="math inline">\(\beta_0\)</span> and <span
class="math inline">\(\beta_1\)</span>. 从 <code>n</code>
个数据点开始，但由于用这些数据估计了两个参数：<span
class="math inline">\(\beta_0\)</span> 和 <span
class="math inline">\(\beta_1\)</span>，因此损失了两个自由度。 #### 3.
Estimating the Error Variance (<span
class="math inline">\(s^2\)</span>)估计误差方差 (<span
class="math inline">\(s^2\)</span>) To calculate the standard errors, we
need a value for <code>s</code>, which is our estimate of the true error
standard deviation <span class="math inline">\(\sigma\)</span>. This is
calculated from the <strong>Residual Sum of Squares (RSS)</strong>.
为了计算标准误差，我们需要一个 <code>s</code> 的值，它是对真实误差标准差
<span class="math inline">\(\sigma\)</span>
的估计值。该值由<strong>残差平方和 (RSS)</strong> 计算得出。 *
<strong>RSS:</strong> First, we calculate the RSS = <span
class="math inline">\(\sum(y_i - \hat{y}_i)^2\)</span>, which is the sum
of all the squared errors.* <strong>RSS</strong>：首先，计算 RSS = <span
class="math inline">\(\sum(y_i -
\hat{y}_i)^2\)</span>，即所有平方误差之和。 * <strong><span
class="math inline">\(s^2\)</span>:</strong> Then, we find the estimate
of the error variance: <span class="math inline">\(s^2 = \text{RSS} /
(n-2)\)</span>. We divide by <span class="math inline">\(n-2\)</span> to
get an unbiased estimate. * <strong><span
class="math inline">\(s^2\)</span></strong>：然后，计算误差方差的估计值：<span
class="math inline">\(s^2 = \text{RSS} / (n-2)\)</span>。我们将其除以
<span class="math inline">\(n-2\)</span> 即可得到无偏估计值。 *
<code>s</code> is simply the square root of <span
class="math inline">\(s^2\)</span>. This <code>s</code> is the value
used in the standard error formulas.* <code>s</code> 就是 <span
class="math inline">\(s^2\)</span> 的平方根。这个 <code>s</code>
是标准误差公式中使用的值。</p>
<h3 id="what-this-allows-us-to-do-the-practical-use">## What This Allows
Us To Do (The Practical Use)</h3>
<p>Because we know the exact distribution of our t-statistic, we can now
achieve our goal of quantifying uncertainty: 因为知道 t
统计量的精确分布，所以现在可以实现量化不确定性的目标：</p>
<ol type="1">
<li><strong>Hypothesis Testing:</strong> We can test if a predictor is
actually useful. The most common test is for the null hypothesis <span
class="math inline">\(H_0: \beta_1 = 0\)</span>. If we can prove the
observed <span class="math inline">\(\hat{\beta}_1\)</span> is very
unlikely to occur if the true <span
class="math inline">\(\beta_1\)</span> were zero, we can conclude there
is a statistically significant relationship between <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>.
可以检验一个预测变量是否真的有用。最常见的检验是零假设 <span
class="math inline">\(H_0: \beta_1 = 0\)</span>。如果能证明，当真实的
<span class="math inline">\(\beta_1\)</span> 为零时，观测到的 <span
class="math inline">\(\hat{\beta}_1\)</span>
不太可能发生，那么就可以得出结论，<span class="math inline">\(x\)</span>
和 <span class="math inline">\(y\)</span>
之间存在统计学上的显著关系。</li>
<li><strong>Confidence Intervals:</strong> We can construct a range of
plausible values for the true coefficient. For example, we can calculate
a 95% confidence interval for <span
class="math inline">\(\beta_1\)</span>. This gives us a range where we
are 95% confident the true value of <span
class="math inline">\(\beta_1\)</span> lies.
可以为真实系数构建一系列合理的值。</li>
</ol>
<h1 id="multiple-linear-regression">4. Multiple Linear Regression</h1>
<p><img src="/imgs/5054C3/Multiple_Linear Regression1.png" alt="Multiple_Linear Regression1">
<img src="/imgs/5054C3/Multiple_Linear Regression2.png" alt="Multiple_Linear Regression2">
## 4.1 Multiple Linear Regression - <strong>内容</strong>:
<strong>Multiple Linear Regression:</strong></p>
<p>Here’s a detailed breakdown that connects both slides.</p>
<h3
id="the-model-from-one-to-many-predictors-从单预测变量到多预测变量">##
The Model: From One to Many Predictors 从单预测变量到多预测变量</h3>
<p>The first slide introduces the <strong>Multiple Linear Regression
model</strong>. This is a direct extension of the simple model, but
instead of using just one predictor variable, we use multiple (<span
class="math inline">\(p\)</span>) predictors to explain our response
variable.
多元线性回归模型是简单模型的直接扩展，但不是只使用一个预测变量，而是使用多个（<span
class="math inline">\(p\)</span>）预测变量来解释响应变量。</p>
<p>The general formula is: <span class="math display">\[y_i = \beta_0 +
\beta_1x_{i1} + \beta_2x_{i2} + \dots + \beta_px_{ip} +
\epsilon_i\]</span></p>
<h4 id="key-change-in-interpretation">Key Change in Interpretation</h4>
<p>This is the most important new concept. In simple regression, <span
class="math inline">\(\beta_1\)</span> was just the slope. In multiple
regression, each coefficient has a more nuanced meaning:
在简单回归中，<span class="math inline">\(\beta_1\)</span>
只是斜率。在多元回归中，每个系数都有更微妙的含义：</p>
<p><strong><span class="math inline">\(\beta_j\)</span> is the average
change in <span class="math inline">\(y\)</span> for a one-unit increase
in <span class="math inline">\(x_j\)</span>, while holding all other
predictors constant.</strong></p>
<p>This is incredibly powerful. Using the advertising example from your
slide: * <span class="math inline">\(y_i = \beta_0 +
\beta_1(\text{TV}_i) + \beta_2(\text{Radio}_i) +
\beta_3(\text{Newspaper}_i) + \epsilon_i\)</span> * <span
class="math inline">\(\beta_1\)</span> represents the effect of TV
advertising on sales, <strong>after controlling for</strong> the amount
spent on Radio and Newspaper ads. This allows you to isolate the unique
contribution of each advertising
channel.表示在<strong>控制</strong>广播和报纸广告支出后，电视广告对销售额的影响。这可以让您区分每个广告渠道的独特贡献。</p>
<h3 id="the-solution-deriving-the-normal-equation-推导正态方程">## The
Solution: Deriving the Normal Equation 推导正态方程</h3>
<p>The second slide shows the mathematical process for finding the best
coefficients (<span class="math inline">\(\beta_0, \beta_1, \dots,
\beta_p\)</span>) using the <strong>Ordinary Least Squares
(OLS)</strong> method. It’s essentially a condensed derivation of the
<strong>Normal Equation</strong>. 使用<strong>普通最小二乘法
(OLS)</strong> 寻找最佳系数 (<span class="math inline">\(\beta_0,
\beta_1, \dots, \beta_p\)</span>)
的数学过程。它本质上是<strong>正态方程</strong>的简化推导。</p>
<h4 id="the-goal-minimizing-the-sum-of-squares-最小化平方和">1. The
Goal: Minimizing the Sum of Squares 最小化平方和</h4>
<p>Just like before, our goal is to minimize the sum of the squared
errors (or residuals): 目标是最小化平方误差（或残差）之和。</p>
<ul>
<li><strong>Scalar Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1x_{i1} -
\beta_2x_{i2} - \beta_3x_{i3})^2\)</span>
<ul>
<li>This is easy to read but gets very long with more variables.
代码易于阅读，但变量越多，代码越长。</li>
</ul></li>
<li><strong>Vector Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \boldsymbol{\beta}^T
\mathbf{x}_i)^2\)</span>
<ul>
<li>This is a more compact and powerful way to write the same thing
using linear algebra, where <span
class="math inline">\(\boldsymbol{\beta}^T \mathbf{x}_i\)</span> is the
dot product that calculates the entire predicted value <span
class="math inline">\(\hat{y}_i\)</span>.
这是一种更简洁、更强大的线性代数表示方法，其中 <span
class="math inline">\(\boldsymbol{\beta}^T \mathbf{x}_i\)</span>
是计算整个预测值 <span class="math inline">\(\hat{y}_i\)</span>
的点积。</li>
</ul></li>
</ul>
<h4
id="the-method-using-calculus-to-find-the-minimum-使用微积分求最小值">2.
The Method: Using Calculus to Find the Minimum 使用微积分求最小值</h4>
<p>To find the set of <span class="math inline">\(\beta\)</span> values
that results in the lowest possible error, we use calculus.</p>
<ul>
<li><p><strong>The Derivative (Gradient):</strong> Since our error
function depends on multiple <span class="math inline">\(\beta\)</span>
coefficients, we can’t take a simple derivative. Instead, we take the
<strong>gradient</strong>, which is a vector of partial derivatives (one
for each coefficient). This tells us the “slope” of the error function
in every direction. 导数（梯度） 误差函数依赖于多个 <span
class="math inline">\(\beta\)</span>
系数，因此我们不能简单地求导数。相反，采用<strong>梯度</strong>，它是一个由偏导数组成的向量（每个系数对应一个偏导数）。这告诉误差函数在各个方向上的“斜率”。</p></li>
<li><p><strong>Setting the Gradient to Zero:</strong> The minimum of a
function occurs where its slope is zero (the very bottom of the error
“valley”). The slide shows the result of taking this gradient and
setting it to
zero.函数的最小值出现在其斜率为零的地方（即误差“谷底”的最低点）。幻灯片展示了取此梯度并将其设为零的结果。</p></li>
</ul>
<p>The equation shown on the slide: <span class="math display">\[2
\sum_{i=1}^{n} (\boldsymbol{\beta}^T \mathbf{x}_i - y_i)\mathbf{x}_i^T =
0\]</span> …is the result of this calculus step. The goal is now to
algebraically rearrange this equation to solve for <span
class="math inline">\(\boldsymbol{\beta}\)</span>.
是这一微积分步骤的结果。现在的目标是用代数方法重新排列这个方程，以求解
<span class="math inline">\(\boldsymbol{\beta}\)</span>。</p>
<h4 id="the-result-the-normal-equation-正则方程">3. The Result: The
Normal Equation 正则方程</h4>
<p>After rearranging the equation from the previous step and expressing
the sums in their full matrix form, we arrive at a clean and beautiful
solution. While the slide doesn’t show the final step, the result of
“Setting the gradient zero and solve <span
class="math inline">\(\beta\)</span>” is the <strong>Normal
Equation</strong>:
重新排列上一步中的方程，并将和表示为完整的矩阵形式后，得到了一个简洁美观的解。虽然幻灯片没有展示最后一步，“设置梯度零点并求解
<span class="math inline">\(\beta\)</span>”
的结果就是<strong>正态方程</strong>：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> is the
vector of our optimal coefficient estimates.</li>
<li><span class="math inline">\(\mathbf{X}\)</span> is the “design
matrix” where each row is an observation and each column is a predictor
variable. <span class="math inline">\(\mathbf{X}\)</span>
是“设计矩阵”，其中每一行代表一个观测值，每一列代表一个预测变量。</li>
<li><span class="math inline">\(\mathbf{y}\)</span> is the vector of our
response variable. <span class="math inline">\(\mathbf{y}\)</span>
是我们的响应变量的向量。</li>
</ul>
<p>This single equation is the general solution for finding the OLS
coefficients for <strong>any</strong> linear regression model, no matter
how many predictors you have. This is what statistical software
calculates for you under the hood.
无论有多少个预测变量，这个简单的方程都是<strong>任何</strong>线性回归模型中
OLS 系数的通解。</p>
<h1 id="matrix-notatio">5. matrix notatio</h1>
<p><img src="/imgs/5054C3/matrix_notatio.png"></p>
<ul>
<li><strong>内容</strong>: This slide introduces the <strong>matrix
notation</strong> for multiple linear regression, which is a powerful
way to represent the entire system of equations in a compact form. This
notation isn’t just for tidiness—it’s the foundation for how the
solutions are derived and calculated in software.</li>
</ul>
<p>多元线性回归的<strong>矩阵符号</strong>，这是一种以紧凑形式表示整个方程组的有效方法。这种符号不仅仅是为了简洁，它还是软件中推导和计算解的基础。
Here is a more detailed breakdown.</p>
<h3 id="why-use-matrix-notation">## Why Use Matrix Notation?</h3>
<p>Imagine you have 10,000 observations (<span
class="math inline">\(n=10,000\)</span>) and 5 predictor variables
(<span class="math inline">\(p=5\)</span>). Writing out the model
equation for each observation would be impossible: <span
class="math inline">\(y_1 = \beta_0 + \beta_1x_{11} + \dots +
\beta_5x_{15} + \epsilon_1\)</span> <span class="math inline">\(y_2 =
\beta_0 + \beta_1x_{21} + \dots + \beta_5x_{25} + \epsilon_2\)</span>
…and so on for 10,000 lines.</p>
<p>假设你有 10,000 个观测值（n=10,000）和 5
个预测变量（p=5）。为每个观测值写出模型方程是不可能的： <span
class="math inline">\(y_1 = \beta_0 + \beta_1x_{11} + \dots +
\beta_5x_{15} + \epsilon_1\)</span> <span class="math inline">\(y_2 =
\beta_0 + \beta_1x_{21} + \dots + \beta_5x_{25} + \epsilon_2\)</span>
……以此类推，直到 10,000 行。 Matrix notation allows us to consolidate
this entire system into a single, elegant
equation:矩阵符号使我们能够将整个系统合并成一个简洁的方程： <span
class="math display">\[\mathbf{y} = \mathbf{X}\boldsymbol{\beta} +
\boldsymbol{\epsilon}\]</span> Let’s break down each component shown on
your slide.</p>
<h3 id="the-components-explained">## The Components Explained</h3>
<h4 id="the-design-matrix-mathbfx-设计矩阵">1. The Design Matrix: <span
class="math inline">\(\mathbf{X}\)</span> 设计矩阵</h4>
<p><span class="math display">\[\mathbf{X} = \begin{pmatrix} 1 &amp;
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\ 1 &amp; x_{21} &amp;
x_{22} &amp; \cdots &amp; x_{2p} \\ \vdots &amp; \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots
&amp; x_{np} \end{pmatrix}\]</span> This is the most important matrix.
It contains all of your predictor variable
data.这是最重要的矩阵。它包含所有预测变量数据。 * <strong>Rows:</strong>
Each row represents a single observation (e.g., a person, a company, a
day). There are <strong>n</strong>
rows.每一行代表一个观察值（例如，一个人、一家公司、一天）。共有
<strong>n</strong> 行。 * <strong>Columns:</strong> Each column
represents a predictor variable. There are <strong>p</strong> predictor
columns, plus one special column.每列代表一个预测变量。共有
<strong>p</strong> 个预测列，外加一个特殊列。 * <strong>The Column of
Ones:</strong> This is a crucial detail. This first column of all ones
is a placeholder for the <strong>intercept term (<span
class="math inline">\(\beta_0\)</span>)</strong>. When you perform
matrix multiplication, this <code>1</code> gets multiplied by <span
class="math inline">\(\beta_0\)</span>, ensuring the intercept is
included in the model for every single observation.
这是一个至关重要的细节。第一列（全 1）是<strong>截距项 (<span
class="math inline">\(\beta_0\)</span>)</strong>
的占位符。执行矩阵乘法时，这个 <code>1</code> 会乘以 <span
class="math inline">\(\beta_0\)</span>，以确保截距包含在模型中，适用于每个观测值。</p>
<h4 id="the-coefficient-vector-boldsymbolbeta-系数向量">2. The
Coefficient Vector: <span
class="math inline">\(\boldsymbol{\beta}\)</span> 系数向量</h4>
<p><span class="math display">\[\boldsymbol{\beta} = \begin{pmatrix}
\beta_0 \\ \beta_1 \\ \vdots \\ \beta_p \end{pmatrix}\]</span> This is a
column vector that contains all the model parameters—the unknown values
we want to estimate. The goal of linear regression is to find the
numerical values for this vector.</p>
<h4 id="the-response-vector-mathbfy-响应向量">3. The Response Vector:
<span class="math inline">\(\mathbf{y}\)</span> 响应向量</h4>
<p><span class="math display">\[\mathbf{y} = \begin{pmatrix} y_1 \\
\vdots \\ y_n \end{pmatrix}\]</span> This is a column vector containing
all the observed outcomes you are trying to predict (e.g., sales, test
scores, stock prices).</p>
<h4 id="the-error-vector-boldsymbolepsilon-误差向量">4. The Error
Vector: <span class="math inline">\(\boldsymbol{\epsilon}\)</span>
误差向量</h4>
<p><span class="math display">\[\boldsymbol{\epsilon} = \begin{pmatrix}
\epsilon_1 \\ \vdots \\ \epsilon_n \end{pmatrix}\]</span> This column
vector bundles together all the individual, unobserved random errors. It
represents the portion of <strong>y</strong> that our model cannot
explain with <strong>X</strong>.</p>
<h3 id="putting-it-all-together">## Putting It All Together</h3>
<p>When you write the equation <span class="math inline">\(\mathbf{y} =
\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\epsilon}\)</span>, you are
actually representing the entire system of individual equations.</p>
<p>Let’s look at the multiplication <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>: <span
class="math display">\[\begin{pmatrix} 1 &amp; x_{11} &amp; \dots &amp;
x_{1p} \\ 1 &amp; x_{21} &amp; \dots &amp; x_{2p} \\ \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 1 &amp; x_{n1} &amp; \dots &amp; x_{np}
\end{pmatrix} \begin{pmatrix} \beta_0 \\ \beta_1 \\ \vdots \\ \beta_p
\end{pmatrix} = \begin{pmatrix} 1\cdot\beta_0 + x_{11}\cdot\beta_1 +
\dots + x_{1p}\cdot\beta_p \\ 1\cdot\beta_0 + x_{21}\cdot\beta_1 + \dots
+ x_{2p}\cdot\beta_p \\ \vdots \\ 1\cdot\beta_0 + x_{n1}\cdot\beta_1 +
\dots + x_{np}\cdot\beta_p \end{pmatrix}\]</span> As you can see, the
result of this multiplication is a single column vector where each row
is the “predictor” part of the regression equation for that observation.
此乘法的结果是一个单列向量，其中每一行都是该观测值的回归方程的“预测变量”部分。</p>
<p>By setting this equal to <span class="math inline">\(\mathbf{y} -
\boldsymbol{\epsilon}\)</span>, you perfectly recreate the entire set of
<code>n</code> equations in one clean statement. This compact form is
what allows us to easily derive and compute the <strong>Normal
Equation</strong> solution: <span
class="math inline">\(\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\)</span>.这种紧凑形式使我们能够轻松推导和计算<strong>正态方程</strong>的解</p>
<h1
id="the-core-mathematical-conclusion-of-ordinary-least-squares-ols">6.
the core mathematical conclusion of Ordinary Least Squares (OLS)</h1>
<p><img src="/imgs/5054C3/OLS1.png">
<img src="/imgs/5054C3/OLS2.png"></p>
<ul>
<li><strong>内容</strong>: Of course. These slides present the core
mathematical conclusion of Ordinary Least Squares (OLS) and a key
geometric property that explains <em>why</em> this solution works.
展示了普通最小二乘法 (OLS)
的核心数学结论，以及一个关键的几何性质，解释了该解决方案<em>为何</em>有效。
Let’s break down the concepts and the calculation processes in
detail.</li>
</ul>
<hr />
<h3 id="part-1-the-objective-and-the-solution-slide-1-最小化几何距离">##
Part 1: The Objective and the Solution (Slide 1) 最小化几何距离</h3>
<p>This slide summarizes the entire OLS problem and its solution in the
language of matrix algebra.</p>
<h4 id="the-concept-minimizing-geometric-distance"><strong>The Concept:
Minimizing Geometric Distance</strong></h4>
<p>“最小二乘准则”是我们模型的目标。 The “least squares criterion” is the
objective of our model. The slide shows it in two equivalent forms:</p>
<ol type="1">
<li><strong>Summation Form:</strong> <span
class="math inline">\(\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1x_{i1} -
\dots - \beta_px_{ip})^2\)</span> This is the sum of the squared
differences between the actual values (<span
class="math inline">\(y_i\)</span>) and the predicted values. 这是实际值
(<span class="math inline">\(y_i\)</span>) 与预测值之差的平方和。</li>
<li><strong>Matrix Form:</strong> <span
class="math inline">\(||\mathbf{y} - \mathbf{X}\boldsymbol{\beta}||^2 =
(\mathbf{y} - \mathbf{X}\boldsymbol{\beta})^T(\mathbf{y} -
\mathbf{X}\boldsymbol{\beta})\)</span> This is the more powerful way to
view the problem. Think of <span
class="math inline">\(\mathbf{y}\)</span> (the vector of all actual
outcomes) and <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span> (the vector
of all predicted outcomes) as two points in an n-dimensional space. The
expression <span class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{\beta}||^2\)</span> represents the <strong>squared
Euclidean distance</strong> between these two points. 将 <span
class="math inline">\(\mathbf{y}\)</span>（所有实际结果的向量）和 <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>（所有预测结果的向量）视为
n 维空间中的两个点。表达式 <span class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{\beta}||^2\)</span>
表示这两点之间的<strong>平方欧氏距离</strong>。 Therefore, the OLS
problem is a geometric one: <strong>Find the coefficient vector <span
class="math inline">\(\boldsymbol{\beta}\)</span> that makes the
predicted values vector <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span> as close as
possible to the actual values vector <span
class="math inline">\(\mathbf{y}\)</span>.</strong> 因此，OLS
问题是一个几何问题：<strong>找到一个系数向量 <span
class="math inline">\(\boldsymbol{\beta}\)</span>，使预测值向量 <span
class="math inline">\(\mathbf{X}\boldsymbol{\beta}\)</span>
尽可能接近实际值向量 <span
class="math inline">\(\mathbf{y}\)</span>。</strong></li>
</ol>
<h4
id="the-solution-the-least-squares-estimator-lse最小二乘估计器-lse"><strong>The
Solution: The Least Squares Estimator (LSE)</strong>最小二乘估计器
(LSE)</h4>
<p>The slide provides the direct solution to this minimization problem,
which is the <strong>Normal
Equation</strong>:此最小化问题的直接解，即<strong>正态方程</strong>：</p>
<p><span class="math display">\[\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\]</span></p>
<p>This formula gives you the exact vector of coefficients <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> that minimizes
the squared distance. We get this formula by taking the gradient (the
multidimensional version of a derivative) of the distance function with
respect to <span class="math inline">\(\boldsymbol{\beta}\)</span>,
setting it to zero, and solving, as hinted at in your previous slides.
给出了使平方距离最小化的精确系数向量 通过取距离函数关于 <span
class="math inline">\(\boldsymbol{\beta}\)</span>
的梯度（导数的多维版本），将其设为零，然后求解，即可得到此公式。
Finally, the slide defines: * <strong>Fitted values:</strong> <span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span> (The vector of predictions
using our optimal coefficients). 拟合值 * <strong>Residuals:</strong>
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span> (The vector of errors, representing the
difference between actuals and
predictions).误差向量，表示实际值与预测值之间的差异</p>
<h3
id="part-2-the-geometric-property-and-proofs-slide-2几何性质及证明">##
Part 2: The Geometric Property and Proofs (Slide 2)几何性质及证明</h3>
<p>This slide explains a beautiful and fundamental property of the least
squares solution:
<strong>orthogonality</strong>.解释了最小二乘解的一个美妙而基本的性质：<strong>正交性</strong>。</p>
<h4 id="the-concept-orthogonality-of-residuals残差的正交性"><strong>The
Concept: Orthogonality of Residuals</strong>残差的正交性</h4>
<p>The main idea is that the residual vector <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> is
<strong>orthogonal</strong> (perpendicular) to every predictor variable
in your model. 主要思想是残差向量 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>
与模型中的每个预测变量<strong>正交</strong>（垂直）。</p>
<ul>
<li><p><strong>Geometric Intuition:</strong> Think of the columns of
your matrix <span class="math inline">\(\mathbf{X}\)</span> (i.e., your
predictors and the intercept) as defining a flat surface, or a
“hyperplane,” in a high-dimensional space. Your actual data vector <span
class="math inline">\(\mathbf{y}\)</span> exists somewhere in this
space, likely not on the hyperplane. The OLS process finds the point on
that hyperplane, <span class="math inline">\(\hat{\mathbf{y}}\)</span>,
that is closest to <span class="math inline">\(\mathbf{y}\)</span>. The
shortest line from a point to a plane is always one that is
<strong>perpendicular</strong> to the plane. The residual vector, <span
class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>, <em>is</em> that line. 将矩阵 <span
class="math inline">\(\mathbf{X}\)</span>
的列（即预测变量和截距）想象成在高维空间中定义一个平面或“超平面”。实际数据向量
<span class="math inline">\(\mathbf{y}\)</span>
存在于该空间的某个位置，可能不在超平面上。OLS 过程会在该超平面 <span
class="math inline">\(\hat{\mathbf{y}}\)</span> 上找到与 <span
class="math inline">\(\mathbf{y}\)</span>
最接近的点。从一个点到一个平面的最短线始终是与该平面<strong>垂直</strong>的线。残差向量
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span> 就是这条直线。</p></li>
<li><p><strong>Mathematical Statement:</strong> This geometric property
is stated as <span class="math inline">\(\mathbf{X}^T
\hat{\boldsymbol{\epsilon}} = \mathbf{0}\)</span>. This equation means
that the dot product of the residual vector with every column of <span
class="math inline">\(\mathbf{X}\)</span> is zero, which is the
mathematical definition of orthogonality. 该等式意味着残差向量与 <span
class="math inline">\(\mathbf{X}\)</span>
每一列的点积都为零，这正是正交性的数学定义。</p></li>
</ul>
<h4 id="the-calculation-process-the-proofs"><strong>The Calculation
Process (The Proofs)</strong></h4>
<p><strong>1. Proof of Orthogonality:</strong> The slide shows a
step-by-step calculation to prove that <span
class="math inline">\(\mathbf{X}^T \hat{\boldsymbol{\epsilon}}\)</span>
is indeed zero. * <strong>Step 1:</strong> Start with the expression to
be proven: <span class="math inline">\(\mathbf{X}^T
\hat{\boldsymbol{\epsilon}}\)</span> 从待证明的表达式开始： *
<strong>Step 2:</strong> Substitute the definition of the residual,
<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\mathbf{X}^T (\mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}})\]</span> 代入残差的定义 *
<strong>Step 3:</strong> Distribute the <span
class="math inline">\(\mathbf{X}^T\)</span>: <span
class="math display">\[\mathbf{X}^T \mathbf{y} -
\mathbf{X}^T\mathbf{X}\hat{\boldsymbol{\beta}}\]</span><em>分配 </em>
<strong>Step 4:</strong> Substitute the Normal Equation for <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\mathbf{X}^T \mathbf{y} - \mathbf{X}^T\mathbf{X}
[(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}]\]</span> *
<strong>Step 5:</strong> The key step is the cancellation. A matrix
<span class="math inline">\((\mathbf{X}^T\mathbf{X})\)</span> multiplied
by its inverse <span
class="math inline">\((\mathbf{X}^T\mathbf{X})^{-1}\)</span> equals the
identity matrix <span class="math inline">\(\mathbf{I}\)</span>, which
acts like the number 1 in multiplication. <span
class="math display">\[\mathbf{X}^T \mathbf{y} - \mathbf{I}
\mathbf{X}^T\mathbf{y} = \mathbf{X}^T \mathbf{y} -
\mathbf{X}^T\mathbf{y} = \mathbf{0}\]</span> 关键步骤是消去。 This
completes the proof, showing that the orthogonality property is a direct
consequence of the Normal Equation solution.</p>
<p><strong>2. Proof of LSE:</strong> This is a more abstract proof
showing that our <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> truly gives the
minimum possible error. It uses the orthogonality property and the
Pythagorean theorem for vectors. It essentially shows that for any other
possible coefficient vector <span
class="math inline">\(\boldsymbol{v}\)</span>, the error <span
class="math inline">\(||\mathbf{y} -
\mathbf{X}\boldsymbol{v}||^2\)</span> will always be greater than or
equal to the error from our LSE, <span
class="math inline">\(||\mathbf{y} -
\mathbf{X}\hat{\boldsymbol{\beta}}||^2\)</span>.</p>
<h1 id="geometric-interpretation">7.geometric interpretation</h1>
<p><img src="/imgs/5054C3/geometric_interpretation1.png">
<img src="/imgs/5054C3/geometric_interpretation2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These two slides together provide a powerful geometric interpretation
of how Ordinary Least Squares (OLS) works, centered on the concepts of
<strong>orthogonality</strong> and <strong>projection</strong>.
以<strong>正交性</strong>和<strong>投影</strong>的概念为中心，从几何角度有力地诠释了普通最小二乘法
(OLS) 的工作原理。</p>
<p>Here’s a detailed summary of the concepts and the processes they
describe.</p>
<h3 id="summary">## Summary</h3>
<p>These slides explain that the process of finding the “best fit” line
in regression is geometrically equivalent to <strong>projecting</strong>
the actual data vector (<span class="math inline">\(\mathbf{y}\)</span>)
onto a hyperplane defined by the predictor variables (<span
class="math inline">\(\mathbf{X}\)</span>). This projection splits the
actual data into two perpendicular components:
解释了回归分析中寻找“最佳拟合”直线的过程，其几何意义等同于将实际数据向量
(<span class="math inline">\(\mathbf{y}\)</span>)
<strong>投影</strong>到由预测变量 (<span
class="math inline">\(\mathbf{X}\)</span>)
定义的超平面上。此投影将实际数据拆分为两个垂直分量：</p>
<ol type="1">
<li><strong>The Fitted Values (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>):</strong> The part of
the data that is perfectly explained by the model (the projection).
数据中能够被模型完美解释的部分（投影）。</li>
<li><strong>The Residuals (<span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>):</strong>
The part of the data that is unexplained (the error), which is
perpendicular to the explained part.
数据中无法解释的部分（误差），它与被解释部分垂直。 A special tool called
the <strong>projection matrix (H)</strong>, or “hat matrix,” is
introduced as the operator that performs this projection.
引入一个称为<strong>投影矩阵
(H)</strong>（或称“帽子矩阵”）的特殊工具，作为执行此投影的运算符。</li>
</ol>
<h3 id="concepts-and-process-explained-in-detail">## Concepts and
Process Explained in Detail</h3>
<h4 id="the-fitted-values-as-a-linear-combination-拟合值作为线性组合">1.
The Fitted Values as a Linear Combination 拟合值作为线性组合</h4>
<p>The first slide starts by stating that the fitted value vector <span
class="math inline">\(\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}}\)</span> is a <strong>linear
combination</strong> of the columns of <span
class="math inline">\(\mathbf{X}\)</span> (your predictors).</p>
<ul>
<li><p><strong>Concept:</strong> This means that the vector of fitted
values, <span class="math inline">\(\hat{\mathbf{y}}\)</span>, must lie
within the geometric space (a line, plane, or hyperplane) spanned by
your predictor variables. The model is incapable of producing a
prediction that does not live in this space. 这意味着拟合值向量 <span
class="math inline">\(\hat{\mathbf{y}}\)</span>
必须位于预测变量所构成的几何空间（直线、平面或超平面）内。模型无法生成不存在于此空间的预测。
#### 2. The Projection Matrix (The “Hat Matrix”) 投影矩阵（“帽子矩阵”）
The second slide introduces the tool that makes this projection happen:
the <strong>projection matrix</strong>, also called the <strong>hat
matrix</strong>, <strong>H</strong>.</p></li>
<li><p><strong>Definition:</strong> <span
class="math inline">\(\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span></p></li>
<li><p><strong>Process:</strong> This matrix has a special job. When you
multiply it by any vector (like our data vector <span
class="math inline">\(\mathbf{y}\)</span>), it projects that vector onto
the space spanned by the columns of <span
class="math inline">\(\mathbf{X}\)</span>. We can see this by starting
with our definition of fitted values and substituting the normal
equation solution for <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>: <span
class="math display">\[\hat{\mathbf{y}} =
\mathbf{X}\hat{\boldsymbol{\beta}} =
\mathbf{X}[(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}] =
[\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T]\mathbf{y}\]</span>
This shows that: <span class="math display">\[\hat{\mathbf{y}} =
\mathbf{H}\mathbf{y}\]</span> This is why <strong>H</strong> is
nicknamed the <strong>hat matrix</strong>—it “puts the hat” on <span
class="math inline">\(\mathbf{y}\)</span>.
这个矩阵有其特殊的用途。当你将它乘以任何向量（例如我们的数据向量 <span
class="math inline">\(\mathbf{y}\)</span>）时，它会将该向量投影到由
<span class="math inline">\(\mathbf{X}\)</span> 的列所跨越的空间上。
#### 3. The Orthogonality of Fitted Values and Residuals
拟合值和残差的正交性 This is the central concept of the first slide and
a fundamental property of least squares.</p></li>
<li><p><strong>Concept:</strong> The fitted value vector (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) and the residual vector
(<span class="math inline">\(\hat{\boldsymbol{\epsilon}} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>) are <strong>orthogonal</strong>
(perpendicular) to each other.</p></li>
<li><p><strong>Mathematical Statement:</strong> Their dot product is
zero: <span class="math inline">\(\hat{\mathbf{y}}^T(\mathbf{y} -
\hat{\mathbf{y}}) = 0\)</span>.</p></li>
<li><p><strong>Geometric Intuition:</strong> This means the vectors
<span class="math inline">\(\mathbf{y}\)</span>, <span
class="math inline">\(\hat{\mathbf{y}}\)</span>, and <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> form a
<strong>right-angled triangle</strong> in n-dimensional space. The
actual data vector <span class="math inline">\(\mathbf{y}\)</span> is
the hypotenuse, while the model’s prediction <span
class="math inline">\(\hat{\mathbf{y}}\)</span> and the error <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> are the two
perpendicular legs. 这意味着向量 <span
class="math inline">\(\mathbf{y}\)</span>、<span
class="math inline">\(\hat{\mathbf{y}}\)</span> 和 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span> 在 n
维空间中构成一个<strong>直角三角形</strong>。实际数据向量 <span
class="math inline">\(\mathbf{y}\)</span> 是斜边，而模型的预测值 <span
class="math inline">\(\hat{\mathbf{y}}\)</span> 和误差值 <span
class="math inline">\(\hat{\boldsymbol{\epsilon}}\)</span>
是两条垂直边。</p></li>
</ul>
<h4 id="the-pythagorean-theorem-of-least-squares">4. The Pythagorean
Theorem of Least Squares</h4>
<p>The orthogonality relationship directly implies the Pythagorean
theorem.</p>
<ul>
<li><strong>Formula:</strong> <span
class="math inline">\(||\mathbf{y}||^2 = ||\hat{\mathbf{y}}||^2 +
||\mathbf{y} - \hat{\mathbf{y}}||^2\)</span></li>
<li><strong>Concept:</strong> This is one of the most important
equations in statistics, as it partitions the total variance in the
data. 这是统计学中最重要的方程之一，因为它可以分割数据中的总方差。
<ul>
<li><span class="math inline">\(||\mathbf{y}||^2\)</span> is
proportional to the <strong>Total Sum of Squares (TSS):</strong> The
total variation of the response variable around its
mean.响应变量围绕其均值的总变异。</li>
<li><span class="math inline">\(||\hat{\mathbf{y}}||^2\)</span> is
proportional to the <strong>Explained Sum of Squares (ESS):</strong> The
portion of the total variation that is explained by your regression
model.回归模型可以解释的总变异部分。</li>
<li><span class="math inline">\(||\mathbf{y} -
\hat{\mathbf{y}}||^2\)</span> is the <strong>Residual Sum of Squares
(RSS):</strong> The portion of the total variation that is left
unexplained (the error).总变异中未解释的部分（即误差）。</li>
</ul></li>
</ul>
<p>This relationship, <strong>Total Variation = Explained Variation +
Unexplained Variation</strong>, is the foundation for calculating
metrics like <strong>R-squared (<span
class="math inline">\(R^2\)</span>)</strong>, which measures the
goodness of fit of your model. <strong>总变异 = 解释变异 +
未解释变异</strong>，是计算<strong>R 平方 (<span
class="math inline">\(R^2\)</span>)</strong>
等指标的基础，该指标用于衡量模型的拟合优度。</p>
<h4 id="residuals-and-the-identity-matrix-残差和单位矩阵">5. Residuals
and the Identity Matrix 残差和单位矩阵</h4>
<p>Finally, the second slide shows that just as <strong>H</strong>
projects onto the “model space,” a related matrix projects onto the
“error space.” 最后，第二张幻灯片显示，正如<strong>H</strong>
投影到“模型空间”一样，相关矩阵也会投影到“误差空间”。 *
<strong>Process:</strong> We can express the residuals using the hat
matrix: <span class="math display">\[\hat{\boldsymbol{\epsilon}} =
\mathbf{y} - \hat{\mathbf{y}} = \mathbf{y} - \mathbf{H}\mathbf{y} =
(\mathbf{I} - \mathbf{H})\mathbf{y}\]</span> The matrix <span
class="math inline">\((\mathbf{I} - \mathbf{H})\)</span> is also a
projection matrix. It takes the original data vector <span
class="math inline">\(\mathbf{y}\)</span> and projects it onto the space
that is orthogonal to all of your predictors, giving you the residual
vector directly.</p>
<h1
id="visualization-of-ordinary-least-squares-ols-regression">8.visualization
of Ordinary Least Squares (OLS) regression</h1>
<p><img src="/imgs/5054C3/visualization_of_Ordinary_Least_Squares_(OLS)_regression.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>This slide provides an excellent geometric visualization of what’s
happening “under the hood” in Ordinary Least Squares (OLS) regression.
It translates the algebraic formulas into a more intuitive spatial
concept. 这张幻灯片以出色的几何可视化方式展现了普通最小二乘 (OLS)
回归的“幕后”机制。它将代数公式转化为更直观的空间概念。</p>
<h3 id="summary-1">## Summary</h3>
<p>The image shows that the process of finding the least squares
estimates is geometrically equivalent to taking the <strong>actual
outcome vector</strong> (<span
class="math inline">\(\mathbf{y}\)</span>) and finding its
<strong>orthogonal projection</strong> (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) onto a
<strong>hyperplane</strong> formed by the predictor variables (<span
class="math inline">\(\mathbf{x}_1\)</span> and <span
class="math inline">\(\mathbf{x}_2\)</span>). The projection <span
class="math inline">\(\hat{\mathbf{y}}\)</span> is the vector of fitted
values, representing the closest possible approximation of the real data
that the model can achieve.</p>
<p>该图显示，寻找最小二乘估计值的过程在几何上等同于将<strong>实际结果向量</strong>
(<span class="math inline">\(\mathbf{y}\)</span>)
求出其<strong>正交投影</strong> (<span
class="math inline">\(\hat{\mathbf{y}}\)</span>) 到由预测变量 (<span
class="math inline">\(\mathbf{x}_1\)</span> 和 <span
class="math inline">\(\mathbf{x}_2\)</span>
构成的<strong>超平面</strong>上。投影 <span
class="math inline">\(\hat{\mathbf{y}}\)</span>
是拟合值的向量，表示模型能够达到的与真实数据最接近的近似值。</p>
<h3 id="the-concepts-explained-spatially空间概念解释">## The Concepts
Explained Spatially空间概念解释</h3>
<p>Let’s break down each element of the diagram and its meaning:</p>
<h4 id="the-space-itself-空间本身">1. The Space Itself 空间本身</h4>
<ul>
<li><strong>Concept:</strong> We are not in a simple 2D or 3D graph
where axes are X and Y. Instead, we are in an <strong>n-dimensional
space</strong>, where <strong>n is the number of observations</strong>
in your dataset. Each axis in this space corresponds to one observation
(e.g., one person, one day).
我们并非身处一个简单的二维或三维图形中，其中坐标轴为 X 和
Y。相反，我们身处一个 <strong>n 维空间</strong>，其中 <strong>n
是数据集中的观测值数量</strong>。此空间中的每个轴对应一个观测值（例如，一个人，一天）。</li>
<li><strong>Meaning:</strong> A vector like <strong>y</strong> or
<strong>x₁</strong> is a single point in this high-dimensional space.
For example, if you have 50 data points, <strong>y</strong> is a vector
pointing to a specific location in a 50-dimensional space. 像
<strong>y</strong> 或 <strong>x₁</strong>
这样的向量是这个高维空间中的单个点。例如，如果您有 50
个数据点，<strong>y</strong> 就是指向 50 维空间中特定位置的向量。</li>
</ul>
<h4
id="the-predictor-hyperplane-the-yellow-surface预测变量超平面黄色表面">2.
The Predictor Hyperplane (The Yellow
Surface)预测变量超平面（黄色表面）</h4>
<ul>
<li><strong>Concept:</strong> The vectors for your predictor variables,
<strong>x₁</strong> and <strong>x₂</strong>, define a flat surface. If
you had only one predictor, this would be a line. With two, it’s a
plane. With more, it’s a <strong>hyperplane</strong>.预测变量的向量
<strong>x₁</strong> 和 <strong>x₂</strong>
定义了一个平面。如果只有一个预测变量，它就是一条线。如果有两个，它就是一个平面。如果有更多的预测变量，它就是一个<strong>超平面</strong>。</li>
<li><strong>Meaning:</strong> This yellow plane represents the
<strong>“world of possible predictions”</strong> that your model is
allowed to make. Any linear combination of your predictors—which is what
a linear regression model calculates—will result in a vector that lies
<em>somewhere</em> on this surface.
这个黄色平面代表你的模型可以做出的<strong>“可能预测的世界”</strong>。任何预测变量的线性组合（也就是线性回归模型计算的结果）都会产生一个位于这个平面<em>某处</em>的向量。
#### 3. The Actual Outcome Vector (y)实际结果向量 (y)</li>
<li><strong>Concept:</strong> The red vector <strong>y</strong>
represents your actual, observed data. It’s a single point in the
n-dimensional space. 红色向量 <strong>y</strong>
代表你实际观察到的数据。它是 n 维空间中的一个点。</li>
<li><strong>Meaning:</strong> Critically, this vector usually does
<strong>not</strong> lie on the predictor hyperplane. If it did, your
model would be a perfect fit with zero error. The fact that it’s “off
the plane” represents the real-world noise and variation that the model
cannot fully capture.
至关重要的是，这个向量通常<strong>不</strong>位于预测变量超平面上。如果它位于超平面上，你的模型将完美拟合，误差为零。它“偏离平面”代表了模型无法完全捕捉到的真实世界的噪声和变化。</li>
</ul>
<h4 id="the-fitted-value-vector-ŷ拟合值向量-ŷ">4. The Fitted Value
Vector (ŷ)拟合值向量 (ŷ)</h4>
<ul>
<li><strong>Concept:</strong> Since <strong>y</strong> is not on the
plane, we find the point on the plane that is <strong>geometrically
closest</strong> to <strong>y</strong>. This closest point is found by
dropping a perpendicular line from <strong>y</strong> to the plane. The
point where it lands is the <strong>orthogonal projection</strong>,
labeled <strong>ŷ</strong> (y-hat). 由于 <strong>y</strong>
不在平面上，因此我们在平面上找到与 <strong>y</strong>
<strong>几何上最接近的点。这个最接近点是通过从 </strong>y**
到平面做一条垂直线找到的。垂直线所在的点就是<strong>正交投影</strong>，标记为
<strong>ŷ</strong> (y-hat)。</li>
<li><strong>Meaning:</strong> <strong>ŷ is the vector of your model’s
fitted values.</strong> It is the “best” possible approximation of the
real data that can be created using the given predictors because it
minimizes the distance (and therefore the squared error) between the
actual data (<strong>y</strong>) and the model’s prediction. <strong>ŷ
是模型拟合值的向量。</strong>它是使用给定预测变量可以创建的对真实数据的“最佳”近似值，因为它最小化了实际数据
(<strong>y</strong>)
与模型预测值之间的距离（从而最小化了平方误差）。</li>
</ul>
<h4 id="the-residual-vector-the-dashed-line残差向量虚线">5. The Residual
Vector (The Dashed Line)残差向量（虚线）</h4>
<ul>
<li><strong>Concept:</strong> The dashed line connecting the tip of
<strong>y</strong> to the tip of <strong>ŷ</strong> is the
<strong>residual vector</strong> (<span
class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>). Its length is the shortest possible distance
from <strong>y</strong> to the hyperplane.
连接<strong>y</strong>顶点和<strong>ŷ</strong>顶点的虚线是<strong>残差向量</strong>
(<span class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>)。其长度是从<strong>y</strong>到超平面的最短可能距离。</li>
<li><strong>Meaning:</strong> This vector represents the
<strong>error</strong> of the model—the part of the actual data that is
left over after accounting for the predictors. The right-angle symbol
(└) is the most important part of the diagram, as it shows this error is
<strong>orthogonal</strong> (perpendicular) to the prediction and to all
the predictors. This visualizes the core property that the model’s
errors are uncorrelated with the predictors.
连接<strong>y</strong>顶点和<strong>ŷ</strong>顶点的虚线是<strong>残差向量</strong>
(<span class="math inline">\(\boldsymbol{\epsilon} = \mathbf{y} -
\hat{\mathbf{y}}\)</span>)。其长度是从<strong>y</strong>到超平面的最短可能距离。</li>
</ul>
<h1 id="singular-value-decomposition-svd-奇异值分解-svd">9.Singular
Value Decomposition (SVD) 奇异值分解 (SVD)</h1>
<p><img src="/imgs/5054C3/SVD1.png">
<img src="/imgs/5054C3/SVD2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides delve into the more advanced linear algebra behind the
projection matrix (<strong>H</strong>), explaining its fundamental
properties and offering a new way to construct it using <strong>Singular
Value Decomposition (SVD)</strong>. 探讨了投影矩阵 (<strong>H</strong>)
背后更高级的线性代数，解释了它的基本性质，并提供了一种使用<strong>奇异值分解
(SVD)</strong> 构造它的新方法。</p>
<h3 id="summary-2">## Summary</h3>
<p>These slides show that the <strong>projection matrix (H)</strong>,
which is central to least squares, has two key mathematical properties:
it’s <strong>symmetric</strong> and <strong>idempotent</strong>
(projecting twice is the same as projecting once). These properties
dictate that its eigenvalues must be either 1 or 0. Singular Value
Decomposition (SVD) of the data matrix <strong>X</strong> provides an
elegant and numerically stable way to express <strong>H</strong> as
<strong>UUᵀ</strong>, which makes these fundamental properties easier to
understand and prove. 这些幻灯片展示了<strong>投影矩阵
(H)</strong>（最小二乘法的核心）的两个关键数学性质：<strong>对称</strong>和<strong>幂等</strong>（投影两次等于投影一次）。这些性质决定了它的特征值必须为
1 或 0。数据矩阵 <strong>X</strong> 的奇异值分解 (SVD)
提供了一种优雅且数值稳定的方式，将<strong>H</strong> 表示为
<strong>UUᵀ</strong>，这使得这些基本性质更容易理解和证明。</p>
<h3 id="concepts-and-process-explained-in-detail-1">## Concepts and
Process Explained in Detail</h3>
<h4 id="singular-value-decomposition-svd">1. Singular Value
Decomposition (SVD)</h4>
<p>The first slide introduces SVD, a powerful method for factoring any
matrix.</p>
<ul>
<li><strong>Concept:</strong> SVD breaks down your data matrix
<strong>X</strong> into three simpler matrices: <strong>X =
UDVᵀ</strong>. Think of this as revealing the fundamental structure of
your data.SVD 将数据矩阵 <strong>X</strong>
分解为三个更简单的矩阵：<strong>X =
UDVᵀ</strong>。这可以理解为揭示数据的基本结构。
<ul>
<li><strong>U:</strong> An <strong>orthogonal matrix</strong> whose
columns form a perfect, orthonormal basis for the space spanned by your
predictors (the column space of <strong>X</strong>). These columns
represent the principal directions of your data’s
space.一个<strong>正交矩阵</strong>，其列构成预测变量所占空间（<strong>X</strong>
的列空间）的完美正交基。这些列代表数据空间的主方向。</li>
<li><strong>D:</strong> A <strong>diagonal matrix</strong> containing
the “singular values,” which measure the importance or magnitude of each
of these principal
directions.一个<strong>对角矩阵</strong>，包含“奇异值”，用于衡量每个主方向的重要性或大小。</li>
<li><strong>V:</strong> Another <strong>orthogonal
matrix</strong>.另一个<strong>正交矩阵</strong>。</li>
</ul></li>
<li><strong>Process (How SVD simplifies the Projection Matrix) SVD
如何简化投影矩阵:</strong> The main takeaway from this slide is the new,
simpler formula for the hat matrix: <span
class="math display">\[\mathbf{H} = \mathbf{UU}^T\]</span> This result
is derived by substituting <strong>X = UDVᵀ</strong> into the original,
more complex formula for <strong>H</strong>: <span
class="math display">\[\mathbf{H} =
\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\]</span> When you
perform this substitution and use the fact that for orthogonal matrices
<strong>U</strong> and <strong>V</strong>, we have <strong>UᵀU =
I</strong> and <strong>VᵀV = I</strong>, the <strong>D</strong> and
<strong>V</strong> matrices completely cancel out, leaving the
beautifully simple form <strong>H = UUᵀ</strong>. This tells us that
projection is fundamentally about the basis vectors (<strong>U</strong>)
of the predictor space. 执行此代入并利用正交矩阵 <strong>U</strong> 和
<strong>V</strong> 的公式，即 <strong>UᵀU = I</strong> 和 <strong>VᵀV =
I</strong>，<strong>D</strong> 和 <strong>V</strong>
矩阵完全抵消，剩下简洁的形式 <strong>H =
UUᵀ</strong>。这告诉我们，投影本质上是关于预测空间的基向量（<strong>U</strong>）的。</li>
</ul>
<h4 id="the-properties-of-the-projection-matrix-h-投影矩阵-h-的性质">2.
The Properties of the Projection Matrix (H) 投影矩阵 (H) 的性质</h4>
<p>The second slide describes the essential nature of any projection
matrix.</p>
<ul>
<li><p><strong>Symmetric (H = Hᵀ):</strong> This property ensures that
the projection is orthogonal (i.e., it finds the closest point by moving
perpendicularly).
此性质确保投影是正交的（即，它通过垂直移动找到最近的点）。</p></li>
<li><p><strong>Idempotent (H² = H):</strong> This is the most intuitive
property of a projection. 这是投影最直观的性质。</p>
<ul>
<li><strong>Concept:</strong> “Doing it twice is the same as doing it
once.” “两次和一次相同。”</li>
<li><strong>Geometric Meaning:</strong> Imagine you project a point onto
a flat tabletop. That projected point is now <em>on the table</em>. If
you try to project it onto the table <em>again</em>, it doesn’t move.
The projection of a projection is just the projection itself.
Mathematically, this is <strong>H(Hv) = Hv</strong>, which simplifies to
<strong>H² = H</strong>.
想象一下，你将一个点投影到平坦的桌面上。这个投影点现在<em>在桌子上</em>。如果你尝试<em>再次</em>将它投影到桌子上，它不会移动。投影的投影就是投影本身。从数学上讲，这是<strong>H(Hv)
= Hv</strong>，简化为<strong>H² = H</strong>。</li>
</ul></li>
</ul>
<h4 id="eigenvalues-and-eigenspaces-特征值和特征空间">3. Eigenvalues and
Eigenspaces 特征值和特征空间</h4>
<p>The idempotency property has a profound consequence for the matrix’s
eigenvalues.</p>
<ul>
<li><strong>Concept:</strong> The eigenvalues of <strong>H</strong> can
only be <strong>1 or 0</strong>.
<strong>H</strong>的特征值只能是<strong>1</strong>或0**。</li>
<li><strong>Process (The Proof):</strong>
<ol type="1">
<li>Let <strong>v</strong> be an eigenvector of <strong>H</strong> with
eigenvalue <span class="math inline">\(\lambda\)</span>. By definition,
<strong>Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>.
设<strong>v</strong>是<strong>H</strong>的特征向量，其特征值为<span
class="math inline">\(\lambda\)</span>。根据定义，<strong>Hv</strong> =
<span class="math inline">\(\lambda\)</span><strong>v</strong>。</li>
<li>If we apply <strong>H</strong> again, we get <strong>H(Hv)</strong>
= <strong>H</strong>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda\)</span>(<strong>Hv</strong>) = <span
class="math inline">\(\lambda\)</span>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>.
如果我们再次应用<strong>H</strong>，我们得到<strong>H(Hv)</strong> =
<strong>H</strong>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda\)</span>(<strong>Hv</strong>) = <span
class="math inline">\(\lambda\)</span>(<span
class="math inline">\(\lambda\)</span><strong>v</strong>) = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>。</li>
<li>So, we have <strong>H²v</strong> = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>.
因此，我们有<strong>H²v</strong> = <span
class="math inline">\(\lambda^2\)</span><strong>v</strong>。</li>
<li>But since <strong>H</strong> is idempotent, <strong>H² = H</strong>,
which means <strong>H²v = Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>.
但由于<strong>H</strong>是幂等的，<strong>H² =
H</strong>，这意味着<strong>H²v = Hv</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>。</li>
<li>Therefore, we must have <span
class="math inline">\(\lambda^2\)</span><strong>v</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>, which means
<span class="math inline">\(\lambda^2 = \lambda\)</span>. The only two
numbers in existence that satisfy this equation are <strong>0 and
1</strong>. 因此，我们必须有<span
class="math inline">\(\lambda^2\)</span><strong>v</strong> = <span
class="math inline">\(\lambda\)</span><strong>v</strong>，这意味着<span
class="math inline">\(\lambda^2 =
\lambda\)</span>。满足此等式的仅有两个数字是<strong>0</strong>和<strong>1</strong>。</li>
</ol></li>
<li><strong>Connecting Eigenvalues to the Model
将特征值连接到模型:</strong>
<ul>
<li><p><strong>Eigenvalue = 1:</strong> The eigenvectors associated with
an eigenvalue of 1 are the vectors that <strong>do not change</strong>
when projected. This is only possible if they were already in the space
being projected onto. Therefore, the space <code>L₁</code> is the
<strong>column space of X</strong>—the “model space.” <strong>H</strong>
is the projection onto this space. <strong>与特征值为 1
相关联的特征向量是投影时</strong>不会改变<strong>的向量。只有当它们已经存在于投影到的空间中时，这种情况才有可能发生。因此，空间
<code>L₁</code> 是 X 的</strong>列空间<strong>——“模型空间”。</strong>H**
是到该空间的投影。</p></li>
<li><p><strong>Eigenvalue = 0:</strong> The eigenvectors associated with
an eigenvalue of 0 are the vectors that get sent to the zero vector when
projected. This happens to vectors that are <strong>orthogonal</strong>
to the projection space. Therefore, the space <code>L₀</code> is the
<strong>orthogonal “error” space</strong>. The matrix <strong>I -
H</strong> is the projection onto this space.</p></li>
</ul>
<strong>与特征值为 0
相关联的特征向量是投影时被发送到零向量的向量。这种情况发生在与投影空间</strong>正交<strong>的向量上。因此，空间
<code>L₀</code> 是</strong>正交“误差”空间<strong>。矩阵 </strong>I - H**
是到该空间的投影。</li>
</ul>
<h1 id="statistical-inference-1">10.statistical inference</h1>
<p><img src="/imgs/5054C3/statistical_inference_in_linear_regression1.png">
<img src="/imgs/5054C3/statistical_inference_in_linear_regression2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides cover the theoretical backbone of statistical inference
in linear regression. They explain the necessary assumptions and the
resulting probability distributions of our estimates, which is what
allows us to perform hypothesis tests and create confidence
intervals.</p>
<p>这些幻灯片涵盖了线性回归中统计推断的理论基础。它们解释了必要的假设以及由此得出的估计概率分布，这使我们能够进行假设检验并创建置信区间。</p>
<h3 id="summary-3">## Summary</h3>
<p>These slides lay out the statistical assumptions required for the
Least Squares Estimator (LSE). The core idea is that if we assume the
errors are independent and normally distributed, we can then prove that:
这些幻灯片列出了最小二乘估计量 (LSE)
所需的统计假设。其核心思想是，如果我们假设误差是独立的且服从正态分布，那么我们可以证明：</p>
<ol type="1">
<li><p>Our estimated coefficients (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) also follow a
<strong>Normal distribution</strong> (or a
<strong>t-distribution</strong> when standardized). 我们的估计系数
(<span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>)
也服从<strong>正态分布</strong>（标准化后服从<strong>t
分布</strong>）。</p></li>
<li><p>Our summed-up squared errors (RSS) follow a <strong>Chi-squared
distribution</strong>. 我们的平方误差总和 (RSS)
服从<strong>卡方分布</strong>。</p></li>
<li><p>A specific ratio of the explained variance to the unexplained
variance follows an <strong>F-distribution</strong>, which is used to
test the overall significance of the model.
解释方差与未解释方差的特定比率服从<strong>F
分布</strong>，该分布用于检验模型的整体显著性。</p></li>
</ol>
<p>These known distributions are the foundation for all statistical
inference in linear
models.这些已知的分布是线性模型中所有统计推断的基础。</p>
<h3 id="deeper-dive-into-concepts-and-processes">## Deeper Dive into
Concepts and Processes</h3>
<h4 id="the-model-assumptions-the-foundation-模型假设基础">1. The Model
Assumptions (The Foundation) 模型假设（基础）</h4>
<p>The first slide states the two assumptions that are critical for
everything that follows. Without them, we can’t make claims about the
statistical properties of our estimates.
第一张幻灯片阐述了对后续所有内容都至关重要的两个假设。没有它们，我们就无法断言估计值的统计特性。</p>
<ul>
<li><strong>Assumption 1: <span class="math inline">\(\epsilon_i \sim
N(0, \sigma^2)\)</span></strong>
<ul>
<li><strong>Concept:</strong> This assumes that the error terms (the
part of <code>y</code> that the model can’t explain) are drawn from a
normal (bell-curve) distribution with a mean of zero and a constant
variance <span class="math inline">\(\sigma^2\)</span>.
**假设误差项（模型无法解释的 y
值部分）服从正态（钟形曲线）分布，该分布的均值为零，方差为常数 <span
class="math inline">\(\sigma^2\)</span>。</li>
<li><strong>Meaning in Plain English:</strong>
<ul>
<li><strong>Mean of 0:</strong> The model is “correct on average.” The
errors are not systematically positive or negative.
**模型“平均正确”。误差并非系统地为正或负。</li>
<li><strong>Normal Distribution:</strong> Small errors are more likely
than large errors. This is a common assumption for random noise.
**小误差比大误差更有可能出现。这是随机噪声的常见假设。</li>
<li><strong>Constant Variance (<span
class="math inline">\(\sigma^2\)</span>):</strong> The amount of random
scatter around the regression line is the same at all levels of the
predictor variables. This is called <strong>homoscedasticity</strong>.
回归线周围的随机散度在预测变量的各个水平上都是相同的。这被称为<strong>同方差性</strong>。</li>
</ul></li>
</ul></li>
<li><strong>Assumption 2: Observations are independent</strong>
观测值是独立的**
<ul>
<li><strong>Concept:</strong> Each data point <span
class="math inline">\((x_i, y_i)\)</span> is an independent piece of
information. The value of the error for one observation gives no
information about the error for another observation. 每个数据点 <span
class="math inline">\((x_i, y_i)\)</span>
都是一条独立的信息。一个观测值的误差值并不能反映另一个观测值的误差。</li>
<li><strong>Meaning:</strong> This is often true for cross-sectional
data (e.g., a random sample of people) but can be violated in
time-series data where today’s error might be correlated with
yesterday’s.
这通常适用于横截面数据（例如，随机抽样的人群），但在时间序列数据中可能不成立，因为今天的误差可能与昨天的误差相关。</li>
</ul></li>
</ul>
<h4
id="the-distribution-of-the-coefficients-theorem-of-lse-系数分布最小二乘法定理">2.
The Distribution of the Coefficients (Theorem of LSE)
系数分布（最小二乘法定理）</h4>
<p>This is the most important result for understanding the accuracy of
our individual predictors.</p>
<ul>
<li><strong>Concept 1: The Sampling Distribution of <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span></strong>
<ul>
<li><p><strong>Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}} \sim
N(\boldsymbol{\beta},
\sigma^2(\mathbf{X}^T\mathbf{X})^{-1})\)</span></p></li>
<li><p><strong>Meaning:</strong> If you were to take many different
random samples from the population and calculate the coefficients <span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> for each sample,
the distribution of those coefficients would be a multivariate normal
distribution. **如果从总体中随机抽取许多不同的样本，并计算每个样本的系数
<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>，则这些系数的分布将服从多元正态分布。</p>
<ul>
<li>The center of this distribution is the <strong>true population
coefficient vector <span
class="math inline">\(\boldsymbol{\beta}\)</span></strong>. This means
our estimator is <strong>unbiased</strong>—on average, it finds the
right answer. 该分布的中心是<strong>真实的总体系数向量 <span
class="math inline">\(\boldsymbol{\beta}\)</span></strong>。这意味着我们的估计器是<strong>无偏的</strong>——平均而言，它能够找到正确的答案。</li>
<li>The “spread” of this distribution is its variance-covariance matrix,
<span
class="math inline">\(\sigma^2(\mathbf{X}^T\mathbf{X})^{-1}\)</span>.
This tells us the uncertainty in our estimates.
该分布的“散度”是其方差-协方差矩阵</li>
</ul></li>
</ul></li>
<li><strong>Concept 2: The t-statistic</strong> t 统计量
<ul>
<li><strong>Formula:</strong> The standardized coefficient, <span
class="math inline">\(\frac{\hat{\beta}_j -
\beta_j}{\text{s.e.}(\hat{\beta}_j)}\)</span>, follows a
<strong>t-distribution</strong> with <strong><span
class="math inline">\(n-p-1\)</span> degrees of freedom</strong>.</li>
<li><strong>Process &amp; Meaning:</strong> In the real world, we don’t
know the true error variance <span
class="math inline">\(\sigma^2\)</span>. We have to estimate it using
our sample data, which gives us <span
class="math inline">\(s^2\)</span>. Because we are using an
<em>estimate</em> of the variance, we introduce extra uncertainty. The
t-distribution is like a normal distribution but with slightly “fatter”
tails to account for this additional uncertainty. The degrees of
freedom, <span class="math inline">\(n-p-1\)</span>, reflect the number
of data points (<code>n</code>) minus the number of parameters we had to
estimate (<code>p</code> slopes + 1 intercept). This is the basis for
t-tests and confidence intervals for each coefficient.
在现实世界中，我们不知道真实的误差方差 <span
class="math inline">\(\sigma^2\)</span>。我们必须使用样本数据来估计它，从而得到
<span
class="math inline">\(s^2\)</span>。由于我们使用的是方差的<em>估计值</em>，因此引入了额外的不确定性。
t 分布类似于正态分布，但尾部略微“丰满”，以解释这种额外的不确定性。自由度
<span class="math inline">\(n-p-1\)</span>
表示数据点的数量（<code>n</code>）减去我们需要估计的参数数量（<code>p</code>
个斜率 + 1 个截距）。这是 t 检验和每个系数置信区间的基础。</li>
</ul></li>
</ul>
<h4
id="the-distribution-of-the-error-theorem-of-residual-误差分布残差定理">3.
The Distribution of the Error (Theorem of Residual)
误差分布（残差定理）</h4>
<p>This theorem helps us understand the properties of our model’s
overall error.</p>
<ul>
<li><p><strong>Concept:</strong> The <strong>Residual Sum of Squares
(RSS)</strong>, when scaled by the true variance, follows a
<strong>Chi-squared (<span class="math inline">\(\chi^2\)</span>)
distribution</strong> with <span class="math inline">\(n-p-1\)</span>
degrees of freedom. <strong>残差平方和 (RSS)</strong>
经真实方差缩放后，服从自由度为 <span
class="math inline">\(n-p-1\)</span> 的<strong>卡方 (<span
class="math inline">\(\chi^2\)</span>) 分布</strong>。</p></li>
<li><p><strong>Process &amp; Meaning:</strong> The Chi-squared
distribution often arises when dealing with sums of squared normal
variables. This theorem provides a formal probability distribution for
our total model error. Its most important consequence is that it allows
us to prove that:
**卡方分布通常用于处理正态变量的平方和。该定理为我们模型的总体误差提供了一个正式的概率分布。它最重要的推论是，它使我们能够证明：</p>
<p><span class="math display">\[s^2 = \text{RSS}/(n - p - 1)\]</span> is
an <strong>unbiased estimate</strong> of the true error variance <span
class="math inline">\(\sigma^2\)</span>. This <span
class="math inline">\(s^2\)</span> is a critical ingredient for
calculating the standard errors of our coefficients. <span
class="math display">\[s^2 = \text{RSS}/(n - p - 1)\]</span>
是真实误差方差 <span class="math inline">\(\sigma^2\)</span>
的<strong>无偏估计</strong>。这个 <span
class="math inline">\(s^2\)</span>
是计算系数标准误差的关键因素。</p></li>
</ul>
<h4 id="the-f-distribution-and-the-overall-model-test">4. The
F-Distribution and the Overall Model Test</h4>
<p>This final theorem combines our findings about the coefficients and
the residuals.</p>
<ul>
<li><p><strong>Concept:</strong> The F-statistic, which is essentially a
ratio of the variance explained by the model to the variance left
unexplained, follows an <strong>F-distribution</strong>. F
统计量本质上是模型解释的方差与未解释方差的比率，服从 F 分布。</p></li>
<li><p><strong>Process &amp; Meaning:</strong> This result relies on the
fact that our coefficient estimates (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) are independent
of our total error (RSS). The F-distribution is used for the
<strong>F-test of overall significance</strong>. This test checks the
null hypothesis that <em>all</em> of your slope coefficients are
simultaneously zero (<span class="math inline">\(\beta_1 = \beta_2 =
\dots = \beta_p = 0\)</span>). If the F-test gives a small p-value, you
can conclude that your model, as a whole, is statistically significant
and provides a better fit than a model with no predictors. 如果 F
检验得出的 p
值较小，则可以得出结论，您的模型整体上具有统计显著性，并且比没有预测因子的模型拟合效果更好。</p></li>
</ul>
<h1 id="construct-different-types-of-intervals">11.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/construct_different_types_of_intervals1.png">
<img src="/imgs/5054C3/construct_different_types_of_intervals2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides explain how to use the statistical properties of the
least squares estimates to construct different types of intervals, which
are essential for quantifying the uncertainty in your model’s
predictions and parameters.
这些幻灯片解释了如何利用最小二乘估计的统计特性来构建不同类型的区间，这对于量化模型预测和参数中的不确定性至关重要。</p>
<h3 id="summary-4">Summary</h3>
<p>These slides show how to calculate three distinct types of intervals
in linear regression, each answering a different question about
uncertainty:
展示了如何计算线性回归中三种不同类型的区间，每种区间分别回答了关于不确定性的不同问题：</p>
<ol type="1">
<li><strong>Confidence Interval for a Parameter (<span
class="math inline">\(\beta_j\)</span>):</strong> Provides a plausible
range for a single, true unknown coefficient in the model.
为模型中单个真实未知系数提供一个合理的范围。</li>
<li><strong>Confidence Interval for the Mean Response:</strong> Provides
a plausible range for the <em>average</em> outcome for a given set of
predictor values.
为给定一组预测变量值的<em>平均</em>结果提供一个合理的范围。</li>
<li><strong>Prediction Interval:</strong> Provides a plausible range for
a <em>single future</em> outcome for a given set of predictor values.
This interval is always wider than the confidence interval for the mean
response because it must also account for individual random error.
为给定一组预测变量值的<em>单个未来</em>结果提供一个合理的范围。该区间始终比平均响应的置信区间更宽，因为它还必须考虑单个随机误差。</li>
</ol>
<h3 id="deeper-dive-into-concepts-and-processes-1">Deeper Dive into
Concepts and Processes</h3>
<h4
id="confidence-interval-for-a-single-parameter-单个参数的置信区间">1.
Confidence Interval for a Single Parameter 单个参数的置信区间</h4>
<p>This interval addresses the uncertainty around one specific
coefficient, like the slope for your most important predictor.
此区间用于解决围绕某个特定系数的不确定性，例如最重要的预测因子的斜率。</p>
<ul>
<li><strong>The Question It Answers:</strong> “I’ve calculated a slope
of <span class="math inline">\(\hat{\beta}_1 = 10.5\)</span>. How sure
am I about this number? What is a plausible range for the <em>true</em>
population slope?” 我计算出了斜率为 <span
class="math inline">\(\hat{\beta}_1 =
10.5\)</span>。我对这个数字有多确定？<em>真实</em>总体斜率的合理范围是多少？”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\beta}_j \pm t_{n-p-1}(\alpha/2) s
\sqrt{c_{jj}}\)</span>
<ul>
<li><strong><span class="math inline">\(\hat{\beta}_j\)</span></strong>:
This is your best point estimate for the coefficient, taken directly
from the model output. 这是该系数的最佳点估计值，直接取自模型输出。</li>
<li><strong><span
class="math inline">\(t_{n-p-1}(\alpha/2)\)</span></strong>: This is the
<strong>critical value</strong> from a t-distribution. It’s a multiplier
that sets the width of the interval based on your desired confidence
level (e.g., for 95% confidence, <span
class="math inline">\(\alpha=0.05\)</span>). 这是 t
分布的<strong>临界值</strong>。它是一个乘数，根据您所需的置信水平设置区间宽度（例如，对于
95% 的置信度，<span class="math inline">\(\alpha=0.05\)</span>）。</li>
<li><strong><span class="math inline">\(s
\sqrt{c_{jj}}\)</span></strong>: This whole term is the <strong>standard
error</strong> of the coefficient <span
class="math inline">\(\hat{\beta}_j\)</span>. It measures the precision
of your estimate. A smaller standard error means a narrower, more
precise interval. 这整个项是系数 <span
class="math inline">\(\hat{\beta}_j\)</span>
的<strong>标准误差</strong>。它衡量您估计的精度。标准误差越小，区间越窄，精度越高。</li>
</ul></li>
</ul>
<h4 id="confidence-interval-for-the-mean-response-平均响应的置信区间">2.
Confidence Interval for the Mean Response 平均响应的置信区间</h4>
<p>This interval addresses the uncertainty about the location of the
regression line itself. 这个区间解决了回归线本身位置的不确定性。</p>
<ul>
<li><strong>The Question It Answers:</strong> “For a house with 3
bedrooms and 2 bathrooms, what is the plausible range for the
<em>average</em> selling price of <em>all such houses</em>?”
<strong>它回答的问题</strong>：“对于一栋有 3 间卧室和 2
间浴室的房子，<em>所有此类房屋</em>的<em>平均</em>售价的合理范围是多少？”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}}^T \mathbf{x} \pm
t_{n-p-1}(\alpha/2)s\sqrt{\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span>
<ul>
<li><strong><span class="math inline">\(\hat{\boldsymbol{\beta}}^T
\mathbf{x}\)</span></strong>: This is your point prediction, <span
class="math inline">\(\hat{y}\)</span>, for the given input vector
<strong>x</strong>. 这是给定输入向量 <strong>x</strong> 的点预测 <span
class="math inline">\(\hat{y}\)</span>。</li>
<li><strong><span
class="math inline">\(s\sqrt{\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span></strong>:
This is the standard error of the mean response. Its value depends on
how far the input vector <strong>x</strong> is from the center of the
data. This means the confidence interval is narrowest near the average
of your data and gets wider as you move toward the extremes.
这是平均响应的标准误差。其值取决于输入向量 <strong>x</strong>
距离数据中心的距离。这意味着置信区间在数据平均值附近最窄，并且随着接近极值而变宽。</li>
</ul></li>
</ul>
<h4
id="prediction-interval-for-an-individual-response-单个响应的预测区间">3.
Prediction Interval for an Individual Response 单个响应的预测区间</h4>
<p>This is the most comprehensive interval and is often the most useful
for making real-world predictions.
这是最全面的区间，通常对于进行实际预测最有用。</p>
<ul>
<li><strong>The Question It Answers:</strong> “I want to predict the
selling price for <em>one specific house</em> that has 3 bedrooms and 2
bathrooms. What is a plausible price range for this <em>single
house</em>?”</li>
<li><strong>The Formula:</strong> <span
class="math inline">\(\hat{\boldsymbol{\beta}}^T \mathbf{x} \pm
t_{n-p-1}(\alpha/2)s\sqrt{1 +
\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}}\)</span></li>
<li><strong>The Key Difference:</strong> Notice the formula is identical
to the one above, except for the <strong><code>1 + ...</code></strong>
inside the square root. This “1” is critically important. It accounts
for the second source of uncertainty.
<strong>请注意，该公式与上面的公式完全相同，只是平方根中的</strong><code>1 + ...</code>**不同。这个“1”至关重要。它解释了第二个不确定性来源。
<ol type="1">
<li><strong>Uncertainty in the model:</strong> We are not perfectly
certain about the true location of the regression line. This is captured
by the <span
class="math inline">\(\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}\)</span>
term. **我们无法完全确定回归线的真实位置。这可以通过 <span
class="math inline">\(\mathbf{x}^T(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{x}\)</span>
项来捕捉。</li>
<li><strong>Uncertainty in the individual data point:</strong> Even if
we knew the true regression line perfectly, individual data points would
still be scattered around it due to random error (<span
class="math inline">\(\epsilon\)</span>). The “1” in the formula
accounts for this irreducible, random error of a single observation.
即使我们完全了解真实的回归线，由于随机误差 (<span
class="math inline">\(\epsilon\)</span>)，单个数据点仍然会散布在其周围。公式中的“1”解释了单个观测值中这种不可约的随机误差。</li>
</ol></li>
</ul>
<p>Because it accounts for both types of uncertainty, the
<strong>prediction interval is always wider than the confidence interval
for the mean</strong>.
由于它同时考虑了两种不确定性，因此<strong>预测区间</strong>总是比均值的置信区间更宽。</p>
<h4 id="the-core-difference-an-analogy-一个类比">The Core Difference: An
Analogy 一个类比</h4>
<ul>
<li><p><strong>Confidence Interval (Mean) 均值置信区间:</strong> Like
predicting the <strong>average</strong> arrival time for a specific
flight that runs every day. After observing it for a year, you can
predict the average very accurately (e.g., 10:05 AM ± 2 minutes).
就像预测每天特定航班的<strong>平均</strong>到达时间。经过一年的观察，您可以非常准确地预测平均值（例如，上午
10:05 ± 2 分钟）。</p></li>
<li><p><strong>Prediction Interval (Individual) 个体预测区间:</strong>
Like predicting the arrival time for that same flight on <strong>one
specific day</strong> next week. You have to account for the uncertainty
in the average <em>plus</em> the potential for random, one-time events
like weather or air traffic delays. Your prediction must be wider to be
safe (e.g., 10:05 AM ± 15 minutes).
就像预测同一航班下周<strong>某一天</strong>的到达时间。您必须考虑平均值的不确定性，以及*可能出现的随机、一次性事件，例如天气或空中交通延误。您的预测范围必须更广才能安全（例如，上午
10:05 ± 15 分钟）。</p></li>
</ul>
<h1 id="construct-different-types-of-intervals-1">12.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/ANOVA1.png">
<img src="/imgs/5054C3/ANOVA2.png"></p>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<p>These slides explain <strong>Analysis of Variance (ANOVA)</strong>, a
method used in regression to break down the total variability in your
data to test if your model is statistically significant as a
whole.这些幻灯片讲解了<strong>方差分析
(ANOVA)</strong>，这是一种用于回归分析的方法，用于分解数据中的总变异性，以检验模型整体是否具有统计显著性。</p>
<h3 id="summary-5">Summary</h3>
<p>The core idea is to decompose the total variation in the response
variable (<strong>Total Sum of Squares, SS_total</strong>) into two
parts: the variation that is explained by your regression model
(<strong>Regression Sum of Squares, SS_reg</strong>) and the variation
that is left unexplained (<strong>Error Sum of Squares,
SS_error</strong>).
其核心思想是将响应变量的总变异（<strong>总平方和，SS_total</strong>）分解为两部分：回归模型可以解释的变异（<strong>回归平方和，SS_reg</strong>）和未解释的变异（<strong>误差平方和，SS_error</strong>）。</p>
<p>By comparing the size of the explained variation to the unexplained
variation using an <strong>F-statistic</strong>, we can formally test
the hypothesis that our model has predictive power. This entire process
is neatly organized in an <strong>ANOVA table</strong>.
通过使用<strong>F
统计量</strong>比较已解释变异与未解释变异的大小，我们可以正式检验模型具有预测能力的假设。整个过程都整齐地组织在<strong>方差分析表</strong>中。</p>
<h3 id="deeper-dive-into-concepts-and-connections">Deeper Dive into
Concepts and Connections</h3>
<h4
id="the-decomposition-of-variances-the-core-equation-方差分解核心方程">1.
The Decomposition of Variances (The Core Equation)
方差分解（核心方程）</h4>
<p>The first slide starts with the fundamental equation of ANOVA, which
stems directly from the geometric properties of least squares:
第一张幻灯片以方差分析的基本方程开头，该方程直接源于最小二乘的几何性质：</p>
<p><span class="math display">\[SS_{total} = SS_{reg} +
SS_{error}\]</span></p>
<ul>
<li><strong>SS_total (Total Sum of Squares):</strong> <span
class="math inline">\(\sum(y_i - \bar{y})^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>total
variation</strong> in your response variable, <code>y</code>. Imagine
you didn’t have a model and your only prediction for any <code>y</code>
was its overall average, <code>ȳ</code>. SS_total is the total squared
error of this simple “mean-only” model. It represents the total amount
of variation you are trying to explain.
这测量的是响应变量“y”的<strong>总变异</strong>。假设你没有模型，你对任何“y”的唯一预测是它的整体平均值“ȳ”。SS_total
是这个简单的“仅均值”模型的总平方误差。它代表了你试图解释的变异总量。</li>
</ul></li>
<li><strong>SS_reg (Regression Sum of Squares):</strong> <span
class="math inline">\(\sum(\hat{y}_i - \bar{y})^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>explained
variation</strong>. It’s the amount of variation in <code>y</code> that
is captured by your regression model. It calculates the difference
between your model’s predictions (<code>ŷ</code>) and the simple average
(<code>ȳ</code>). A large SS_reg means your model’s predictions are a
big improvement over just guessing the average.
<strong>它衡量</strong>解释变异**。它是回归模型捕捉到的 y
的变异量。它计算模型预测值（“ŷ”）与简单平均值（“ȳ”）之间的差异。较大的
SS_reg 意味着模型的预测结果比仅仅猜测平均值有显著改善。</li>
</ul></li>
<li><strong>SS_error (Error Sum of Squares):</strong> <span
class="math inline">\(\sum(y_i - \hat{y}_i)^2\)</span>
<ul>
<li><strong>Concept:</strong> This measures the <strong>unexplained
variation</strong> (also called the Residual Sum of Squares). It’s the
amount of variation your model <em>failed</em> to capture. It’s the sum
of the squared differences between the actual data (<code>y</code>) and
your model’s predictions (<code>ŷ</code>).
<strong>它衡量</strong>未解释变异**（也称为残差平方和）。它是模型<em>未能</em>捕捉到的变异量。它是实际数据
(<code>y</code>) 与模型预测值 (<code>ŷ</code>) 之间平方差之和。</li>
</ul></li>
</ul>
<p>The <strong>R-squared</strong> value is a direct consequence of this
decomposition. It’s the proportion of the total variance that is
explained by the model: <strong>R 平方</strong>
值是这种分解的直接结果。它是模型解释的总方差的比例：</p>
<p><span class="math display">\[R^2 =
\frac{SS_{reg}}{SS_{total}}\]</span></p>
<h4 id="the-anova-table-and-the-f-test">2. The ANOVA Table and the
F-test</h4>
<p>方差分析表和 F 检验 The second slide organizes these sums of squares
to perform a formal hypothesis test.
第二张幻灯片整理了这些平方和，以进行正式的假设检验。</p>
<ul>
<li><strong>The Question:</strong> “Is there <em>any</em> relationship
between my set of predictors and the response variable?” or “Is my model
better than nothing?”
“我的预测变量集和响应变量之间是否存在<em>任何</em>关系？”或“我的模型比没有模型好吗？”</li>
<li><strong>The Hypotheses:</strong>
<ul>
<li><strong>Null Hypothesis (<span
class="math inline">\(H_0\)</span>):</strong> <span
class="math inline">\(\beta_1 = \beta_2 = \dots = \beta_p = 0\)</span>.
(None of the predictors have a relationship with the response; the model
is useless). <strong>零假设 (<span
class="math inline">\(H_0\)</span>)</strong>：<span
class="math inline">\(\beta_1 = \beta_2 = \dots = \beta_p = 0\)</span>。
（所有预测变量都与响应变量无关；该模型毫无用处）。</li>
<li><strong>Alternative Hypothesis (<span
class="math inline">\(H_1\)</span>):</strong> At least one <span
class="math inline">\(\beta_j\)</span> is not zero. (The model has some
predictive value). <strong>备择假设 (<span
class="math inline">\(H_1\)</span>)：</strong>至少有一个 <span
class="math inline">\(\beta_j\)</span>
不为零。（该模型具有一定的预测值）。</li>
</ul></li>
</ul>
<p>To test this, we can’t just compare the raw SS values, because they
depend on the number of data points and predictors. We need to normalize
them. 为了验证这一点，我们不能仅仅比较原始的 SS
值，因为它们取决于数据点和预测变量的数量。我们需要对它们进行归一化。</p>
<ul>
<li><strong>Mean Squares (MS):</strong> This is the “average” variation.
We calculate it by dividing the Sum of Squares by its <strong>degrees of
freedom (df)</strong>.
<strong>这是“平均”变异。我们通过将平方和除以其</strong>自由度 (df)**
来计算它。
<ul>
<li><strong>MS_reg</strong> = <span class="math inline">\(SS_{reg} /
p\)</span>. This is the average explained variation <em>per
predictor</em>. 这是<em>每个预测变量</em>的平均解释变异。</li>
<li><strong>MS_error</strong> = <span class="math inline">\(SS_{error} /
(n - p - 1)\)</span>. This is the average unexplained variation, which
is our estimate of the error variance, <span
class="math inline">\(s^2\)</span>. 这是平均未解释变异，即我们对误差方差
<span class="math inline">\(s^2\)</span> 的估计值。</li>
</ul></li>
</ul>
<h4 id="the-connection-the-f-statistic-联系f-统计量">3. The Connection:
The F-statistic 联系：F 统计量</h4>
<p>The <strong>F-statistic</strong> is the key that connects everything.
It’s the ratio of the two mean squares: <strong>F
统计量</strong>是连接一切的关键。它是两个均方的比值： <span
class="math display">\[F = \frac{\text{Mean Squared
Regression}}{\text{Mean Squared Error}} =
\frac{MS_{reg}}{MS_{error}}\]</span></p>
<ul>
<li><strong>Intuitive Meaning:</strong> The F-statistic is a ratio of
the <strong>average explained variation</strong> to the <strong>average
unexplained variation</strong>. F
统计量是<strong>平均解释变异</strong>与<strong>平均未解释变异</strong>的比值。
<ul>
<li>If your model is useless (<span class="math inline">\(H_0\)</span>
is true), the explained variation should be about the same as the
random, unexplained variation. The F-statistic will be close to 1.
如果你的模型无效（H_0$
为真），则解释变异应该与随机的未解释变异大致相同。F 统计量接近 1。</li>
<li>If your model is useful (<span class="math inline">\(H_1\)</span> is
true), the explained variation should be significantly larger than the
unexplained variation. The F-statistic will be much greater than 1.
如果你的模型有效（H_1$ 为真），则解释变异应该显著大于未解释变异。 F
统计量将远大于 1。</li>
</ul></li>
</ul>
<p>We compare our calculated F-statistic to an
<strong>F-distribution</strong> to get a <strong>p-value</strong>. A
small p-value (&lt; 0.05) provides strong evidence to reject the null
hypothesis and conclude that your model, as a whole, is statistically
significant. 我们将计算出的 F 统计量与<strong>F
分布</strong>进行比较，得出<strong>p 值</strong>。较小的 p 值（&lt;
0.05）可以提供强有力的证据来拒绝零假设，并得出您的模型整体具有统计显著性的结论。</p>
<h1 id="construct-different-types-of-intervals-2">12.construct different
types of intervals</h1>
<p><img src="/imgs/5054C3/Gauss_Markov1.png">
<img src="/imgs/5054C3/Gauss_Markov2.png"></p>
<ul>
<li><strong>内容</strong>: These slides explain the <strong>Gauss-Markov
theorem</strong>, a cornerstone result in statistics that establishes
why the Least Squares Estimator (LSE) is considered the gold standard
for fitting linear models under a specific set of assumptions.
这些幻灯片解释了<strong>高斯-马尔可夫定理</strong>，这是统计学中的一个基石性成果，它阐明了为什么最小二乘估计量
(LSE) 被认为是在特定假设条件下拟合线性模型的黄金标准。</li>
</ul>
<h3 id="summary-6">Summary</h3>
<p>The slides argue for the superiority of the Least Squares Estimator
(LSE) by highlighting its key properties: it’s easy to compute,
consistent, and efficient. This culminates in the <strong>Gauss-Markov
Theorem</strong>, which proves that LSE is <strong>BLUE</strong>: the
<strong>B</strong>est <strong>L</strong>inear <strong>U</strong>nbiased
<strong>E</strong>stimator. This means that among all estimators that
are both linear and unbiased, the LSE is the “best” because it has the
smallest possible variance, making it the most precise. The second slide
provides the key steps for the mathematical proof of this important
theorem. 这些幻灯片通过强调最小二乘估计量 (LSE)
的关键特性来论证其优越性：易于计算、一致性高且高效。最终得出了<strong>高斯-马尔可夫定理</strong>，该定理证明了
LSE
是<strong>BLUE</strong>：<strong>最佳</strong>线性<strong>无偏</strong>估计量。这意味着在所有线性且无偏的估计量中，LSE
是“最佳”的，因为它具有最小的方差，因此精度最高。第二张幻灯片提供了这一重要定理的数学证明的关键步骤。</p>
<h3 id="deeper-dive-into-the-concepts">Deeper Dive into the
Concepts</h3>
<h4 id="properties-of-lse-slide-1-局部正交估计-lse-的性质">Properties of
LSE (Slide 1) 局部正交估计 (LSE) 的性质</h4>
<ul>
<li><strong>Easy Computation易于计算:</strong> The LSE has a direct,
closed-form solution called the Normal Equation (<span
class="math inline">\(\hat{\boldsymbol{\beta}} =
(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}\)</span>). You can
calculate it directly without needing complex iterative algorithms.</li>
<li><strong>Consistency一致性:</strong> As your sample size gets larger
and larger, the LSE estimate (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>) is guaranteed
to get closer and closer to the true population value (<span
class="math inline">\(\boldsymbol{\beta}\)</span>). With enough data, it
will find the truth. 随着样本量越来越大，LSE 估计值 (<span
class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>)
必然会越来越接近真实的总体值 (<span
class="math inline">\(\boldsymbol{\beta}\)</span>)。只要有足够的数据，它就能找到真相。</li>
<li><strong>Efficiency效率:</strong> An efficient estimator is the one
with the lowest possible variance. This means its estimates are the most
precise and least spread out.
高效的估计器是方差尽可能低的估计器。这意味着它的估计值最精确，且分布最均匀。</li>
<li><strong>BLUE (Best Linear Unbiased
Estimator)BLUE（最佳线性无偏估计器）:</strong> This acronym elegantly
summarizes the Gauss-Markov theorem.
这个缩写完美地概括了高斯-马尔可夫定理。
<ul>
<li><strong>Linear:</strong> The estimator is a linear function of the
response variable <strong>y</strong>. We can write it as <span
class="math inline">\(\hat{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span> for some matrix <strong>A</strong>.
估计器是响应变量<strong>y</strong>的线性函数。对于某个矩阵<strong>A</strong>，我们可以将其写成
<span class="math inline">\(\hat{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>。</li>
<li><strong>Unbiased:</strong> The estimator does not systematically
overestimate or underestimate the true parameter. On average, its
expected value is the true value: <span
class="math inline">\(E[\hat{\boldsymbol{\beta}}] =
\boldsymbol{\beta}\)</span>.
估计器不会系统性地高估或低估真实参数。平均而言，其预期值即为真实值：<span
class="math inline">\(E[\hat{\boldsymbol{\beta}}] =
\boldsymbol{\beta}\)</span>。</li>
<li><strong>Best:</strong> It has the <strong>minimum variance</strong>
of all possible linear unbiased estimators. It’s the most precise and
reliable estimator in its class.
在所有可能的线性无偏估计器中，它的<strong>方差</strong>最小。它是同类中最精确、最可靠的估计器。</li>
</ul></li>
</ul>
<h4 id="the-gauss-markov-theorem-高斯-马尔可夫定理">The Gauss-Markov
Theorem 高斯-马尔可夫定理</h4>
<p>The theorem provides the theoretical justification for using OLS.
该定理为使用最小二乘法 (OLS) 提供了理论依据。 * <strong>The Core
Idea:</strong> You could invent many different ways to estimate the
coefficients of a linear model. As long as your proposed methods are
both linear and unbiased, the Gauss-Markov theorem guarantees that none
of them will be more precise than the standard least squares method. LSE
gives the “sharpest” possible estimates.
你可以发明许多不同的方法来估计线性模型的系数。只要你提出的方法是线性的且无偏的，高斯-马尔可夫定理就能保证，它们都不会比标准最小二乘法更精确。最小二乘法
(LSE) 给出了“最精确”的估计值。</p>
<ul>
<li><strong>The Logic of the Proof (Slide 2) 证明逻辑:</strong> The
proof is a clever comparison of variances. **该证明巧妙地比较了方差。
<ol type="1">
<li>It starts by defining <strong>any</strong> other linear unbiased
estimator as <span class="math inline">\(\tilde{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>.
首先，将<strong>任何</strong>其他线性无偏估计量定义为 <span
class="math inline">\(\tilde{\boldsymbol{\beta}} =
\mathbf{A}\mathbf{y}\)</span>。</li>
<li>It uses the “unbiased” property to force a condition on the matrix
<strong>A</strong>, which ultimately leads to the insight that
<strong>A</strong> can be written in terms of the LSE matrix plus some
other matrix <strong>D</strong>, where <strong>DX = 0</strong>.
它利用“无偏”性质对矩阵<strong>A</strong>强制施加一个条件，最终得出<strong>A</strong>可以写成LSE矩阵加上另一个矩阵<strong>D</strong>，其中<strong>DX
= 0</strong>。</li>
<li>It then calculates the variance of this other estimator, which turns
out to be: <span class="math display">\[Var(\tilde{\boldsymbol{\beta}})
= Var(\text{LSE}) + \text{a non-negative term involving }
\mathbf{D}\]</span> 然后计算另一个估计量的方差，结果为： <span
class="math display">\[Var(\tilde{\boldsymbol{\beta}}) = Var(\text{LSE})
+ \text{一个包含 } \mathbf{D} 的非负项\]</span></li>
<li>Since the variance of any other linear unbiased estimator is the
variance of the LSE <em>plus</em> something non-negative, the variance
of the LSE must be the smallest possible value.
由于任何其他线性无偏估计量的方差都是LSE的方差<em>加上</em>一个非负项，因此LSE的方差必须是最小的可能值。</li>
</ol></li>
</ul>
<h3 id="further-understandings-beyond-the-slides">Further Understandings
Beyond the Slides</h3>
<h4 id="what-are-the-required-assumptions需要哪些假设">1. What are the
required assumptions?需要哪些假设？</h4>
<p>The Gauss-Markov theorem is powerful, but it’s not magic. It only
holds if a set of assumptions about the model’s errors (<span
class="math inline">\(\epsilon\)</span>) are met:
高斯-马尔可夫定理虽然强大，但并非魔法。它仅在满足以下关于模型误差 (<span
class="math inline">\(\epsilon\)</span>) 的假设时成立： * <strong>Zero
Mean零均值:</strong> The average of the errors is zero (<span
class="math inline">\(E[\epsilon] = 0\)</span>). 误差的平均值为零 (<span
class="math inline">\(E[\epsilon] = 0\)</span>)。 * <strong>Constant
Variance (Homoscedasticity)恒定方差（同方差性）:</strong> The errors
have the same variance, <span class="math inline">\(\sigma^2\)</span>,
at all levels of the predictors.
<strong>在预测变量的各个水平上，误差具有相同的方差 <span
class="math inline">\(\sigma^2\)</span>。 * </strong>Uncorrelated
Errors不相关误差:** The error for one observation is not correlated with
the error for another. 一个观测值的误差与另一个观测值的误差不相关。 *
<strong>No Perfect Multicollinearity非完全多重共线性:</strong> The
predictor variables are not perfectly linearly related.
预测变量并非完全线性相关。</p>
<p><strong>Crucially, the Gauss-Markov theorem does NOT require the
errors to be normally distributed.</strong> The normality assumption is
only needed later for constructing confidence intervals and conducting
t-tests and F-tests.
至关重要的是，高斯-马尔可夫定理并不要求误差服从正态分布。**正态性假设仅在构建置信区间以及进行
t 检验和 F 检验时需要。</p>
<h4
id="when-is-lse-not-the-best-the-bias-variance-tradeoff-什么时候-lse-不是最佳选择-偏差-方差权衡">2.
When is LSE NOT the Best? (The Bias-Variance Tradeoff) 什么时候 LSE
不是最佳选择？ （偏差-方差权衡）</h4>
<p>While LSE is the best <em>unbiased</em> estimator, sometimes we can
get better predictive performance by accepting a little bit of bias in
exchange for a large reduction in variance. This is the core idea behind
modern regularization methods: 虽然 LSE
是最好的<em>无偏</em>估计器，但有时我们可以通过接受少量偏差来大幅降低方差，从而获得更好的预测性能。这是现代正则化方法背后的核心思想：
* <strong>Ridge Regression and LASSO岭回归和 LASSO:</strong> These are
popular techniques that produce <em>biased</em> estimates of the
coefficients. However, by introducing this small amount of bias, they
can often produce models with a lower overall error (Mean Squared Error)
than LSE, especially when predictors are highly correlated.
这些是产生<em>有偏</em>系数估计的流行技术。然而，通过引入少量偏差，它们通常可以生成比
LSE
具有更低总体误差（均方误差）的模型，尤其是在预测变量高度相关的情况下。
Therefore, while LSE is the theoretical champion in the world of
unbiased estimators, in the world of predictive modeling, methods that
intentionally introduce bias can sometimes be superior. 因此，虽然 LSE
是无偏估计领域的理论冠军，但在预测模型领域，有意引入偏差的方法有时会更胜一筹。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/16/2025_9_15%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/16/2025_9_15%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/" class="post-title-link" itemprop="url">MEETING - AI4Chemistry conference notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-16 01:00:00" itemprop="dateCreated datePublished" datetime="2025-09-16T01:00:00+08:00">2025-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-21 06:46:20" itemprop="dateModified" datetime="2025-09-21T06:46:20+08:00">2025-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/meeting-notes/" itemprop="url" rel="index"><span itemprop="name">meeting notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Meeting Notes</p>
<h1 id="九月份规划">1. 九月份规划：</h1>
<ul>
<li><strong>内容</strong>:</li>
</ul>
<h2 id="经典论文模型复现">1.1 经典论文模型复现：</h2>
<ul>
<li><strong>1.1.1</strong> <a
target="_blank" rel="noopener" href="https://www.biorxiv.org/content/10.1101/2025.08.06.668973v2">MetaAI-3D蛋白质结构对比学习</a>
<a target="_blank" rel="noopener" href="https://github.com/kalifadan/FusionProt">github</a></li>
<li><strong>1.1.2</strong> <a
target="_blank" rel="noopener" href="https://bmcbiol.biomedcentral.com/articles/10.1186/s12915-024-02030-9">DrugDAGT</a>
<a target="_blank" rel="noopener" href="https://github.com/codejiajia/DrugDAGT">github</a> <a
target="_blank" rel="noopener" href="https://zenodo.org/records/6568518#.YrtTKHbMK38">!!! orbnet
qm9的graph based的feature</a> <a
target="_blank" rel="noopener" href="https://zenodo.org/records/6568518#.YrtTKHbMK38">github</a></li>
<li><strong>1.1.3 GCL &amp; GCFORMER</strong> <a
target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.13902">经典对比学习论文</a> <a
target="_blank" rel="noopener" href="https://openreview.net/forum?id=u6FuiKzT1K">!! Graph contrastive
learning former - NIPS2024</a> <a
target="_blank" rel="noopener" href="https://github.com/JHL-HUST/GCFormer">github</a></li>
<li><strong>GCL</strong> <a
target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.13902">Graph Contrastive Learning with
Augmentations - NIPS</a> <a
target="_blank" rel="noopener" href="https://github.com/Shen-Lab/GraphCL">github</a></li>
</ul>
<h2 id="数据集">1.2 数据集：</h2>
<p><a
target="_blank" rel="noopener" href="https://quantum-machine.org/datasets/">quantum-machine-QM9</a> <a
target="_blank" rel="noopener" href="https://github.com/bigdata-ustc/QM9nano4USTC">中科大实验课做了个QM9数据集的demo</a></p>
<ul>
<li><p><strong>闭壳层分子数据集</strong></p></li>
<li><p><strong>分子规模</strong>：含 13.4
万个稳定的小分子有机物</p></li>
<li><p><strong>元素组成</strong>：仅包含
H（氢）、C（碳）、N（氮）、O（氧）、F（氟）5 种元素</p></li>
<li><p><strong>计算理论水平</strong>：所有分子属性基于DFT（密度泛函理论）/B3LYP
泛函 / 6-31G (2df,p) 基组计算</p></li>
<li><p><strong>包含属性</strong>：偶极矩、HOMO（最高占据分子轨道）能量、LUMO（最低未占据分子轨道）能量、0K
内能、298.15K 内能等，是闭壳层分子性质预测的基准数据集</p></li>
<li><p><strong>训练输入</strong>：闭壳层下的量子化学矩阵，即 Fock
矩阵（F）、密度矩阵（P）、哈密顿矩阵（H）、重叠矩阵（S），构成向量 T
的闭壳层形式（因闭壳层自旋对称，无需区分 α、β 自旋，故
T=[F,P,H,S]）</p></li>
<li><p><strong>特征本质</strong>：这些矩阵编码了分子的电子结构信息（如轨道间相互作用、电子密度分布），是
OrbNet-Equi 学习 “分子结构 - 能量” 映射的核心依据</p></li>
<li><p><strong>训练输出</strong>：QM9 中的0K
内能作为核心训练目标输出，0K
内能是分子势能面（PES）计算的核心属性，直接关联分子稳定性与反应能垒预测，相比其他属性（如偶极矩），能量是闭壳层与开壳层系统共有的关键指标，便于后续扩展到开壳层能量预测。</p></li>
</ul>
<h2 id="复现方式">1.3 复现方式：</h2>
<p>数据小型化复现： setp1: 5k bonds and edges</p>
<p>setp2: 10k bonds and edges</p>
<p>setp3: 20k bonds and edges</p>
<h2 id="两种数据空间一个待理解的概念open-shell">1.4
两种数据空间一个待理解的概念Open-shell：</h2>
<ul>
<li><strong>AO (Atomic
Orbital)</strong>：<strong>原子轨道</strong>。</li>
<li><strong>MO (Molecular
Orbital)</strong>：<strong>分子轨道</strong>。</li>
<li><strong>Open-shell</strong>：<strong>开壳层组态</strong>。</li>
</ul>
<h4 id="ao-atomic-orbital---原子轨道层面-以原子为中心的模型">1. AO
(Atomic Orbital) - 原子轨道层面 / 以原子为中心的模型</h4>
<p>将分子看作是原子（节点）和化学键（边）构成的图。模型学习每个原子以及其周围局部环境的representation，预测整个分子的性质。</p>
<ul>
<li><p><strong>key</strong>:
分子的性质是由其组成原子以及原子间的相互作用决定的。</p></li>
<li><p><strong>输入</strong>:
原子的坐标、原子类型、以及原子间的距离或键合关系。</p></li>
<li><p><strong>方式</strong>: <strong>消息传递图神经网络 (Message
Passing Neural Network, MPNN)</strong>
。每个原子（节点）从其邻居原子那里接收“消息”（信息），更新自己的状态（特征向量）。过程会重复多次（对应图神经网络的多个GCL层），信息可以在整个分子中传播。</p>
<ul>
<li><strong>EGNN (E(n) Equivariant Graph Neural Network)</strong>:
典型的以原子为中心的模型。<strong>等变性
(Equivariance)</strong>，旋转或移动整个分子时，模型内部学习到的原子表示也会相应地旋转或移动，最终预测的能量等标量属性保持不变。符合物理规律，性能出色。它直接在原子的3D坐标上进行操作。</li>
<li><strong>OrbNet</strong>:
<strong>数据来源</strong>采用半经验方法（GFN1-xTB）生成量子化学矩阵，显著降低了计算成本，同时保留了关键物理信息,支持数千原子规模的分子模拟。
闭壳层（Closed-shell）与开壳层（Open-shell）系统的区别：闭壳层电子自旋全配对（仅需考虑空间自由度），开壳层含未配对电子（需同时考虑空间和自旋自由度），开壳层在自由基、反应中间体等场景的关键意义。
<ul>
<li><strong>key</strong>:
基于原子轨道（AO）特征（自洽场（SCF）收敛过程中的量子化学矩阵）预测分子能量。</li>
<li><strong>特征表示</strong>: 采用对称适配原子轨道（SAAO）基组，将 AO
特征编码为图结构数据。</li>
<li><strong>模型架构</strong>:
基于图神经网络（GNN），解码输出张量并求和得到分子能量。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="mo-molecular-orbital---分子轨道层面-以分子为整体的模型">2. MO
(Molecular Orbital) - 分子轨道层面 / 以分子为整体的模型</h4>
<p>直接学习或预测整个分子的全局属性，分子整体电子结构相关的属性。分子轨道本身就是由所有原子轨道线性组合而成的，描述了电子在整个分子中的运动状态。</p>
<ul>
<li><strong>key</strong>:
直接对分子的全局特征或其电子结构的宏观表现（如轨道能级）进行建模。</li>
<li><strong>典型输入</strong>: 整个分子的描述符（例如分子指纹
fingerprint），或者直接将分子结构作为输入来预测分子轨道的性质。</li>
<li><strong>工作方式</strong>:
这类模型可能不完全依赖于原子间的消息传递，而是旨在直接构建一个从分子到其全局属性的映射。例如，预测分子的最高占据分子轨道
(HOMO) 和最低未占据分子轨道 (LUMO) 的能量。</li>
</ul>
<h4 id="open-shell---开壳层组态">3. Open-shell - 开壳层组态</h4>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/620638044?write">Open-shell</a></p>
<p>随便看看的一篇ICML-2024 <a
target="_blank" rel="noopener" href="https://openreview.net/forum?id=XC9IoAsyEN">ICML-WORKSHOP-2024</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.nature.com/articles/s41524-022-00863-y">NPJ-2022</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.pnas.org/doi/abs/10.1073/pnas.2205221119">PNAS-2022
OrbNet-Equi</a> <a
target="_blank" rel="noopener" href="https://zenodo.org/records/6568518#.YrtTKHbMK38">!!! orbnet
qm9的graph based的feature</a></p>
<h1 id="十月份规划">2. 十月份规划：</h1>
<h2 id="what-we-need-to-do">2.1 What we need to do?</h2>
<h2 id="我们需要分析ao-和-mo-的表现">我们需要分析AO 和 MO 的表现。</h2>
<p>我们不确定MO和AO的variability的差异，是由EGNN还是GPR带来的
他们的information不一样。</p>
<p>Learning curve - learnability图</p>
<p>我们需要通过对比学习找到 AO 和 MO 的 similarity。</p>
<p>理想化结果：
我们希望AO通过对比学习达到MO的程度，我们希望对比学习对AO更有用。</p>
<p>我们希望达到GCL + AO</p>
<p>AO从物理意义上更本质，MO的性质更好。</p>
<p>Final goal Inverse design 需要生成 AO</p>
<h2 id="linear-combination-of-atomic-orbitals">2.2 (Linear Combination
of Atomic Orbitals)</h2>
<p><strong>LCAO</strong> <strong>原子轨道线性组合 (Linear Combination of
Atomic Orbitals)</strong>。</p>
<ul>
<li><p><strong>key</strong>:
分子的复杂行为（由分子轨道MO描述）可以近似地通过其组成原子的更简单的行为（由原子轨道AO描述）来构建。一个<strong>分子轨道
(MO)</strong> 可以表示为多个<strong>原子轨道 (AO)</strong>
的加权和。</p></li>
<li><p><strong>数学形式</strong>: 一个分子轨道 <span
class="math inline">\(\Psi_{MO}\)</span>，它可以表示为： <span
class="math display">\[\Psi_{MO} = c_1\phi_1 + c_2\phi_2 + \dots +
c_n\phi_n = \sum_{i=1}^{n} c_i\phi_i\]</span> 其中：</p>
<ul>
<li><span class="math inline">\(\Psi_{MO}\)</span>
是一个分子轨道波函数。</li>
<li><span class="math inline">\(\phi_i\)</span> 是第 <span
class="math inline">\(i\)</span> 个原子的原子轨道波函数。</li>
<li><span class="math inline">\(c_i\)</span>
是每个原子轨道的<strong>组合系数
(coefficient)</strong>，它是一个权重值，表示该原子轨道对这个分子轨道的贡献大小。系数通过求解薛定谔方程（通常使用Hartree-Fock等近似方法）得到的。</li>
</ul></li>
<li><p><strong>ex</strong>:
氢分子（H₂）。有两个氢原子，每个氢原子有一个1s原子轨道（<span
class="math inline">\(\phi_A\)</span> 和 <span
class="math inline">\(\phi_B\)</span>）。这两个原子轨道可以通过两种方式线性组合，形成两个分子轨道：</p>
<ol type="1">
<li><strong>成键轨道 (Bonding MO)</strong>: <span
class="math inline">\(\Psi_{\sigma} = c_A\phi_A +
c_B\phi_B\)</span>。电子处于这个轨道时，会主要分布在两个原子核之间，形成稳定的化学键。能量比原来的AO更低。</li>
<li><strong>反键轨道 (Antibonding MO)</strong>: <span
class="math inline">\(\Psi_{\sigma^*} = c&#39;_A\phi_A -
c&#39;_B\phi_B\)</span>。电子处于这个轨道时，会主要分布在原子核的外侧，排斥两个原子核，不利于成键。能量比原来的AO更高。</li>
</ol></li>
</ul>
<h3 id="localization-分子轨道局域化">2.3 Localization
(分子轨道局域化)</h3>
<p>分子轨道（MOs），尤其是通过标准计算方法（如Hartree-Fock）直接求解出来的，通常是<strong>离域的
(delocalized)</strong>。这意味着每个MO都可能扩展到整个分子，由分子中几乎所有原子的AOs贡献构成。例如，在苯环中，计算出的π电子MO会均匀地分布在六个碳原子上。</p>
<p><strong>分子轨道局域化 (Localization of Molecular Orbitals)</strong>
就是一个数学变换过程，它将这些离域的MOs转化为一组新的<strong>局域化分子轨道
(Localized Molecular Orbitals, LMOs)</strong>。</p>
<ul>
<li><strong>核心目标</strong>:
在不改变分子整体波函数和总能量的前提下，将分子轨道尽可能地限制在空间中的一小块区域内。</li>
<li><strong>变换结果</strong>:
<ul>
<li>离域的成键轨道 <span class="math inline">\(\rightarrow\)</span>
对应于特定 <strong>化学键</strong>
的局域轨道（例如C-H键，C=C双键）。</li>
<li>离域的非键轨道 <span class="math inline">\(\rightarrow\)</span>
对应于特定原子上的 <strong>孤对电子 (lone pair)</strong> 或
<strong>内层电子</strong>。</li>
</ul></li>
<li><strong>局域化</strong>:
<ol type="1">
<li><strong>化学直观性</strong>:
LMOs提供了清晰的化学图像，便于理解和分析化学成键情况。</li>
</ol></li>
</ul>
<h3 id="lcao-和-mo-的关系">3. LCAO 和 MO 的关系</h3>
<ol type="1">
<li><strong>LCAO是构建MO的方法</strong>:
LCAO是用于近似计算和表示分子轨道（MO）的数学框架。我们假设MO可以由一组已知的基函数（即原子轨道AO）线性组合而成。</li>
<li><strong>MO是LCAO方法的结果</strong>:
通过LCAO方法，结合量子力学变分原理求解薛定谔方程，我们最终得到了一系列分子轨道（MOs）的具体形式（即每个AO的贡献系数<span
class="math inline">\(c_i\)</span>）以及它们的能量。</li>
</ol>
<p><strong>原子轨道 (AO) [输入]</strong> <span
class="math inline">\(\xrightarrow{\text{LCAO方法 [过程/框架]}}\)</span>
<strong>分子轨道 (MO) [输出/结果]</strong></p>
<h3 id="高斯过程回归-gaussian-process-regression-gpr">4. 高斯过程回归
(Gaussian Process Regression, GPR)</h3>
<p><strong>高斯过程回归 (GPR)</strong>
是一种基于贝叶斯思想的非参数回归方法。它在处理小样本、高维度、需要不确定性估计的复杂回归问题时特别有效。</p>
<h4 id="key">key</h4>
<p><strong>GPR的核心是直接对函数本身进行建模</strong>。它假设我们想要建模的目标函数
<span class="math inline">\(f(x)\)</span> 是一个服从<strong>高斯过程
(Gaussian Process, GP)</strong> 的随机函数。</p>
<ul>
<li><strong>高斯过程 (GP)</strong>
一个高斯过程是无穷多个随机变量的集合，其中任意有限个随机变量的组合都服从一个联合高斯分布。
一个GP定义了一个关于<strong>函数的分布 (a distribution over
functions)</strong>。当我们从这个GP中“采样”时，我们得到的不是一个数值，而是一整个函数。</li>
</ul>
<p>一个高斯过程完全由两部分定义： 1. <strong>均值函数 (Mean Function)
<span class="math inline">\(m(x)\)</span></strong>:
定义了函数分布的“期望”或“中心趋势”。通常为了简化，会假设均值为零。 2.
<strong>协方差函数 (Covariance Function) 或 核函数 (Kernel) <span
class="math inline">\(k(x, x&#39;)\)</span></strong>:
定义了函数在不同输入点 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(x&#39;\)</span>
处的值之间的“相关性”或“相似性”。如果 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(x&#39;\)</span> 很接近，核函数的值就很大，意味着
<span class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(f(x&#39;)\)</span>
的值会很相似。这编码了我们对函数平滑性的先验信念。</p>
<h4 id="gpr-工作">GPR 工作</h4>
<p>GPR的工作流程：</p>
<p><strong>第一步：定义先验分布 (Prior Distribution)</strong>
在看到任何训练数据之前，我们首先根据先验知识选择一个均值函数（通常为0）和一个核函数（例如常用的<strong>径向基函数核/RBF核</strong>）。这个GP定义了一个函数的先验分布，包含了我们能想到的所有“可能”的函数。</p>
<p><strong>第二步：计算后验分布 (Posterior Distribution)</strong>
当我们得到一组训练数据 <span class="math inline">\((X_{train},
Y_{train})\)</span>
后，我们利用贝叶斯定理来更新我们的函数分布。我们从先验分布中“筛选”掉那些与训练数据不符的函数，得到一个<strong>后验分布
(Posterior Distribution)</strong>。</p>
<p>这个后验分布仍然是一个高斯过程，其均值和协方差有解析解（可以直接计算出来），不需要复杂的迭代优化。</p>
<h4 id="进行预测">进行预测</h4>
<p>对于一个新的测试点 <span
class="math inline">\(x_{test}\)</span>，我们想预测对应的 <span
class="math inline">\(y_{test}\)</span>。在后验分布下，<span
class="math inline">\(y_{test}\)</span>
的预测值服从一个一维高斯分布，这个分布有： 1. <strong>预测均值
(Predicted Mean)</strong>: 这就是我们对 <span
class="math inline">\(y_{test}\)</span>
的最佳点估计。它是由训练数据点的加权平均计算得出的，权重由核函数决定。
2. <strong>预测方差 (Predicted Variance)</strong>:
这衡量了我们对预测结果的<strong>不确定性</strong>。在靠近训练数据点的地方，方差会很小（预测很自信）；在远离训练数据点的未知区域，方差会很大（预测很不确定）。</p>
<h1 id="后续规划">3. 后续规划：</h1>
<p>IF AO 的学习表现比 MO 要好 我们将会聚焦于 AO （Atomic representation
vs atomic orbital）</p>
<ol type="1">
<li><strong>AO one body decomposition</strong></li>
<li><strong>MO two body decomposition</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/15/Pandoc_Deployment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/15/Pandoc_Deployment/" class="post-title-link" itemprop="url">BLOGS - Pandoc Deployment</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-15 10:00:00" itemprop="dateCreated datePublished" datetime="2025-09-15T10:00:00+08:00">2025-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:55" itemprop="dateModified" datetime="2025-09-19T19:24:55+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Download <a
target="_blank" rel="noopener" href="https://github.com/jgm/pandoc/releases/tag/3.8">Pandoc</a>!</p>
<p><strong>pandoc-3.8-windows-x86_64.msi</strong></p>
<h2
id="问题主要为了解决默认的next渲染器无法渲染复杂公式的问题">【问题】主要为了解决默认的Next渲染器无法渲染复杂公式的问题</h2>
<h3
id="step1在系统变量中找到path点击编辑">Step1:在系统变量中找到<strong>Path→点击编辑</strong></h3>
<h3
id="step2点击新建输入pandoc.exe的父目录路径c点击确定">Step2:点击新建→输入pandoc.exe的父目录路径（C:）→点击确定</h3>
<h3 id="step3重启终端">Step3:重启终端</h3>
<h3
id="step4安装pandoc-3.8-windows-x86_64.msi">Step4:安装pandoc-3.8-windows-x86_64.msi</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pandoc --version</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list --depth=0 | Select-String <span class="string">&quot;renderer&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list --depth=0 | Select-String <span class="string">&quot;renderer&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://blog.csdn.net/gitblog_00216/article/details/141763934">Ref</a></p>
<h3
id="step5在你所在的博客头加入必要的引入">Step5:在你所在的博客头加入必要的引入</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mathjax: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3
id="step6在d_ailab_hkust_machine_learning的_config.yaml文件中确保你的pandoc路径能被找到">Step6:在D:_AILab_HKUST_Machine_Learning的_config.yaml文件中确保你的Pandoc路径能被找到</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pandoc:</span><br><span class="line">$ pandoc_path: <span class="string">&quot;C:/Users/Aprine/AppData/Local/Pandoc/pandoc.exe&quot;</span> <span class="comment"># </span></span><br><span class="line">$ args:</span><br><span class="line">$   - <span class="string">&quot;--mathjax&quot;</span></span><br></pre></td></tr></table></figure>
<h3
id="step7在d_ailab_hkust_machine_learning_config.yaml文件中确保你的math信息配置正确">Step7:在D:_AILab_HKUST_Machine_Learning_config.yaml文件中确保你的math信息配置正确</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mathjax:</span><br><span class="line">$   <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">$   <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">$   mhchem: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3
id="step8修改你的head文件的基础格式">Step8:修改你的head文件的基础格式</h3>
<p>More info: <a
target="_blank" rel="noopener" href="https://blog.csdn.net/ALexander_Monster/article/details/105717091">Ref</a></p>
<h3 id="push-new-blog">Push new blog</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$   hexo g -d</span><br></pre></td></tr></table></figure>
<p>对比损失函数（InfoNCE/NT-Xent Loss）定义为： <span
class="math inline">\(\mathcal{L}_{\text{q}} = -\log \underbrace{\left(
\frac{\exp\left( \mathbf{q} \cdot \mathbf{k}^{+} / \tau
\right)}{\exp\left( \mathbf{q} \cdot \mathbf{k}^{+} / \tau \right) +
\sum\limits_{i=1}^{N} \exp\left( \mathbf{q} \cdot \mathbf{k}_{i}^{-} /
\tau \right)} \right)}_{\text{Softmax 概率}}\)</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/14/contrastive_learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/14/contrastive_learning/" class="post-title-link" itemprop="url">PAPER READING - Contrastive Learning</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-14 21:00:00" itemprop="dateCreated datePublished" datetime="2025-09-14T21:00:00+08:00">2025-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:40" itemprop="dateModified" datetime="2025-09-19T19:24:40+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用于无监督视觉表示学习的动量对比 <a
target="_blank" rel="noopener" href="https://arxiv.org/abs/1911.05722v3">Momentum Contrast for
Unsupervised Visual Representation Learning</a></p>
<h1 id="momentum-contrast">1. Momentum Contrast</h1>
<h2 id="定义">1.1 定义</h2>
<ul>
<li><strong>内容</strong>: 对比学习（Contrastive Learning）
通过让模型学习区分相似<strong>正样本</strong>与不相似<strong>负样本</strong>的数据点来学习有用的特征。</li>
</ul>
<h2 id="正样本对positive-pairs">1.2 正样本对（Positive Pairs）:</h2>
<ul>
<li><strong>内容</strong>:
通常来自同一数据点的不同数据增强视图（例如，同一张图片的两次随机裁剪、颜色抖动等）。它们应该具有相似的语义信息。</li>
</ul>
<h2 id="负样本negatives">1.3 负样本（Negatives）:</h2>
<ul>
<li><strong>内容</strong>:
来自与<strong>查询样本</strong>不同的其他数据点。它们代表不同的语义内容。</li>
</ul>
<h2 id="目标-模型的目标是学习一个编码器encoder">1.4 目标:
模型的目标是学习一个编码器（Encoder）</h2>
<ul>
<li><strong>内容</strong>:
查询样本与其对应的正样本在特征空间中的距离<strong>很近</strong>（相似度高）。</li>
<li><strong>内容</strong>:
查询样本与大量负样本在特征空间中的距离<strong>很远</strong>（相似度低）。</li>
</ul>
<h1 id="创新">2. 创新</h1>
<h2 id="动态字典dynamic-dictionary">2.1 动态字典（Dynamic
Dictionary）:</h2>
<ul>
<li><strong>内容</strong>: MoCo
维护一个<strong>先进先出FIFO</strong>的队列来存储编码后的特征<strong>Keys</strong>。</li>
<li><strong>内容</strong>:当前批次的数据经过键编码器编码后，其特征被入队添加到字典队列尾部。</li>
<li><strong>内容</strong>:同时，队列中最老的批次特征被出<strong>队dequeue</strong>
移除。</li>
<li><strong>内容</strong>:队列可以将字典大小 <span
class="math inline">\(K\)</span>
设计得远大于单个批次的大小，从而提供海量且一致的负样本来源（一致性由下面的动量更新保证）。队列解耦了字典大小与批次大小的限制。</li>
</ul>
<h2 id="动量更新编码器momentum-update-of-key-encoder">2.2
动量更新编码器（Momentum Update of Key Encoder）:</h2>
<ul>
<li><strong>内容</strong>:
查询编码器使用标准的梯度下降更新（<strong>SGD</strong>）</li>
<li><strong>内容</strong>:
键编码器<strong>不通过反向传播更新</strong>。</li>
<li><strong>内容</strong>: 键编码器的参数 <span
class="math inline">\(θ_k\)</span> 通过动量更新<strong>Momentum
Update</strong>从查询编码器的参数 <span
class="math inline">\(θ_q\)</span> 获得：<span class="math display">\[
\theta_k \gets m \cdot \theta_k + (1 - m) \cdot \theta_q \]</span>其中
<span class="math inline">\(m\)</span> 是一个动量系数（如 <span
class="math inline">\(m\)</span> = <span
class="math inline">\(0.999\)</span>），非常接近<span
class="math inline">\(1\)</span>。 ## 2.3 优势:</li>
<li><strong>内容</strong>:动量更新使得键编码器 <span
class="math inline">\(f_k\)</span> 的参数变化非常缓慢和平滑。</li>
</ul>
<h1 id="对比损失函数infonce-loss">3. 对比损失函数（InfoNCE Loss:</h1>
<h2 id="infonce-loss-noise-contrastive-estimation-loss">3.1 InfoNCE Loss
(Noise-Contrastive Estimation Loss)：</h2>
<p>对比损失函数（InfoNCE/NT-Xent Loss）定义为： <span
class="math inline">\(\mathcal{L}_{\text{q}} = -\log \underbrace{\left(
\frac{\exp\left( \mathbf{q} \cdot \mathbf{k}^{+} / \tau
\right)}{\exp\left( \mathbf{q} \cdot \mathbf{k}^{+} / \tau \right) +
\sum\limits_{i=1}^{N} \exp\left( \mathbf{q} \cdot \mathbf{k}_{i}^{-} /
\tau \right)} \right)}_{\text{Softmax 概率}}\)</span></p>
<h2 id="其中">3.2其中：</h2>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(\mathbf{q}\)</span></td>
<td>查询向量（Query Vector）：由查询编码器 <span
class="math inline">\(f_q\)</span> 输出（如 <span
class="math inline">\(2048\)</span> 维）。</td>
</tr>
<tr>
<td><span class="math inline">\(\mathbf{k}^{+}\)</span></td>
<td>正样本键向量（Positive Key）：由键编码器 <span
class="math inline">\(f_k\)</span>
输出（来自同一数据的不同增强视图）。</td>
</tr>
<tr>
<td><span class="math inline">\(\mathbf{k}_{i}^{-}\)</span></td>
<td>负样本键向量（Negative Keys）：来自字典队列的其他数据样本（数量为
<span class="math inline">\(N\)</span>，如 <span
class="math inline">\(65536\)</span>）。</td>
</tr>
<tr>
<td><span class="math inline">\(\tau\)</span></td>
<td>温度参数（Temperature）：控制相似度分布的尖锐程度（典型值 <span
class="math inline">\(0.05 \sim 0.2\)</span>）。</td>
</tr>
<tr>
<td><span class="math inline">\(\cdot\)</span></td>
<td>向量点积（L2归一化后等价于余弦相似度，即 <span
class="math inline">\(\mathbf{q} \cdot \mathbf{k} =
\cos\theta\)</span>）。</td>
</tr>
</tbody>
</table>
<h2 id="数据流">3.2 数据流：</h2>
<ul>
<li><strong>原始输入</strong>: 一张图片 <strong>P.jpg</strong>
(<strong>256x256</strong> 原始尺寸)</li>
<li><strong>预处理Step1</strong>: 随机裁剪出 <strong>224x224</strong>
的区域</li>
<li><strong>预处理Step2</strong>: 随机轻微改变颜色和亮度。</li>
<li><strong>预处理Step3</strong>: 归一化像素值。</li>
<li><strong>结果</strong>: <strong>[3, 224, 224]</strong> (一个
<strong>3x224x224</strong> 的张量)。输入到编码器的形式。</li>
<li><strong>查询编码器 <span class="math inline">\(f_q\)</span>
处理</strong>:</li>
<li><strong>Step1</strong>: 输入：<strong>[3, 224, 224]</strong>
张量。</li>
<li><strong>Step2</strong>: 经过<strong>Model</strong></li>
<li><strong>Step3</strong>: 全局平均池化层 (Global Average Pooling)
将空间维度压缩掉。</li>
<li><strong>Step4</strong>: 一个线性投影层将特征维度映射到
<strong>D</strong>。</li>
<li><strong>结果</strong>:一个 <span class="math inline">\(D\)</span>
维（如 <span class="math inline">\(M\)</span> 维）的归一化向量 <span
class="math inline">\(q\)</span>。这个 <span
class="math inline">\(q\)</span>
代表了经过裁剪、颜色扰动后的猫头像的抽象特征。例如， <strong>[0.12,
-0.05, 0.87, …, 0.03]</strong> (<span
class="math inline">\(M\)</span>个数值)。</li>
<li><strong>键编码器 <span class="math inline">\(f_k\)</span>
处理</strong>:</li>
<li><strong>Step1</strong>: 输入：<strong>[3, 224, 224]</strong>
张量。(对 <strong>P.jpg</strong> 应用另一组随机预处理得到的另一个
<strong>[3, 224, 224]</strong> 张量。)</li>
<li><strong>Step2</strong>: 经过结构相同但参数由动量更新的 <span
class="math inline">\(f_k\)</span>。</li>
<li><strong>Step3</strong>: 一个 <span class="math inline">\(D\)</span>
维（如 <span class="math inline">\(M\)</span> 维）的归一化向量 <span
class="math inline">\(k\)</span>。例如 <strong>[0.15, -0.08, 0.84, …,
0.02]</strong>。这个 <span class="math inline">\(k\)</span>
代表了同一数据但不同视角/颜色下的抽象特征。</li>
<li><strong>动态字典</strong>:</li>
<li><strong>Step1</strong>:包含之前通过 <span
class="math inline">\(f_k\)</span> 计算出的 <span
class="math inline">\(k\)</span> 向量。例如，队列大小是 <span
class="math inline">\(L\)</span>，里面存储了 <span
class="math inline">\(L\)</span> 个不同的 <strong>D=128</strong>
维向量，每个代表处理过的一张数据的特征。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/14/CaltechData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/14/CaltechData/" class="post-title-link" itemprop="url">Criegee, H10 chain, small radicals, water bond dissociation, and QMSpin energy datasets with MOB features for MOB-ML(KA-GPR)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-14 20:30:00" itemprop="dateCreated datePublished" datetime="2025-09-14T20:30:00+08:00">2025-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-15 01:42:44" itemprop="dateModified" datetime="2025-09-15T01:42:44+08:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI4chemistry/" itemprop="url" rel="index"><span itemprop="name">AI4chemistry</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用于MOB-ML（KA-GPR）的Criegee、H10链、小自由基、水键解离和具有MOB特征的QMSpin能量数据集
<a
target="_blank" rel="noopener" href="https://data.caltech.edu/records/cvjkq-tjt86">CaltechData</a>!</p>
<p>Criegee, H10 chain, small radicals, water bond dissociation, and
QMSpin energy datasets with MOB features for MOB-ML(KA-GPR)</p>
<h2 id="目录">目录</h2>
<ol type="1">
<li><a href="#Criegee数据集%20criegee.zip">Criegee数据集)</a><br />
</li>
<li><a href="#H10链数据集%20h10.zip">H10链数据集</a><br />
</li>
<li><a
href="#小自由基数据集%20small_radicals.zip">小自由基数据集</a><br />
</li>
<li><a
href="#水分子键解离数据集%20h2o_dissociation.zip">水分子键解离数据集</a></li>
<li><a href="#QMSpin数据集%20qmspin.zip">QMSpin数据集</a></li>
</ol>
<h2 id="criegee数据集">1. Criegee数据集</h2>
<h3 id="能量文件-criegee.csv">1.1 能量文件 (criegee.csv)</h3>
<ul>
<li><strong>内容</strong>: 包含 RHF 和 MRCI+Q 能量（cc-pVTZ 基组计算）。
### 1.2 诊断文件 (criegee_diagnostic.csv):</li>
<li><strong>内容</strong>: 包含 CCSD/cc-pVTZ 计算的 T1 和 D1 诊断指标。
### 1.3 结构文件夹 (共 800 个):</li>
<li><strong>内容</strong>: geo.xyz: 分子构型坐标</li>
<li><strong>内容</strong>: features_tz.hdf5: 用于 KA-GPR 的 对角 MOB
特征。</li>
</ul>
<h2 id="待学习rhf-mrciq-cc-ka-gpr-mob">待学习：RHF, MRCI+Q, CC, KA-GPR,
MOB</h2>
<h2 id="h10-链数据集-h10.zip">2. H10 链数据集 (h10.zip)</h2>
<h3 id="能量文件-h10.csv">2.1 能量文件 (h10.csv):</h3>
<ul>
<li><strong>内容</strong>: 包含 RHF 和 MRCI+Q-F12 能量（cc-pVTZ-F12
基组计算）。 ### 2.2 结构文件夹:</li>
<li><strong>内容</strong>: geo.xyz: 分子构型坐标</li>
<li><strong>内容</strong>: features_tz.hdf5: 用于 KA-GPR 的 对角 MOB
特征。</li>
</ul>
<h2 id="待学习rhf-mrciq-cc-ka-gpr-mob-1">待学习：RHF, MRCI+Q, CC,
KA-GPR, MOB</h2>
<h2 id="小自由基数据集-small_radicals.zip">3. 小自由基数据集
(small_radicals.zip)</h2>
<h3 id="包含-9-种自由基每种自由基有">3.1 包含 9
种自由基，每种自由基有：</h3>
<h3 id="能量文件-x.csv">3.1.1 能量文件 (x.csv):</h3>
<ul>
<li><strong>内容</strong>: 包含 ROHF 和 MRCI+Q 能量（cc-pVTZ
基组计算）。 ### 3.1.2 热化结构文件夹 (每种 200 个):</li>
<li><strong>内容</strong>: geo.xyz: 分子构型坐标</li>
<li><strong>内容</strong>: features_alpha.hdf5: α 自旋轨道的 MOB
特征</li>
<li><strong>内容</strong>: features_beta.hdf5: β 自旋轨道的 MOB
特征。</li>
</ul>
<h2
id="待学习rhf-rohf-mrciq-cc-ka-gpr-mob-α-自旋轨道的-mob-特征-β-自旋轨道的-mob-特征">待学习：RHF,
ROHF, MRCI+Q, CC, KA-GPR, MOB, α 自旋轨道的 MOB 特征, β 自旋轨道的 MOB
特征</h2>
<h2 id="水分子键解离数据集-h2o_dissociation.zip">4. 水分子键解离数据集
(h2o_dissociation.zip)</h2>
<h3 id="能量文件-h2o_dissociation.csv">4.1 能量文件
(h2o_dissociation.csv)</h3>
<ul>
<li><strong>内容</strong>: 包含 初始构象 ID、OH
键解离路径的键长比例因子、ROHF 和 MRCI+Q 能量（aug-cc-pVTZ 基组计算）。
### 4.2 初始构象文件夹 (共 50 个): ### 4.2.1 每个构象包含 20
个解离路径结构:</li>
<li><strong>内容</strong>: features_alpha.hdf5: α 自旋轨道的 MOB
特征</li>
<li><strong>内容</strong>: features_beta.hdf5: β 自旋轨道的 MOB
特征。</li>
</ul>
<h2
id="待学习初始构象-idoh-键解离路径的键长比例因子-rohf-mrciq-cc-α-自旋轨道的-mob-特征-β-自旋轨道的-mob-特征">待学习：初始构象
ID、OH 键解离路径的键长比例因子, ROHF, MRCI+Q, CC, α 自旋轨道的 MOB
特征, β 自旋轨道的 MOB 特征</h2>
<h2 id="qmspin-数据集-qmspin.zip">3. QMSpin 数据集 (qmspin.zip)</h2>
<h3 id="能量文件-qmspin.csv">3.1 能量文件 (qmspin.csv)：</h3>
<ul>
<li><strong>内容</strong>: 包含 单重态 (RHF) 和 三重态 (ROHF) 的 MRCI+Q
能量（cc-pVDZ 基组计算），自旋状态标记为 0（单重态）或 2（三重态）。 ###
3.2 结构文件夹:</li>
<li><strong>内容</strong>: geometries_singlet: 单重态优化结构</li>
<li><strong>内容</strong>: geometries_triplet: 三重态优化结构</li>
<li><strong>内容</strong>: 单重态特征文件:features_dz_singlet.hdf5:
单重态能量的 MOB 特征</li>
<li><strong>内容</strong>: 单重态特征文件:features_dz_singlet.hdf5:
单重态能量的 MOB 特征</li>
<li><strong>内容</strong>:
三重态特征文件:features_alpha_dz_triplet.hdf5: α 自旋轨道特征
features_beta_dz_triplet.hdf5: β 自旋轨道特征。</li>
</ul>
<h2
id="待学习rhf-rohf-mrciq-cc-mob-α-自旋轨道的-mob-特征-β-自旋轨道的-mob-特征">待学习：RHF,
ROHF, MRCI+Q, CC, MOB, α 自旋轨道的 MOB 特征, β 自旋轨道的 MOB 特征</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tianyaoblogs.github.io/2025/09/12/Build_up_my_UST_Blogs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TianyaoBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/12/Build_up_my_UST_Blogs/" class="post-title-link" itemprop="url">BLOGS - Manage double Github Accounts and Build up my UST Blogs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-12 18:30:00" itemprop="dateCreated datePublished" datetime="2025-09-12T18:30:00+08:00">2025-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 19:24:21" itemprop="dateModified" datetime="2025-09-19T19:24:21+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a
href="https://tianyaoblogs.github.io/">TianyaoBlogs</a>! This is my very
first post. It has shown my process of building blogs!</p>
<h2 id="start-to-own-your-blogs">Start to own your blogs</h2>
<h3 id="download-nodejs-npm-and-check-its-version">Download NodeJS &amp;
npm and check its version</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://www.nodejs.com.cn/download.html">Download</a> More info:
<a
target="_blank" rel="noopener" href="https://blog.csdn.net/Natsuago/article/details/145567734">Download</a></p>
<h3 id="prepare-your-path">Prepare your path</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Program Files (x86)\node_modules\node_global&quot;</span></span><br><span class="line">$ npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\Program Files (x86)\node_modules\node_cache&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://blog.csdn.net/Natsuago/article/details/145567734">Check</a></p>
<h3 id="check-your-environmental-path">Check your environmental
path</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> %NODE_PATH%</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://blog.csdn.net/Natsuago/article/details/145567734">Check</a></p>
<h3
id="generate-ssh-keys-for-the-second-account-for-those-people-who-have-two-or-more-github-account">Generate
SSH keys for the second account (For those people who have two or more
github account)</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@second_account.com&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="add-the-new-public-key-to-the-second-github-account">Add the new
public key to the second GitHub account</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$   <span class="built_in">cat</span> ~/.ssh/id_ed25519_second.pub</span><br></pre></td></tr></table></figure>
<h3 id="configuring-ssh-multi-account-rules">Configuring SSH
multi-account rules</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$    cnano ~/.ssh/config</span><br><span class="line">$    <span class="comment">#  (peninsula824)</span></span><br><span class="line">$    Host github.com-peninsula</span><br><span class="line">$    HostName github.com</span><br><span class="line">$    User git</span><br><span class="line">$    IdentityFile ~/.ssh/id_rsa  <span class="comment"># peninsula824_key</span></span><br><span class="line">$    IdentitiesOnly <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">$    <span class="comment">#  (TianyaoBlogs)</span></span><br><span class="line">$    Host github.com-tianyao</span><br><span class="line">$    HostName github.com</span><br><span class="line">$    User git</span><br><span class="line">$    IdentityFile ~/.ssh/0901102262  <span class="comment"># TianyaoBlogs_key</span></span><br><span class="line">$    IdentitiesOnly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="test-the-connection">Test the connection</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$   ssh -T git@github.com-peninsula</span><br><span class="line">$   ssh -T git@github.com-tianyao</span><br></pre></td></tr></table></figure>
<h3 id="update-hexo-deployment-configuration">Update Hexo deployment
configuration</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$   deploy:</span><br><span class="line">$     <span class="built_in">type</span>: git</span><br><span class="line">$    repo: </span><br><span class="line">$       github: git@github.com-tianyao:TianyaoBlogs/TianyaoBlogs.github.io.git</span><br><span class="line">$     branch: main</span><br></pre></td></tr></table></figure>
<h3 id="complete-the-deployment">Complete the deployment</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$   hexo clean</span><br><span class="line">$   hexo generate</span><br><span class="line">$   hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="push-new-blog">Push new blog</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$   hexo g -d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
